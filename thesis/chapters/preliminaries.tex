\section{General Notation and Definitions}\label{sec:generalNotationDefinitions}

\paragraph{Notation}
We first define the general notation used in the following chapters to formalize procedures and protocols. Let $\cnstGroup$ denote a cyclic group of prime order $\varPrime$ and $\cnstIntegersPrime{\varPrime}$
the ring of integers modulo $\varPrime$. $\cnstIntegersPrimeWithoutZero{\varPrime}$ is $\cnstIntegersPrime{\varPrime} \opExcluding \funList{0}$. $\varG \opSeperate \varH$ are adjacent
generators in $\cnstGroup$, whereas adjacent means the discrete logarithm of $\varH$ in regards to $\varG$ is not known. Exponention stands for repeated application of the group operation.

\begin{definition}{Hard Relation}\label{def:hardRelation}
    Given a language $\varLanguage \opAssign \funList{\varBigA \opForWhich \exists\varSmallA \text{ s.t. } (\varBigA, \varSmallA) \opIn \cnstRelation}$ then the relation $\cnstRelation$ is
    considered hard if the following three properties hold:~\cite{sanches2020bitcoinchannels}
    \begin{enumerate}
        \item $\procGenR{\varSecParam}$ is a $\cnstPolyTime$ sampling algorithm which outputs a statement/witness of the form $(\varBigA, \varSmallA) \opIn \cnstRelation$.
        \item Relation $\cnstRelation$ is poly-time decidable.
        \item For all $\cnstPolyTime$ adversaries $\cnstAdversary$ the probability of finding $\varSmallA$ given $\varBigA$ is neglible.
    \end{enumerate}
\end{definition}

\begin{definition}{Signature Scheme}\label{def:signatureScheme}
    A valid Signature Sccheme must provide three procedures:
    \[ \varSigScheme = (\procGenDefault \opSeperate \procSignDefault \opSeperate \procVerfDefault) \]
    $\procGenDefault$ takes as input a security parameter $\varSecParam$ and outputs a keypair $\varKeyPair$, consisting of a secret key $\varSecKey$ and a public key $\varPubKey$, whereas
    the secret key has to be kept private and the public key is shared with other parties.
    $\varSecKey$ can be used together with a message $\varMsg$ to call the $\procSignDefault$ procedure to create a signature $\varSignature$ over the message $\varMsg$.
    Parties knowing $\varPubKey$ can then test the validity of the signature by calling $\procVerfDefault$ with the same message $\varMsg$. The procedure will only output $1$ if the message was
    indeed signed with the correct secret key $\varSecKey$ of $\varPubKey$ and therefore proves the possesion of $\varSecKey$ by the signer.
    A valid signature scheme have to fullfill two security properties
    \begin{itemize}
        \item Correctness: For all messages $\varMsg$ and valid keypairs $\varKeyPair$ the following must hold $\procVerf{\varPubKey}{\procSignDefault}{\varMsg} \opEq 1$
        \item Unforgability: Note that there are different levels of Unforgability:~\cite{goldwasser1988digital}
        \begin{itemize}
            \item Universal Forgery: The ability to forge signatures for any message.
            \item Selective Forgery: The ability to fogre signatures for messages of the adversary's choice.
            \item Existential Forgery: The ability to forge a valid signature / message pair not previously known to the adversary.
        \end{itemize}
    \end{itemize}
\end{definition}

\begin{definition}{Cryptographic Hash Function}\label{def:hashFunction}
    A cryptographic hash function $\cnstHash$ is defined as $\funHash{\varInput} \rightarrow \cnstBinary{\varN}$ for some fixed number $\varN$ and some input $\varInput$. A secure hashing function
    has to fullfill the following security properties:~\cite{al2011cryptographic}
    \begin{itemize}
        \item Collision-Resistence (CR): Collision-Resistance means that it is computationally infeasible to find two inputs $\varInput_1$ and $\varInput_2$ such that
        $\funHash{\varInput_1} \opAssign \funHash{\varInput_2}$ with $\varInput_1 \opNotEq \varInput_2$.
        \item Pre-image Resistence (Pre): In a hash function $\cnstHash$ that fulfills Pre-image Resistance it is infeasible to recover the original input $\varInput$ from its hash output $\funHash{\varInput}$.
        If this security property is achieved, the hash function is said to be non-invertible.
        \item 2nd Pre-image Resistence (Sec):  This property is similar to Collision-Resistance and is sometimes referred to as \textit{Weak Collision-Resistance}.
        Given such a hash function $\cnstHash$ and an input $\varInput$, it should be infeasible to find a different input $\funStar{\varInput}$ such that $\varInput \opNotEq \funStar{\varInput}$
        and $\funHash{\varInput} \opEq \funHash{\funStar{\varInput}}$.
    \end{itemize}
\end{definition}

\begin{definition}{Commitment Scheme}\label{def:commitment}~\cite{bunz2018bulletproofs}
    A cryptographic Commitment is defined by a pair of functions $(\procSetup{\varSecParam} \opSeperate \procCommitId(\varInput, \varRand))$. $\procSetupId$ is the setup procedure, it takes as input a
    security parameter $\varSecParam$ and outputs public parameters $\varPublicParam$. Depending on $\varPublicParam$ we define a input space $\varInputSpace_{\varPublicParam}$,
    a randomness space $\varRandSpace_{\varPublicParam}$ and a commitment space $\varCommitSpace_{\varPublicParam}$.\\
    The function $\procCommitId$ takes an arbitrary input $\varInput \opIn \varInputSpace_{\varPublicParam}$, and a random value $\varRand \opIn \varRandSpace_{\varPublicParam}$ and
    generates an output$\varCommitment \opIn \varCommitSpace_{\varPublicParam}$.\\
    Secure commitments must fullfill the \textit{Binding} and \textit{Hiding} security properties:
    \begin{itemize}
        \item \textit{Binding:} If a Commitment Scheme is binding it must hold that for all $\cnstPolyTime$ adversaries $\cnstAdversary$ given a valid input $\varInput \opIn \varInputSpace_{\varPublicParam}$
        and randomness $\varRand \opIn \varRandSpace_{\varPublicParam}$ the probabilty of finding a $\funStar{\varInput} \opNotEq \varInput$ and a $\funStar{\varRand}$ with
        $\procCommit{\varInput}{\varRand} \opEq \procCommit{\funStar{\varInput}}{\funStar{\varRand}}$ is negligible.
        \item \textit{Hiding:} For a $\cnstPolyTime$ adversary $\cnstAdversary$, commitment inputs $\varInput \opIn \varInputSpace_{\varPublicParam} \opSeperate \varRand \opIn
       \varRandSpace_{\varPublicParam}$ and a commitment output $\varCommitment \opAssign \procCommit{\varInput, \varRand}$ the probabilty of the adversary choosing the correct input
        $\funList{\varInput, \funStar{\varInput}}$ must not be higher then $\frac{1}{2} + \funNegl{\varProbability}$.
    \end{itemize}
\end{definition}

\begin{definition}{Homomorphic Commitment}\label{def:homomorphicCom}
    If a Commitment Scheme as defined in~\ref{def:commitment} is homomorphic then the following must hold
    \[ \procCommit{\varInput_1}{\varRand_1} \opAdd \procCommit{\varInput_2}{\varRand_2} \opEq \procCommit{\varInput_1 \opAdd \varInput_2}{\varRand_1 \opAdd \varRand_2} \]
\end{definition}

\begin{definition}{Pedersen Commitment}\label{def:pedersenCom}
    A Pedersen Commitment is an instantiation of a Homomoprhic Commitment Scheme as definied in~\ref{def:homomorphicCom}:
    \[ \varCommitSpace_{\varPublicParam} \opAssign \cnstGroup\] of order $\varPrime \opSeperate \varInputSpace_{\varPublicParam} \opSeperate \varRandSpace_{\varPublicParam} \opAssign \cnstIntegersPrime{\varPrime}$.
    the procedures $(\procSetupId, \procCommitId)$ are then instantiated as:
    \[ \procSetup{\varSecParam} \opAssign \varG, \varH \sample \cnstGroup\]
    \[ \procCommit{\varInput}{\varRand} \opAssign \funGen{\varRand} \funGenH{\varInput} \]

\end{definition}


\section{Bitcoin}\label{sec:bitcoin}

\subsection{Bitcoin Transaction Protocol}\label{sec:bitcoinTx}

\subsection{Bitcoin Scaling and Layer Two Solutions}\label{sec:bitcoinScaling}


\section{Privacy-enhancing Cryptocurrencies}\label{sec:privacyCryptos}

\subsection{Zero Knowledge Proofs}\label{sec:zeroKnowlegde}

\subsection{Range Proofs}\label{sec:rangeProof}

\subsection{Mimblewimble}\label{sec:Mimblewimble}
In this section we will outline the fundamental properties of the protocols employed in Mimblewimble which are relevant for the thesis and particularily the construction of the Atomic Swap protocol defined in
\ref{chp:atomicSwap}.
\subsubsection{Transaction Structure}
\begin{itemize}
    \item For two adjacent elliptic curve generators $\varG$ and $\varH$ a coin in Mimblewimble is of the form $\varCoin \opAssign \funGen{\varValue} \opAdd \funGenH{\varRand} \opSeperate \varProof$. $\varCoin$ is a so called Pedersen Commitment \cite{pedersen1991non}
    to the value $\varValue$ with blinding factor $\varRand$. $\varProof$ is a range proof attesting to the fact that $\varValue$ is in a valid range in zero-knowledge.
    \item As already pointed out, there are now addresses in Mimblewimble. Ownership of a coin is equivalent to the knowledge of its opening, so the blinding factor takes the role of the secret key.
    \item A transaction consists of $\varCoinInp \opAssign (\varCoin_1 \opSeperate \dots \opSeperate \varCoin_n)$ input coins and $\varCoinOut \opAssign (\varCoin'_1 \opSeperate \dots \opSeperate \varCoin'_n)$ output coins.
\end{itemize}
A transaction is considered valid iff $\sum{\varValue'_i} \opSub \sum{\varValue_i} \opEq 0$ so the sum of all input values has to be 0. (Not taking transaction fees into account)\\
From that we can derive the following equation:
\[ \sum{\varCoinOut} \opSub \sum{\varCoinInp} \opAssign \sum{\funGenH{\varValue'_i} \opAdd \funGen{\varRand'_i}} \opSub \sum{\funGenH{\varValue_i} \opAdd \funGen{\varRand_i}} \]
So if we assume that a transaction is valid then we are left with the following so called excess value:
\[ \varExcess \opAssign \funGen{(\sum{\varRand'_i} \opSub \sum{\varRand_i})} \]
Knowledge of the opening of all coins and the validity of the transaction implies knowledge of $\varExcess$.
Directly revealing the opening to $\varExcess$ would leak too much information, an adversary knowing the openings for input coins and all but one output coin, could easily calculate the unknown opening given $\varExcess$.
Therefore knowledge of $\varExcess$ instead is proven by providing a valid signature for $\varExcess$ as public key.
Coinbase transactions (transactions creating new money as part of a miners reward) additionally include the newly minted money as supply $\varSupply$ in the excess equation:
\[ \varExcess \opAssign \funGen{(\sum{\varRand'_i} \opSub \sum{\varRand_i})} \opSub \funGenH{\varSupply} \]
Finally a Mimblewimble transaction is of form:
\[ \varTx \opAssign (\varSupply \opSeperate \varCoinInp \opSeperate \varCoinOut \opSeperate \varKernel)~\text{with}~\varKernel \opAssign (\funList{\varProof} \opSeperate \funList{\varExcess} \opSeperate \funList{\varSignature}) \]
where $\varSupply$ is the transaction supply amount, $\varCoinInp$ is the list of input coins, $\varCoinOut$ is the list of output coins and $\varKernel$ is the transaction Kernel. The Kernel consists of $\funList{\varProof}$
which is a list of all output coin range proofs, $\funList{\varExcess}$ a list of excess values and finally $\funList{\varSignature}$ a list of signatures ~\cite{fuchsbauer2019aggregate}.

\subsubsection{Transaction Merging}
An essential property of the Mimblewimble protocol is that two transactions can easily be merged into one, which is essentially a non-interactive version of the CoinJoin protocol on Bitcoin \cite{maxwell2013coinjoin}
Assume we have the following two transactions:
\[ \varTx_0 \opAssign (\varSupply_0 \opSeperate \varCoinInp^0 \opSeperate \varCoinOut^0 \opSeperate (\funList{\varProof_0} \opSeperate \funList{\varExcess_0} \opSeperate \funList{\varSignature_0}) ) \]
\[ \varTx_1 \opAssign (\varSupply_1 \opSeperate \varCoinInp^1 \opSeperate \varCoinOut^1 \opSeperate (\funList{\varProof_1} \opSeperate \funList{\varExcess_1} \opSeperate \funList{\varSignature_1}) ) \]
Then we can build a single merged transaction:
\[ \varTx_m \opAssign (\varSupply_0 \opAdd \varSupply_1 \opSeperate \varCoinInp^0 \opConc \varCoinInp^1,~\varCoinOut^0 \opConc \varCoinOut^1 \opSeperate (\funList{\varProof_0} \opConc \funList{\varProof_1}) \opSeperate
\funList{\varExcess_0} \opConc \funList{\varExcess_1} \opSeperate \funList{\varSignature_0} \opConc \funList{\varSignature_1}) \]
We can easily deduce that if $\varTx_0$ and $\varTx_1$ are valid, it follows that $\varTx_m$ also has to be valid:
If $\varTx_0$ and $\varTx_1$ are valid that means $\varCoinInp^0 \opSub \varCoinOut^0 \opSub \funGenH{\varSupply_0} \opAssign \varExcess_0 \opSeperate \funList{\varProof_0}$ contains valid range proofs for the outputs
$\varCoinOut^0$ and $\funList{\varSignature_0}$ contains a valid signature to $\varExcess_0 \opSub \funGenH{\varSupply_0}$ as public key, the same must hold for $\varTx_1$. \\
By the rules of arithmetic it then must also hold that
\[ \varCoinInp^0 \opConc \varCoinInp^1 \opSub \varCoinOut^0 \opConc \varCoinOut^1 \opSub \funGenH{\varSupply_0 \opAdd \varSupply_1} \opAssign \varExcess_0 \opAdd \varExcess_1 \opSeperate \funList{\varProof_0} \opConc \funList{\varProof_1} \]
must contain valid range proofs for the output coins and $\funList{\varSignature_0} \opConc \funList{\varSignature_1}$ must contain valid signatures to the respective Excess points, which makes $\varTx_m$ a valid transaction.

\subsubsection{Subset Problem}
A subtle problem arises with the way transactions are merged in Mimblewimble. From the shown construction, it is possible to reconstruct the original separate transactions from the merged one,
which can be a privacy issue. Given a set of inputs, outputs, and kernels, a subset of these will recombine to reconstruct one of the valid transaction which were aggregated since Kernel Excess values are not combined.
(which would invalidate the signatures and therefore break the security of the system) This problem has been mitigated in Cryptocurrencies implementing the protocol by including an
additional variable in the Kernel, called offset value. The offset is randomly chosen and needs to be added back to the Excess values to verify the sum of the commitments to zero.
\[ \sum{\varCoinOut} \opSub \sum\varCoinInp \opSub \funGenH{\varSupply} \opAssign \varExcess \opAdd \varOffset\]
Every time two transactions are merged, the offset values are combined into a single value. If offsets are picked truly randomly, and the possible range of values is broad enough, the probability of recovering the
uncombined offsets from a merged one becomes negligible, making it infeasable to recover original transactions from a merged one~\cite{poelstra2016mimblewimble}.

\subsubsection{Cut Through}
From the way transactions are merged together, we can now learn how to purge spent outputs securely. Let's assume $\varCoin_i$ appears as an output in $\varTx_0$ and as an input in $\varTx_1$,
which are being merged. Remembering the equation for transaction balancedness, $\varCoinInp \opSub \varCoinOut \opAssign \varExcess$ if $\varCoin_i$ appears both in the inputs and outputs, and we erase it on both sides, the equation will still hold.
Therefore every time a transaction spends an output, it can be virtually forgotten to improve transaction unlinkability as well as yielding saving space.

\subsubsection{The Ledger}
The ledger of the Mimblewimble protocol itself is a transaction of the already discussed form. Initially, the ledger starts empty, and transactions are added and aggregated recursively.
\begin{itemize}
    \item Only transactions in which input coins are contained in the output coins of the ledger will be valid.
    \item The supply of the ledger is the sum of the supplies of all transactions added so far. Therefore we can easily read the total circulating supply from the ledger state.
    \item Due to cut through, the input coin list of the ledger is always empty, and the output list is the set of UTXOs.
\end{itemize}

\subsubsection{Transaction Building}
As already pointed out, building transactions in Mimblewimble is an interactive process between the sender and receiver of funds. Jedusor, Tom Elvis originally envisioned the following two-step process
to build a transaction:~\cite{jedusor2016mimblewimble}\\
Assume Alice wants to transfer coins of value $\varFundValue$ to Bob.
\begin{enumerate}
    \item Alice first selects input coins $\varCoinInp$ of total value $\varValue \geq \varFundValue$ that she controls. She than creates change coin outputs $\varCoinOut^{A}$ (could be multiple) of total value $\varValue \opSub \varFundValue$ and then
    sends $\varCoinInp \opSeperate \varCoinOut^{A}$, a valid range proofs for $\varCoinOut^{A}$, plus the opening $(-\varFundValue \opSeperate \varKey)$ of $\sum{\varCoinOut^{A}} \opSub \sum{\varCoinInp}$ to Bob.
    \item Bob creates himself additional output coins $\varCoinOut^B$ plus range proofs of total value $\varFundValue$ with keys $(\varKeySt_i)$ and computes a signature $\varSignature$ with the combined secret key $\varKey \opAdd \sum{\varKeySt_i}$ and
    and finalizes the transaction as
    \[ \varTx \opAssign (0 \opSeperate \varCoinInp \opSeperate \varCoinOut^A \opConc \varCoinOut^B \opSeperate (\varProof \opSeperate \varExcess \opAssign \sum{\varCoinOut^A} \opAdd \sum{\varCoinOut^B} \opSub \sum{\varCoinInp} \opSeperate \varSignature)) \]
    and publishes it to the network.
\end{enumerate}
Figure~\ref{fig:txOriginal} depicts the original transaction flow.\\
\begin{figure}
    \label{fig:txOriginal}
    \centering
    \pseudocode{
        \textbf{Alice} \< \< \< \< \textbf{Bob} \\ [][\hline]
        \< \< \< \< \\
        \text{ Select $\varCoinInp$ of value $\varValue \geq \varFundValue$ } \< \< \< \< \\
        \text{ Create $\varCoinOut^{A}$ of value $\varValue \opSub \varFundValue$} \< \< \< \< \\
        \text{ $\varExcess_{A} \opAssign \sum{\varCoinOut^{A}} \opSub \sum{\varCoinInp}$ } \\
        \text{ $(-\varFundValue \opSeperate \varKey)$ opening to $\varExcess_{A}$ } \< \< \< \< \\
        \text{ Create range-proof $\varProof$ for $\varCoinOut^{A}$ } \< \< \< \< \\
        \< \sendmessageright{ top=$(-\varFundValue \opSeperate \varKey) \opSeperate \varProof$ } \< \< \< \\
        \< \< \< \< \text{Create $\varCoinOut^B$ with value $\varFundValue$ and keys $(\varKeySt_i)$ } \\
        \< \< \< \< \text{$\varKey_{shared} \opAssign \varKey \opAdd \sum{\varKeySt_i}$ } \\
        \< \< \< \< \text{Create $\varSignature$ with $\varKey_{shared}$} \\
        \< \< \< \< \text{ Create range-proof $\varProof$ for $\varCoinOut^{B}$ } \\
        \< \< \< \< \text{Finalize transaction $\varTx$} \\
    }
    \caption{Original transaction building process}
\end{figure}
This protocol however turned out to be vulnerable. The receiver can spend the change coins $\varCoinOut^A$ by reverting the transaction. Doing this would give the sender his coins back, however as the sender
might not have the keys for his spent outputs anymore, the coins could then be lost.\\
In detail this reverting transaction would look like:
\[ \varTx_{rv} \opAssign (0 \opSeperate \varCoinOut^A \opConc \varCoinOut^B \opSeperate \varCoinInp \opSeperate (\varProof_{rv} \opSeperate \varExcess_{rv} \opSeperate \varSignature_{rv}) ) \]
Again remembering the construction of the Excess value of this construction would look like this:
\[ \varExcess_{rv} \opAssign \sum{\varCoinOut^A \opConc \varCoinOut^B \opSub \varCoinInp} \]
The key $\varKey$ originally sent by Alice to Bob is a valid opening to $\sum{\varCoinInp} \opSub \sum{\varCoinOut^A}$. With the inverse of this key $\varKey_{inv}$ we get the opening to $\sum{\varCoinOut^A \opSub \varCoinInp}$.
Now all Bob has to do is add his keys $\sum{\varKeySt_i}$ to get:
\[ \varKey_{rv} \opAssign -\varKey \opAdd \sum{\varKeySt_i} \]
which is the opening to $\varExcess_{rv}$. Furthermore obtaining a valid range proofs is trivial, as it once was a valid output the ledger will cointain a valid proof for this coin already. \\
This means Bob spends the newly created outputs and sends them back to the original input coins, chosen by Alice. It might at first seem unclear why Bob would do that. An example situation could be if Alice
pays Bob for some good which Bob is selling. Alice decides to pay in advance, but then Bob discovers that he is already out of stock of the good that Alice ordered. To return the funds to Alice, he reverses
the transaction instead of participating in another interactive process to build a new transaction with new outputs. If Alice already deleted the keys to her initial coins, the funds are now lost.
The problem was solved in the Grin Cryptocurrency by making the signing process itself a two-party process which will be explained in more detail in chapter~\ref{chp:fixedWitnessSignatures}. \\

Fuchsbauer et al.~\cite{fuchsbauer2019aggregate} proposed the following alternative way to build transactions which would not be vulnerable to this problem.
\begin{enumerate}
    \item Alice constructs a full-fledged transaction $\varTx_A$ spending her input coins $\varCoinInp$ and creates her change coins $\varCoinOut^A$, plus a special output coin $\varCoinOut^{sp} \opAssign \funGenH{\varFundValue} \opAdd \funGen{\varKey_{sp}}$,
    where $\varFundValue$ is the desired value which should be transferred to Bob and $\varKey_{sp}$ is a randomly choosen key. She proceeds by sending $\varTx_A$ as well as $(\varFundValue \opSeperate \varKey_{sp})$ and the necessary range
    proofs to Bob.
    \item Bob now creates a second transaction $\varTx_B$ spending the special coin $\varCoinOut^{sp}$ to create an output only he controls $\varCoinOut^{B}$ and merges $\varTx_A$ with $\varTx_B$
    into $\varTx_m$. He then broadcasts $\varTx_m$ to the network. Note that when the two transactions are merged the intermediate special coin $\varCoinOut^{sp}$ will be both in the coin output and input list
    of the transaction and therfore will be discarded.
\end{enumerate}
The only drawback of this approach is that we have two transaction kernels instead of just one because of the merging step, making the transaction slightly bigger.

\section{Scriptless Scripts}\label{sec:scriptlessScripts}

\section{Adaptor Signatures}\label{sec:aptSignatures}

\subsection{Schnorr Signature Construction}\label{sec:schnorrAptSignatures}

\subsection{ECDSA Signature Construction}\label{sec:ecdsaAptSignatures}
