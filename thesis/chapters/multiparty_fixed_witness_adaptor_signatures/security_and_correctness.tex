We now prove that the outlined Schnorr-based instantiation is correct, i.e., Adaptor Signature Correctness holds and is secure with regards to~\cref{subsec:pre:security}.

\subsection{Adaptor Signature Correctness}\label{subsec:sig:aptsig-correctness}

To prove that Adaptor Signature Correctness holds, we have three statements to prove as given by \cref{def:sig:apt-sig-correctness}.
First we demonstrate that $\procVerf{\varMsg}{\varSigFin}{\varSigContext.\varPubKey} \opEqNoQ 1$ holds in our Schnorr-based instantiation of the Signature Scheme, where $\varSigContext$ is set up such that $\varPubKey \opEqNoQ \varPubKeyAlice \opAddPoint \varPubKeyBob$.

\begin{proof}
    \label{prf:apt-schnorr-pre-sig-corr}
    For this proof, we assume the setup already specified in~\cref{def:sig:apt-sig-correctness}.
    The proof is by showing the equality of the equation checked by the verifier of the final signature by continuous substitutions on the left side of the equation:
    \begin{align}
        \funGen{\varS} &\opEqNoQ \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge} \\
        \funGen{\varSAlice} \opAddPoint \funGen{\varSBob} & \\
        \funGen{\varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob} & \\
        \funGen{\varNonceAlice} \opAddPoint \opPointScalar{\varPubKeyAlice}{\varSchnorrChallenge} \opAddPoint \funGen{\varNonceBob} \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} & \\
        \varRandAlice \opAddPoint \opPointScalar{\varPubKeyAlice}{\varSchnorrChallenge} \opAddPoint \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} & \\
        \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge} & \opEqNoQ \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge} \\
        1 & \opEqNoQ 1
    \end{align}

    It remains to prove that with the same setup $\procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEqNoQ 1$ and
    $(\varStatement \opSeperate \varWit) \opIn \cnstRelation$ for $\varWit \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}$:

    \[
        \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEqNoQ 1
    \]
    The proof is by continuous substitutions in the equation checked by the verifier:
    \begin{align}
        \funGen{\varSigAptBob} &\opEqNoQ \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement \\
        \funGen{\varSigBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opAddScalar \varSecKeyBob \opTimesScalar \varSchnorrChallenge \opAddScalar \varWit} & \\
        \funGen{\varNonceBob} \opAddPoint \funGen{\varSecKeyBob \opTimesScalar \varSchnorrChallenge} \opAddScalar \funGen{\varWit} & \\
        \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement &\opEqNoQ \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement \\
        1 &\opEqNoQ 1
    \end{align}
    We now continue to prove the last equation required:
    \[
        (\varStatement \opSeperate \varWit) \opIn \cnstRelation
    \]
    We do this by showing that $\varWit$ is calculated correctly in $\procExtWitId$:
    $\varSAptBob$ is the $\varS$ value in Bob's masked partial signature
    \begin{align}
        \varWit \opEqNoQ & \varSAptBob \opSub (\varS \opSub \varSAlice) \\
        & \varSAptBob \opSub ((\varSAlice \opAddScalar \varSBob ) \opSub \varSAlice ) \\
        & \varSBob \opAddScalar \varWit \opSub (\varSBob) \\
        \varWit \opEqNoQ & \varWit \\
        1 \opEqNoQ & 1
    \end{align}
\end{proof}

\subsection{Security}\label{subsec:sig:secureaptscheme}

We have shown that the outlined Signature Scheme is correct.
Next, we have to prove its security.
Our goal is to prove security in the malicious setting (as shown in~\cref{subsec:pre:security}) that means the adversary might or might not behave as specified by the protocol.
For achieving this, we will prove security for both the $\procDSignId$ and $\procDAptSignId$ protocols in the hybrid model, which Yehuda Lindell laid out in~\cite{lindell2017simulate}.
In particular, we will use the $\procZKfId{\cnstRelation}$-model in which we assume that we have access to a constant-round protocol $\procZKfId{\cnstRelation}$ that computes the zero-knowledge proof of knowledge functionality for any $\cnstNP$ relation $\cnstRelation$.
The function is parameterized with a relation $\cnstRelation$ between a witness value $\varWit$ (or potentially multiple)  and a statement $\varStatement$.
One party provides the witness statement pair $(\varWit, \varStatement)$, the second the statement $\funStar{\varStatement}$.
If $\varStatement \opEqNoQ \funStar{\varStatement}$ and $(\varWit, \varStatement) \opIn \cnstRelation$ the functionality returns 1, otherwise 0.
More formally:
\[
    \procZkf{\cnstRelation}{((\varWit, \varStatement), \funStar{\varStatement})} \opEqNoQ
    \begin{cases}
        (\lambda, \cnstRelation(\varStatement, \varWit)) & \text{if } \varStatement \opEqNoQ \funStar{\varStatement} \\
        (\lambda, 0) &\text{otherwise}
    \end{cases}
\]
That a constant-round zero-knowledge proof of knowledge exists was proven in~\cite{lindell2013note}.
A secure zero-knowledge proof must fulfill Completeness, Soundness and Zero-Knowledge properties, which are defined, for instance, in~\cite{groth2010short}.

\paragraph{Hybrid functionalities:} The parties have access to a trusted third party that computes the zero-knowledge proof of knowledge functionality $\procZKfId{\cnstRelation}$.
$\cnstRelation$ is the relation between a secret key $\varSecKey$ and its public key $\varPubKey \opEqNoQ \funGen{\varSecKey}$, for the elliptic curve generator point $\varG$.
The participants have to call the functionality in the same order.
That means if the prover first sends the pair $(\varWit_1, \varStatement_1)$ and then $(\varWit_2, \varStatement_2)$ the verifier needs first to send $\varStatement_1$ and then $\varStatement_2$.

\paragraph{Proof idea:} To construct our simulation proof in the hybrid model, we make some adjustments to the $\procDSignId$ protocol utilizing the capabilities of the $\procZKfId{\cnstRelation}$ functionality.
The adjusted protocol can be seen in figure \cref{fig:sig:dsign-adj} with the newly added lines marked in blue.
We note here that by making those adjustments to the original protocol, we now no longer prove security of the original protocol but rather the adjusted one.
This circumstance does not mean that the original protocol is insecure.
Still, if one wants to implement a version of the protocol proven to be secure, it should include the calls added in the adjusted protocol.
The same argument holds for all of the modified protocols from this section.
\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering,skipfirstln]{$\procDSign{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSecKeyBob}{\varNonceBob}$} {
            Alice \< \< Bob \\
            \varSigContext \opAssign \{ \varPubKey \opAssign \cnstIdentityElement, \varRand \opAssign \cnstIdentityElement \} \< \< \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyAlice}}{\funGen{\varNonceAlice}} \< \< \\
            \color{blue} \procZkf{\cnstRelation}{(\varSecKeyAlice, \varPubKeyAlice)} \\
            \color{blue} \procZkf{\cnstRelation}{(\varNonceAlice, \varRandAlice)} \\
            \< \sendmessageright*{\varSigContext, \varPubKeyAlice, \varRandAlice} \< \\
            \< \< \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyBob}}{\funGen{\varNonceBob}} \< \< \\
            \< \< \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varSigContext} \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation}{\varPubKeyAlice} \opEqNoQ 0 \opOr \pcskipln \\
            \< \< \color{blue} \t \procZkf{\cnstRelation}{\varSigContext.\varRand} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \color{blue} \procZkf{\cnstRelation}{(\varSecKeyBob, \varPubKeyBob)} \\
            \< \< \color{blue} \procZkf{\cnstRelation}{(\varNonceBob, \varRandBob)} \\
            \< \sendmessageleft*{\varSigBob, \varSigContext, \varPubKeyBob} \< \\
            \color{blue} \pcif \procZkf{\cnstRelation}{\varPubKeyBob} \opEqNoQ 0 \opOr \pcskipln \\
            \t \color{blue} \procZkf{\cnstRelation}{\varSigContext.\varRand \opAddPoint \varRandAlice^{-1}} \opEqNoQ 0 \\
            \t \color{blue} \pcreturn \cnstFalsum \\
            \pcif \procVerfPtSig{\varSigBob}{\varMsg}{\varPubKeyBob} \opEqNoQ 0 \< \< \\
            \t \pcreturn \cnstFalsum \< \< \\
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext} \< \< \\
            \< \sendmessageright*{\varSigAlice} \< \\
            \< \< \pcif \procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice} \opEqNoQ 0 \\
            \< \< \t \pcreturn \cnstFalsum \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
            \varPubKey \opFunResult \varSigContext.\varPubKey \< \< \varPubKey \opFunResult \varSigContext.\varPubKey \\
            \pcreturn (\varSigFin, \varPubKey) \< \< \pcreturn (\varSigFin, \varPubKey)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Adjustment to the $\procDSignId$ protocol seen in \cref{fig:sig:dsign}} \label{fig:sig:dsign-adj}
\end{figure}


In the adjusted protocol, both Alice and Bob will verify the validity of the other party's public key and nonce Commitments.
They will stop protocol execution in case the peer sent an invalid value.
We assume parties have access to a trusted third party computing $\procZKfId{\cnstRelation}$ which will return 1 if $\varPubKeyAlice \opEqNoQ \funStar{\varPubKeyAlice}$ (where $\funStar{\varPubKeyAlice}$ is the public key that Bob received from Alice) and $\varPubKeyAlice \opEqNoQ \funGen{\varSecKeyAlice}$. (The same holds for the reversed case)

\begin{theorem}\label{lem:sig:dsign}
Assume we have two key pairs $\varKeyPairAlice$ and $\varKeyPairBob$, which were set up securely, for instance, with the distributed keygen protocol $\procKeyGenPtId$ and a hash function $\funHash{\cdot}$ modeled in the random oracle model.
    Then $\procDSignId$ securely computes a signature $\varSigFin$ under the composite public key $\varPubKey \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ in the $\procZKfId{\cnstRelation}$-model.
\end{theorem}

\begin{proof}
    \label{prf:sig:two-party-security}
    We proof the protocol's security by constructing a simulator $\cnstSimulator$ who is given output $(\varSigFin, \varPubKey)$ from a TTP (trusted third party) that securely computes the protocol in the ideal world upon receiving Alice and Bob's inputs.
    The simulator's task will be to extract the inputs used by $\cnstAdversary$ such that he can call the TTP and receive the outputs.
    From this output, the simulator $\cnstSimulator$ has to construct a transcript that is indistinguishable from a protocol transcript in the real world in which a deterministic polynomial adversary $\cnstAdversary$ controls the corrupted party.
    The simulator uses the calls to $\procZKfId{\cnstRelation}$ to do this.
    Furthermore, we assume that the message $\varMsg$ is known to both Alice and Bob.
    All other inputs (including public keys) are only known to the respective party at the start of the protocol.
    We have to prove two cases: Alice is the corrupted party and one in which Bob is the corrupted party.
    
    \textbf{Alice is corrupted: } Simulator $\cnstSimulator$ works as follows:
    \begin{asparaenum}
        \item $\cnstSimulator$ invokes $\cnstAdversary$, receives and saves $(\varSecKeyAlice, \varPubKeyAlice)$, as well as $(\varNonceAlice, \varRandAlice)$ that $\cnstAdversary$ sends to $\procZKfId{\cnstRelation}$.
        \item Next $\cnstSimulator$ receives the message $(\varSigContext, \funStar{\varPubKeyAlice}, \funStar{\varRandAlice})$ as sent to Bob by $\cnstAdversary$.
        If $\funStar{\varPubKeyAlice} \opNotEq \varPubKeyAlice$ or $\funStar{\varRandAlice} \opNotEq \varRandAlice$, $\cnstSimulator$ externally sends $\cnstAbort$ to the TTP computing $\procDSignId$ and outputs whatever $\cnstAdversary$ outputs, otherwise he will send the inputs $(\varMsg, \varSecKeyAlice, \varNonceAlice)$ and receive back $(\varSigFin, \varPubKey)$.
        \item $\cnstSimulator$ now calculates $\varPubKeyBob, \varRandBob$ and $\varSigBob$ as follows:
        \begin{gather*}
            (\varS, \varRand) \opFunResult \varSigFin \\
            \varPubKeyBob \opAssign \varPubKey \opAddPoint \varPubKeyAlice^{-1} \\
            \varRandBob \opAssign \varRand \opAddPoint \varRandAlice^{-1} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyBob}{\varRandBob} \\
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext} \\
            (\varSAlice, \varRandAlice, \varSigContext) \opFunResult \varSigAlice \\
            \varSBob \opAssign \varS \opSub \varSAlice \\
            \varSigBob \opAssign (\varSBob, \varRandBob, \varSigContext)
        \end{gather*}
        \item After having done the calculations $\cnstSimulator$ is able to send $\varSigContext, \varSigBob, \varPubKeyBob$ to $\cnstAdversary$ as if coming from Bob.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation}$ and $\procZKfId{\cnstRelation}$ (as the verifier) $\cnstSimulator$ checks equality with $\varPubKeyBob$ (respective $\varRandBob$) and thereafter sends back either 0 or 1.
        \item Eventually $\cnstSimulator$ will receive $\funStar{\varSigAlice}$ from $\cnstAdversary$ and finally output whatever $\cnstAdversary$ outputs.
    \end{asparaenum}

    We now show that the joint output distribution in the ideal model with $\cnstSimulator$ is identically distributed to the joint distribution in a real execution in the $\procZKfId{\cnstRelation}$-hybrid model with $\cnstAdversary$.
    We consider three phases :
    \textbf{(1)} Alice sends $(\varSecKeyAlice, \varPubKeyAlice)$ as well as $(\varNonceAlice, \varRandAlice)$ to $\procZKfId{\cnstRelation}$ and $(\varSigContext, \varPubKeyAlice, \varRandAlice)$ to Bob.
    \textbf{(2)} Bob sends $\varPubKeyAlice$ and $\varSigContext.\varRand$ to $\procZKfId{\cnstRelation}$ as the verifier, and  $(\varSecKeyBob, \varPubKeyBob)$, $(\varNonceBob, \varRandBob)$ to $\procZKfId{\cnstRelation}$ as the prover.
    Afterward, he sends $(\varSigBob, \varSigContext, \varPubKeyBob)$ to Alice.
    \textbf{(3)} Alice sends $\varPubKeyBob$ and $\varRandBob$ to $\procZKfId{\cnstRelation}$ as the verifier and $\varSigAlice$ to Bob.
    Finally, we will have to show that the simulators output is indistinguishable from that of $\cnstAdversary$.

    \begin{asparaitem}
        \item \textit{Phase 1} Since $\cnstAdversary$ is required to be deterministic, the distribution is identical to what one would expect in an actual execution.
        \item \textit{Phase 2} As $\cnstSimulator$ managed to calculate Bobs $\varSigBob, \varPubKeyBob, \varRandBob$, as if they would be expected in a real execution from the final $(\varSigFin, \varPubKey)$, we can conclude that the transcript of this phase must be computationally indistinguishable from a real transcript.
        \item \textit{Phase 3} The messages sent by the deterministic $\cnstAdversary$  have to be identically distributed to a real execution.
        Therefore the transcript produced by this phase again has to be indistinguishable.
        \item Regarding the protocol output, we note that if the adversary deviates from the protocol specification, the simulator will notice it, halt, and output whatever $\cnstAdversary$ outputs.
        If $\cnstAdversary$ behaves correctly, $\cnstSimulator$ will play the protocol until the end and finally output whatever $\cnstAdversary$ outputs.
        So both in the case that $\cnstAdversary$ acts honestly and if he does not, $\cnstAdversary$'s and $\cnstSimulator$'s outputs will be indistinguishable.
    \end{asparaitem}

    We have shown that the distributions of transcript messages are indistinguishable in every phase of the protocol if Alice is corrupted.

    \textbf{Bob is corrupted: } Simulator $\cnstSimulator$ works as follows:
    \begin{asparaenum}
        \item $\cnstSimulator$ starts by sampling $\varSecKeyAlice, \varNonceAlice \sample \cnstIntegersPrimeWithoutZero{*}$ and proceeds by setting up the initial signature context as defined by the protocol:
        \begin{gather*}
            \varSigContext \opAssign \{ \varPubKey \opAssign 1, \varRand \opAssign 1 \} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyAlice}}{\funGen{\varNonceAlice}} \\
        \end{gather*}
        \item $\cnstSimulator$ now invokes $\cnstAdversary$ and sends $(\varSigContext, \varPubKeyAlice, \varRandAlice)$ as if coming from Alice.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation}$ (as verifier), $\cnstSimulator$ checks equality to the parameters he sent in step 1 and returns either 1 or 0.
        When $\cnstAdversary$ calls $\procZkf{\cnstRelation}{(\varSecKeyBob, \varPubKeyBob)}$ and $\procZkf{\cnstRelation}{(\varNonceBob, \varRandBob)}$ the simulator saves those values to its memory.
        \item Now $\cnstSimulator$ externally sends the inputs $(\varMsg, \varSecKeyBob, \varNonceBob)$ to the TTP and receives back $(\varSigFin, \varPubKey)$
        \item When $\cnstAdversary$ queries $\funHash{\varMsg \opConc \varRandAlice \opAddPoint \varRandBob \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob}$ during the $\procSignPtId$ call, $\cnstSimulator$ sends back $\funStar{\varSchnorrChallenge}$ such that:
        \begin{gather*}
            \varSigFin \opEqNoQ \varNonceAlice \opAddScalar \varSecKeyAlice \opTimesScalar \funStar{\varSchnorrChallenge} \opAddScalar \varNonceBob \opAddScalar \varSecKeyBob \opTimesScalar \funStar{\varSchnorrChallenge} \\
            \funStar{\varSchnorrChallenge} \opEqNoQ \frac{\varSigFin \opSub \varNonceAlice \opSub \varNonceBob}{\varSecKeyAlice \opAddScalar \varSecKeyBob}
        \end{gather*}
        \item $\cnstSimulator$ receives $(\varSigBob, \varSigContext, \varPubKeyBob)$ from $\cnstAdversary$.
        He verifies the values sent to him by comparing them with $\varPubKeyBob$ and $\varRandBob$ from its memory.
        If the simulator finds the values invalid, or if he doesn't receive any values at all, he will send $\cnstAbort$ to the TTP and output whatever $\cnstAdversary$ outputs.
        \item $\cnstSimulator$ calculates $\varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}$ as defined in the protocol and then sends it to $\cnstAdversary$ as if coming from Alice and finally outputs whatever $\cnstAdversary$ outputs.
    \end{asparaenum}
    Again we argue why the transcript is indistinguishable from the real one for each of the three phases laid out before:
    \begin{asparaitem}
        \item \textit{Phase 1: } The values $(\varPubKeyAlice, \varRandAlice)$ sent by $\cnstSimulator$ to $\cnstAdversary$ only depend on Alice's input parameters (and to some extent on the public elliptic curve parameters).
        As $\cnstAdversary$ does not know $\varPubKeyAlice$ or $\varRandAlice$ yet, he has no way of determining for two public keys, $\varPubKeyAlice, \funStar{\varPubKeyAlice}$, which is the correct one (other than guessing).
        \item \textit{Phase 2: } When $\cnstAdversary$ calls $\procZKfId{\cnstRelation}$ with the proper parameters sent to him, he will still receive 1 back, or 0 otherwise, which is the same as would be expected in an actual execution.
        The hash function $\funHash{\cdot}$ is expected to output a random value for the Schnorr challenge as it is defined in the random oracle model.
        In the simulated case, $\cnstSimulator$ calculates the output value from the final signature that depends on Alice's and Bob's input values of which at least Alice input is chosen randomly by $\cnstSimulator$.
        As dependent on random tape, the calculation output will be distributed uniformly across the possible values and is therefore indistinguishable from a real hash function output.
        Furthermore, $\cnstAdversary$ can not recover the original input from the hash output.
        Imagine that he would be able to do so. He would then be able to guess the correct input from any hash output and thereby break the hash function's Pre-image Resistance property.
        The remaining messages are identical to what would be expected in a real execution due to the deterministic nature of $\cnstAdversary$.
        \item \textit{Phase 3: } The simulator will verify the values sent to him by $\cnstAdversary$ and will halt and output $\cnstFalsum$ if he sends something invalid, which is again identical to what is expected in a real execution.
        In this case, $\cnstAdversary$ must not receive ($\varSigFin, \varPubKey$) in the ideal setting, which is modeled by $\cnstSimulator$ sending $\cnstAbort$ to the TTP.
        Otherwise, $\cnstSimulator$ will calculate his part of the partial signature as defined by the protocol.
        Therefore, it will be found to be valid by $\cnstAdversary$ and will complete to $\varSigFin$ with $\procFinSigId$, because of the fixed, calculated Schnorr challenge $\cnstSimulator$ computed in Phase 2.
        \item If $\cnstAdversary$ behaves dishonestly at any point of the protocol, then the simulator will notice, sent $\cnstAbort$ to the TTP, and output whatever $\cnstAdversary$ outputs.
        If the adversary behaves as defined in the protocol specification, the protocol will be played until the end, after which $\cnstSimulator$ again outputs whatever $\cnstAdversary$ outputs.
        Therefore, in any case, the outputs must be indistinguishable from the adversary's output in a real execution.
    \end{asparaitem}

    We have managed to show that in the case that Bob is corrupted, the transcript is indistinguishable from a real transcript.
    Therefore, we can conclude that the transcript output will be indistinguishable from a real one in all cases and have thereby proven that the protocol $\procDSignId$ is secure in the $\procZKfId{\cnstRelation}$-model and theorem \cref{lem:sig:dsign} must hold.
\end{proof}

We now do the same for $\procDAptSignId$:
Again, we adjust the protocol with calls to $\procZKfId{\cnstRelation}$, note that we now have one additional call $\procZKfId{\cnstRelation}$, for the pair $(\varWit, \varStatement)$.
The relation $\cnstRelation$ is equally defined as in the previous proof.
The adjusted protocol can be seen in \cref{fig:sig:daptsign-adj}.
\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering,skipfirstln]{$\procDAptSign{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSecKeyBob}{\varNonceBob}{\varWit}$} {
            Alice \< \< Bob \\
            \color{blue} \procZkf{\cnstRelation}{(\varSecKeyAlice, \varPubKeyAlice)} \\
            \color{blue} \procZkf{\cnstRelation}{(\varNonceAlice, \varRandAlice)} \\
            \varSigContext \opAssign \{ \varPubKey \opAssign \cnstIdentityElement, \varRand \opAssign \cnstIdentityElement \} \< \< \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyAlice}}{\funGen{\varNonceAlice}} \< \< \\
            \< \sendmessageright*{\varSigContext, \varPubKeyAlice, \varRandAlice} \< \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation}{\varPubKeyAlice} \opEqNoQ 0 \opOr \pcskipln \\
            \< \< \color{blue} \procZkf{\cnstRelation}{\varSigContext.\varRand} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \color{blue} \procZkf{\cnstRelation}{(\varSecKeyBob, \varPubKeyBob)} \\
            \< \< \color{blue} \procZkf{\cnstRelation}{(\varNonceBob, \varRandBob)} \\
            \< \< \color{blue} \procZkf{\cnstRelation}{(\varWit, \varStatement)} \\
            \< \< \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyBob}}{\funGen{\varNonceBob}} \< \< \\
            \< \< \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varSigContext} \\
            \< \< \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
            \< \< \varPubKeyBob \opAssign \funGen{\varSecKeyBob} \\
            \< \< \varStatement \opAssign \funGen{\varWit} \\
            \< \sendmessageleft*{\varSigBob, \varSigContext, \varPubKeyBob, \varStatement} \< \\
            \pcif \procVerifyAptSig{\varSigBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEqNoQ 0 \< \< \\
            \t \pcreturn \cnstFalsum \< \< \\
            \pcif \color{blue} \procZkf{\cnstRelation}{\varPubKeyBob} \opEqNoQ 0 \opOr \pcskipln \\
            \t \color{blue} \procZkf{\cnstRelation}{\varSigContext.\varRand \opAddPoint \varRandAlice^{-1}} \opEqNoQ 0 \opOr \pcskipln \\
            \t \color{blue} \procZkf{\cnstRelation}{\varStatement} \opEqNoQ 0 \opOr \\
            \t \color{blue} \t \pcreturn \cnstFalsum \\
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext} \< \< \\
            \< \sendmessageright*{\varSigAlice} \< \\
            \< \< \pcif \procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice} \opEqNoQ 0 \\
            \< \< \t \pcreturn \cnstFalsum \\
            \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
            \< \sendmessageleft*{\varSigFin} \< \\
            \varPubKey \opFunResult \varSigContext.\varPubKey \< \< \varPubKey \opFunResult \varSigContext.\varPubKey \\
            \pcif \procVerf{\varMsg}{\varSigFin}{\varPubKey} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \\
            \varWit \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob} \\
            \pcreturn (\varWit, (\varSigFin, \varPubKey)) \< \< \pcreturn (\varSigFin, \varPubKey)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Adjustments to the $\procDAptSignId$ protocol seen in \cref{fig:sig:daptsign}} \label{fig:sig:daptsign-adj}
\end{figure}

\begin{theorem} \label{lem:sig:daptsign}
    Assume we have two key pairs $\varKeyPairAlice$ and $\varKeyPairBob$ which were set up securely as, for instance, with the distributed keygen protocol $\procKeyGenPtId$ and a hash function $\funHash{\cdot}$ modeled in the random oracle model.
    Additionally, we have a pair $(\varWit, \varStatement)$ in the relation $\varStatement \opEqNoQ \funGen{\varWit}$ for which $\varWit$ was chosen randomly.
    Then $\procDAptSignId$ securely computes a signature $\varSigFin$ under the composite public key $\varPubKey \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ after which $\varWit$ is revealed to Alice, in the $\procZKfId{\cnstRelation}$-model.
\end{theorem}

\begin{proof}
    We proof the security of $\procDAptSignId$ by constructing a simulator $\cnstSimulator$ which is given the output $(\varSigFin, \varPubKey)$ (resp. ($\varWit, (\varSigFin, \varPubKey)$)) from a TTP that securely computes the protocol in the ideal world after receiving the inputs from Alice and Bob.
    The simulator's task again is to extract the adversary's inputs and send them to the trusted third party to receive the protocol outputs and construct a transcript that is indistinguishable from the protocol transcript in the real world from this output.
    The simulator uses the calls to $\procZKfId{\cnstRelation}$ to do this.
    As in the proof before, we assume the message $\varMsg$ is known to both participants.
    All other inputs (including public keys) are only known to the respective party at the start of the protocol.
    We prove that the transcript is indistinguishable in case Alice is corrupted as well as in the case that Bob is corrupted.

    \textbf{Alice is corrupted: } Simulator $\cnstSimulator$ works as follows:
    \begin{asparaenum}
        \item $\cnstSimulator$ invokes $\cnstAdversary$.
        When $\cnstAdversary$ internally calls $\procZKfId{\cnstRelation}$ and $\procZKfId{\cnstRelation}$ $\cnstSimulator$ saves $(\varSecKeyAlice, \varPubKeyAlice)$ and $(\varNonceAlice, \varRandBob)$ to its memory.
        \item $\cnstSimulator$ receives $(\varSigContext, \funStar{\varPubKeyAlice}, \funStar{\varPubKeyBob})$ from $\cnstAdversary$.
        $\cnstSimulator$ checks the equalities $\funStar{\varPubKeyAlice} \opEqNoQ \varPubKeyAlice$ and $\funStar{\varRandAlice} \opEqNoQ \varRandAlice$ as well as checking $\varPubKeyAlice \opEqNoQ \funGen{\varSecKeyAlice}$ and $\varRandAlice \opEqNoQ \funGen{\varNonceAlice}$.
        If any of those checks fail, or he doesn't receive some of the values at all, $\cnstSimulator$ sends $\cnstAbort$ to the TTP and outputs whatever $\cnstAdversary$ outputs.
        Otherwise, he sends $(\varMsg, \varSecKeyAlice, \varNonceAlice)$ to the TTP and receives $(\varWit, (\varSigFin, \varPubKey))$.
        \item Again $\cnstSimulator$ calculates $\varSigBob, \varPubKeyBob, \varRandBob$ and finalizes the context $\varSigContext$ as follows:
        \begin{gather*}
            (\varS, \varRand) \opFunResult \varSigFin \\
            \varPubKeyBob \opAssign \varPubKey \opAddPoint \varPubKeyAlice^{-1} \\
            \varRandBob \opAssign \varRand \opAddPoint \varRandAlice^{-1} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyBob}{\varRandBob} \\
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext} \\
            (\varSAlice, \varRandAlice, \varSigContext) \opFunResult \varSigAlice \\
            \varSBob \opAssign \varS \opSub \varSAlice \\
            \varSigBob \opAssign (\varSBob, \varRandBob, \varSigContext)
        \end{gather*}
        \item $\cnstSimulator$ calculates $\funStar{\varSBob} \opAssign \varSBob \opAddScalar \varWit$ (extracted from the TTP output) from which he sets $\varSigAptBob \opAssign (\funStar{\varSBob}, \varRandBob, \varSigContext)$.
        \item $\cnstSimulator$ sends $(\varSigAptBob, \varSigContext, \varPubKeyBob, \varStatement \opAssign \funGen{\varWit})$ as if coming from Bob.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation}$ the simulator compares the parameters send by $\cnstAdversary$ to the real one, in case he sent a invalid value $\cnstSimulator$ returns 0, otherwise 1.
        \item $\cnstSimulator$ receives $\funStar{\varSigAlice}$ from $\cnstAdversary$ and in any case outputs whatever $\cnstAdversary$ outputs.
    \end{asparaenum}

    The phases are similar to the ones defined in \cref{prf:sig:two-party-security}, with the only two adjustments being that a) in Phase 2 Bob additionally sends $\varStatement$ to Alice and b) we introduce a new Phase 4 in which Bob sends $\varSigFin$ to Alice.
    Yet for the sake of completeness, we write the full proof in the following:
    \textbf{(1)} Alice sends $(\varSecKeyAlice, \varPubKeyAlice)$ as well as $(\varNonceAlice, \varRandAlice)$ to $\procZKfId{\cnstRelation}$ and $(\varSigContext, \varPubKeyAlice, \varRandAlice)$ to Bob.
    \textbf{(2)} Bob sends $\varPubKeyAlice$ and $\varSigContext.\varRand$ to $\procZKfId{\cnstRelation}$ as the verifier, and  $(\varSecKeyBob, \varPubKeyBob)$, $(\varNonceBob, \varRandBob)$ to $\procZKfId{\cnstRelation}$ as the prover.
    Afterward, he sends $(\varSigBob, \varSigContext, \varPubKeyBob, \varStatement)$ to Alice.
    \textbf{(3)} Alice sends $\varPubKeyBob$ and $\varRandBob$ to $\procZKfId{\cnstRelation}$ as the verifier and $\varSigAlice$ to Bob.
    \textbf{(4)} Bob sends the final signature $\varSigFin$ to Alice.
    They both output $(\varSigFin, \varPubKey)$ and Alice additionally outputs $\varWit$.
    Finally, again we have to show that the simulator's protocol output is equivalent to $\cnstAdversary$'s expected execution.

    We now again argue why the transcript of each phase has to be indistinguishable from a real transcript:
    \begin{asparaitem}
        \item \textit{Phase 1:} As $\cnstAdversary$ is required to be deterministic, we can conclude that this phase's transcript must be indistinguishable from a real transcript.
        \item \textit{Phase 2:} In this phase, $\cnstSimulator$ sends $\varStatement \opAssign \funGen{\varWit}$ to $\cnstAdversary$ for which the simulator received $\varWit$ from the TTP, therefore it will resamble the value that would have been expected in a real execution.
        \item \textit{Phase 3:} The transcript in this phase must be indistinguishable for the same reasons already laid out in Phase 1.
        \item \textit{Phase 4:} Now, $\cnstAdversary$ expects to receive $\varSigFin$, from which he can extract the witness $\varWit$.
        Indeed he will receive $\varSigFin$ as $\cnstSimulator$ has received from the TTP, which would have been expected in an actual execution.
        Furthermore, it must hold that $\cnstAdversary$ will be able to extract the correct $\varWit$ using the $\procExtWitId$ procedure, as the simulator calculated $\varStatement \opEqNoQ \funGen{\varWit}$ in step 5.
        \item In that case that $\cnstAdversary$ behaves dishonestly and at any time of the protocol by sending invalid (or no) values to the simulator, he will detect this, abort the further protocol execution, and output whatever $\cnstAdversary$ outputs.
        Similarly, in the case that $\cnstAdversary$ behaves honestly, the protocol is played until the end, after which $\cnstSimulator$ outputs whatever $\cnstAdversary$ outputs.
        So in both cases, the outputs will be equivalent to what is expected in a real execution.
    \end{asparaitem}

    We have shown that in the case that Alice is corrupt, $\cnstSimulator$'s simulated transcript is indeed distributed equally to a real execution and is thereby computationally indistinguishable.

    \textbf{Bob is corrupted: } Simulator $\cnstSimulator$ works as follows:
    \begin{asparaenum}
        \item $\cnstSimulator$ starts by sampling $\varSecKeyAlice, \varNonceAlice \sample \cnstIntegersPrimeWithoutZero{*}$ and proceeds by setting up the initial signature context as described in the protocol:
        \begin{gather*}
            \varSigContext \opAssign \{ \varPubKey \opAssign 1, \varRand \opAssign 1 \} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyAlice}}{\funGen{\varNonceAlice}} \\
        \end{gather*}
        \item $\cnstSimulator$ now invokes $\cnstAdversary$ and sends $(\varSigContext, \varPubKeyAlice, \varRandAlice)$ as if coming from Alice.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation}$ (as the verifier) $\cnstSimulator$ checks for equality with the values sent by him and returns either 0 or 1.
        Once $\cnstAdversary$ sends $(\varSecKeyBob, \varPubKeyBob)$, $(\varNonceBob, \varRandBob)$, $(\varWit, \varStatement)$ internally to $\procZKfId{\cnstRelation}$ as the prover, $\cnstSimulator$ saves them to his memory.
        \item $\cnstSimulator$ sends $(\varMsg, \varSecKeyAlice, \varNonceAlice, \varWit)$ to the TTP and receives $(\varSigFin, \varPubKey)$.
        \item When $\cnstAdversary$ queries $\funHash{\cdot}$ the simulator again sets the output to $\funStar{\varSchnorrChallenge}$ calculated with the following steps already seen in the previous proof:
        \begin{gather*}
            \varSigFin \opEqNoQ \varNonceAlice \opAddScalar \varSecKeyAlice \opTimesScalar \funStar{\varSchnorrChallenge} \opAddScalar \varNonceBob \opAddScalar \varSecKeyBob \opTimesScalar \funStar{\varSchnorrChallenge} \\
            \funStar{\varSchnorrChallenge} \opEqNoQ \frac{\varSigFin \opSub \varNonceAlice \opSub \varNonceBob}{\varSecKeyAlice \opAddScalar \varSecKeyBob}
        \end{gather*}
        \item $\cnstSimulator$ receives $(\funStar{\varSigAptBob}, \funStar{\varPubKeyBob}, \varSigContext, \funStar{\varStatement})$ from $\cnstAdversary$ and verifies those values checking equality with the ones stored in its memory.
        If the equality checks succeed, $\cnstSimulator$ sends $\cnstContinue$ to the TTP, otherwise he sends $\cnstAbort$ and outputs whatever $\cnstAdversary$ outputs.
        \item The simulator now calculates $\varSigAlice$ as defined by the protocol using the $\procSignPrtId$ procedure and sends the result to $\cnstAdversary$ as if coming from Alice.
        \item Finally $\cnstSimulator$ will receive $\funStar{\varSigFin}$ from $\cnstAdversary$ and in any case output whatever $\cnstAdversary$ outputs.
    \end{asparaenum}
    
    Again we argue why the transcript is indistinguishable in phases 1--4:
    \begin{asparaitem}
        \item \textit{Phase 1:} As argued in \cref{prf:sig:two-party-security}, in this phase, the adversary will receive some public, nonce Commitment, and signature context.
        As he does not know Alice's actual inputs, he has no way of knowing if the values received are the correct ones fitting with Alice's inputs, other than by guessing.
        \item \textit{Phase 2:} As argued before, with the hash function modeled in the random oracle, its output is expected to be randomly distributed.
        As $\cnstSimulator$'s computation to create the hash output relies on randomly chosen values ($\varSecKeyAlice, \varNonceAlice$), we can conclude that the output is distributed indistinguishably from a real hash output.
        Further, $\cnstAdversary$ must not know the original input value by seeing the hash output he receives as he then would also be able to break the Pre-image Resistance property of the hash function.
        \item \textit{Phase 3:} $\cnstSimulator$ will verify the equality of $\cnstAdversary$'s values with the variables saved to its memory before.
        In case he sent invalid values $\cnstAdversary$ should not receive the final outputs $(\varSigFin, \varPubKey)$, which is modeled by sending $\cnstAbort$ to the TTP.
        The same behavior is expected in a real execution when Alice calls $\procZKfId{\cnstRelation}$ and receives a 0 bit.
        $\varSigAlice$ must be indistinguishable from a real execution because it was calculated by $\cnstSimulator$ exactly as of protocol definition.
        \item \textit{Phase 4:} In this phase, $\cnstSimulator$ is expected to receive $\funStar{\varSigFin}$ from $\cnstAdversary$ after which $\cnstSimulator$ will output whatever $\cnstAdversary$ outputs, which must be indistinguishable from a real execution because of the deterministic adversary.
        \item Again, in both the case that $\cnstAdversary$ deviates from protocol specification and follows it, $\cnstSimulator$ will output whatever $\cnstAdversary$ outputs, therefore being equal to the expected output from $\cnstAdversary$ in an actual execution.
    \end{asparaitem}

    We have shown that the transcript produced by $\cnstSimulator$ in an ideal world with access to a TTP computing $\procDAptSignId$ is indistinguishable from a transcript produced during a real execution both in the case that Alice and that Bob is corrupted.
    By managing to show this, we have proven that the protocol is secure in $\procZKfId{\cnstRelation}$-model and~\cref{lem:sig:daptsign} therefore holds.
\end{proof}