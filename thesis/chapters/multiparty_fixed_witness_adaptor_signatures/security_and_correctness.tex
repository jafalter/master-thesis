We now prove that the outlined schnorr-based instantiation is correct, i.e. Adaptor Signature Correctness holds, as well as secure with regards to the definition~\ref{subsec:pre:security}.

\subsection{Adaptor Signature Correctness}\label{subsec:sig:aptsig-correctness}

To prove that Adaptor Signature Correctness holds we have 3 statements to prove, first we prove that $\procVerf{\varMsg}{\varSigFin}{\varSigContext.\varPubKey} \opEq 1$ holds in our
schnorr-based instantiation of the signature scheme, whereas $\varSigContext$ is setup such that $\varPubKey \opEqNoQ \varPubKeyAlice \opAddPoint \varPubKeyBob$.

\begin{proof}
    \label{prf:apt-schnorr-pre-sig-corr}
    For this prove we assume the setup already specified in definition~\ref{def:sig:apt-sig-correctness}.
    The proof is by showing equality of the equation checked by the verifier of the final signature by continuous substitutions in the left side of equation:
    \begin{align}
        \funGen{\varS} &\opEqNoQ \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge} \\
        \funGen{\varSAlice} \opAddPoint \funGen{\varSBob} & \\
        \funGen{\varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob} & \\
        \funGen{\varNonceAlice} \opAddPoint \opPointScalar{\varPubKeyAlice}{\varSchnorrChallenge} \opAddPoint \funGen{\varNonceBob} \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} & \\
        \varRandAlice \opAddPoint \opPointScalar{\varPubKeyAlice}{\varSchnorrChallenge} \opAddPoint \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} & \\
        \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge} & \opEqNoQ \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge} \\
        1 & \opEqNoQ 1
    \end{align}

    It remains to prove that with the same setup $\procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEq 1$ and
    $(\varStatement \opSeperate \funStar{\varWit}) \opIn \cnstRelation$ hold.

    \[
        \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEq 1
    \]
    The proof is by continuous substitutions in the equation checked by the verifier:
    \begin{align}
        \funGen{\varSigAptBob} &\opEqNoQ \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement \\
        \funGen{\varSigBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opAddScalar \varSecKeyBob \opTimesScalar \varSchnorrChallenge \opAddScalar \varWit} & \\
        \funGen{\varNonceBob} \opAddPoint \funGen{\varSecKeyBob \opTimesScalar \varSchnorrChallenge} \opAddScalar \funGen{\varWit} & \\
        \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement &\opEqNoQ \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement \\
        1 &\opEqNoQ 1
    \end{align}
    We now continue to prove the last equation required:
    \[
        ((\varStatement \opSeperate \funStar{\varWit}) \opIn \cnstRelation)
    \]
    We do this by showing that $\varWit$ is calculated correctly in $\procExtWitId$:
    \begin{align}
        \varWit \opAssign & \varSApt \opSub (\varS \opSub \varSAlice) \\
        & \varSApt \opSub ((\varSAlice \opAddScalar \varSBob ) \opSub \varSAlice ) \\
        & \varSBob \opAddScalar \varWit \opSub (\varSBob) \\
        \varWit \opAssign & \varWit \\
    \end{align}
\end{proof}

\subsection{Security}\label{subsec:sig:secureaptscheme}

We have shown that the outlined signature scheme is correct, next we have to prove its security.
Our goal is to proof security in the malicious setting (as defined in~\ref{subsec:pre:security}) that means the adversary might or might not behave as specified by the protocol.
For achieving this we will prove security for both the $\procDSignId$ and $\procDAptSignId$ protocols in the hybrid model which was layed out by Yehuda Lindell in~\cite{lindell2017simulate}.
In particular, we will use the $\procZKfId{\cnstRelation}$-model in which we assume that we have access to a constant-round protocol $\procZKfId{\cnstRelation}$ that computes the zero-knowledge proof of knowledge functionality for any $\cnstNP$ relation $\cnstRelation$.
The function is parameterized with a relation $\cnstRelation$ between a witness value $\varWit$ and a statement $\varStatement$.
One party provides the witness statment pair $(\varWit, \varStatement)$, the second the statement $\funStar{\varStatement}$.
If $\varStatement \opEqNoQ \funStar{\varStatement}$ the functionality returns 1, otherwise 0.
More formally:
\[
    \procZkf{\cnstRelation}{((\varWit, \varStatement), \funStar{\varStatement})} \opEqNoQ
    \begin{cases}
        (\lambda, \cnstRelation(\varStatement, \varWit)) & \text{if } \varStatement \opEqNoQ \funStar{\varStatement} \\
        (\lambda, 0) &\text{otherwise}
    \end{cases}
\]
That a constant-round zero-knowledge proof of knowledge exists was proven in~\cite{lindell2013note}.
We recall from~\ref{sec:pre:privacy:zeroknowlegde} that a secure zero-knowledge proof must fulfill Completeness, Soundness and Zero-Knowledge.

\paragraph{Proof idea} In order to construct our simulation proof in the hybrid-model we make some adjustments to the $\procDSignId$ protocol utilizing the capabilities of the $\procZKfId{\cnstRelation}$ functionality:
\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procDSign{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSecKeyBob}{\varNonceBob}$} {
        Alice \< \< Bob \\
        \cdots \< \< \\
        \procZkf{\cnstRelation_1}{(\varSecKeyAlice, \funGen{\varSecKeyAlice})} \\
        \procZkf{\cnstRelation_2}{(\varNonceAlice, \funGen{\varRandAlice})} \\
        \< \sendmessageright*{\varSigContext, \varPubKeyAlice} \< \\
        \< \< \cdots \\
        \< \< \pcif \procZkf{\cnstRelation_1}{\varPubKeyAlice} \opEqNoQ 0 \opOr \procZkf{\cnstRelation_2}{\varSigContext.\varRand} \opEqNoQ 0 \\
        \< \< \t \pcreturn \cnstFalsum \\
        \< \< \procZkf{\cnstRelation_3}{(\varSecKeyBob, \varPubKeyBob)} \\
        \< \< \procZkf{\cnstRelation_4}{(\varNonceBob, \varRandBob)} \\
        \< \sendmessageleft*{\varSigBob, \varSigContext, \varPubKeyBob} \< \\
        \cdots \< \< \\
        \pcif \procZkf{\cnstRelation_3}{\varPubKeyBob} \opEqNoQ 0 \opOr \\
        \t \procZkf{\cnstRelation_4}{\varSigContext.\varRand \opAddPoint \varRandAlice^{-1}} \opEqNoQ 0 \\
        \t \pcreturn \cnstFalsum \\
        \< \cdots \< \\
        \pcreturn (\varSigFin, \varPubKey) \< \< \pcreturn (\varSigFin, \varPubKey)
        }
    \end{varwidth}
    }
\end{center}

That means both Alice and Bob will verify the validity of the public key and nonce commitments of the other party and will stop protocol execution in case an invalid value has been sent.
We assume parties have access to a trusted third party computing $\procZKfId{\cnstRelation}$ which will return 1 iff $\varPubKeyAlice \opEqNoQ \funStar{\varPubKeyAlice}$ (where $\funStar{\varPubKeyAlice}$ is the public key that Bob received from Alice) and $\varPubKeyAlice \opEqNoQ \funGen{\varSecKeyAlice}$. (The same holds for the reversed case)

\begin{theorem}\label{lem:sig:security}
Assume we have two key pairs $\varKeyPairAlice$ and $\varKeyPairBob$ which were setup securly as for instance with the distributed keygen protocol $\procKeyGenPtId$.
    Then $\procDSignId$ securely computes a signature $\varSigFin$ under the composite public key $\varPubKey \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ in the $(\procZKfId{\cnstRelation_1}, \procZKfId{\cnstRelation_2}, \procZKfId{\cnstRelation_3}, \procZKfId{\cnstRelation_4})$-model.
\end{theorem}

\begin{proof}
    We proof security of the protocol by constructing a simulator $\cnstSimulator$ who is given output $(\varSigFin, \varPubKey)$ from a TTP (trusted third party) that securely computes the protocol in the ideal world, receiving the inputs from Alice and Bob.
    From this output the simulator $\cnstSimulator$ will output a transcript which is indistinguishable from the protocol transcript in the real world.
    The simulator uses the calls to $(\procZKfId{\cnstRelation_1}, \procZKfId{\cnstRelation_2}, \procZKfId{\cnstRelation_3}, \procZKfId{\cnstRelation_4})$ in order to do this.
    Furthermore we assume that the message $\varMsg$ is known to both Alice and Bob.
    We have to proof two cases, one in which Alice is the corrupted party and one in which Bob is corrupted.
    
    \textbf{Alice is corrupted: } Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ receives and saves $(\varSecKeyAlice, \varPubKeyAlice)$, as well as $(\varNonceAlice, \varRandAlice)$ that $\cnstAdversary$ sends to $\procZKfId{\cnstRelation_1}$.
        In case those values and invalid (not in the specified relation) or the adversary does not call them at all $\cnstSimulator$ sends $\cnstAbort$ to the TTP and ouputs $\cnstFalsum$.
        \item Next $\cnstSimulator$ receives the message $(\varSigContext, \funStar{\varPubKeyAlice}, \funStar{\varRandAlice})$ sent to Bob by $\cnstAdversary$.
        If $\funStar{\varPubKeyAlice} \opNotEq \varPubKeyAlice$ or $\funStar{\varRandAlice} \opNotEq \varRandAlice$ $\cnstSimulator$ externally sends $\cnstAbort$ to the TTP computing $\procDSignId$ and outputs $\cnstFalsum$, otherwise he will send the inputs $(\varMsg, \varSecKeyAlice, \varNonceAlice)$ and receive back $(\varSigFin, \varPubKey)$.
        \item $\cnstSimulator$ calculates $\varPubKeyBob, \varRandBob$ and $\varSigBob$ as follows:
        \begin{gather*}
            (\varS, \varRand) \opFunResult \varSigFin \\
            \varPubKeyBob \opAssign \varPubKey \opAddPoint \varPubKeyAlice^{-1} \\
            \varRandBob \opAssign \varRand \opAddPoint \varRandAlice^{-1} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyBob}{\varRandBob} \\
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext} \\
            (\varSAlice, \varRandAlice, \varSigContext) \opFunResult \varSigAlice \\
            \varSBob \opAssign \varS \opSub \varSAlice \\
            \varSigBob \opAssign (\varSBob, \varRandBob, \varSigContext)
        \end{gather*}
        \item After having done the calculations $\cnstSimulator$ is able to send $\varSigContext, \varSigBob, \varPubKeyBob$ to $\cnstAdversary$ as if coming from Bob.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_3}$ and $\procZKfId{_4}$ (as the verifier) we check equality with $\varPubKeyBob$ (respective $\varRandBob$) and thereafter send back either 0 or 1.
        \item Eventually $\cnstSimulator$ will receive $\funStar{\varSigAlice}$ from $\cnstAdversary$ and checks if $\varSigAlice \opEqNoQ \funStar{\varSigAlice}$.
        If they are indeed the same the simulator will send $\cnstContinue$ to the TTP and output $(\varSigFin, \varPubKey)$, otherwise he will send $\cnstAbort$ and output $\cnstFalsum$.
    \end{enumerate}

    We now show that the joint output distribution in the ideal model with $\cnstSimulator$ is identically distributed to the joint distribution in a real execution in the $\procZKfId{\cnstRelation}$-hybrid model with $\cnstAdversary$.
    We consider three phases :
    \textbf{(1)} Alice sends $(\varSecKeyAlice, \varPubKeyAlice)$ to $\procZKfId{\cnstRelation_1}, (\varNonceAlice, \varRandAlice)$ to $\procZKfId{\cnstRelation_2}$ and $(\varSigContext, \varPubKeyAlice, \varRandAlice)$ to Bob
    \textbf{(2)} Bob sends $\varPubKeyAlice$ to $\procZKfId{\cnstRelation_1}$, $\varSigContext.\varRand$ to $\procZKfId{\cnstRelation_2}$, $(\varSecKeyBob, \varPubKeyBob)$ to $\procZKfId{\cnstRelation_3}$, $(\varNonceBob, \varRandBob)$ to $\procZKfId{\cnstRelation_4}$ and $(\varSigBob, \varSigContext, \varPubKeyBob)$ to Alice
    \textbf{(3)} Alice sends $\varPubKeyBob$ to $\procZKfId{\cnstRelation_3}$, $\varRandBob$ to $\procZKfId{\cnstRelation_4}$ and finally $\varSigAlice$ to Bob.

    \begin{itemize}
        \item \textit{Phase 1} Since $\cnstAdversary$ is required to be deterministic, the distribution is identical to a real execution.
        Also in the case the Alice does not send a message, or sends invalid values which will lead Bob to output $\cnstFalsum$ we also output $\cnstFalsum$ in the simulation, which again is indistinguishable.
        \item \textit{Phase 2} As $\cnstSimulator$ managed to calculate Bobs $\varSigBob, \varPubKeyBob, \varRandBob$ from the final $(\varSigFin, \varPubKey)$ and none of the values depend on any random tape we can say that the values sent in the ideal model are identical to those in the real model.
        As Bob in this case is the honest party, we don't have to consider any deviation from the protocol specification.
        \item \textit{Phase 3} The messages sent by the deterministic $\cnstAdversary$ again have to be identical to the real execution and finally the output $\varSigFin, \varPubKey$ or $\cnstFalsum$ if $\cnstAdversary$ made Bob are the identical values to the real protocol.
    \end{itemize}

    We have shown that the distributions in each phase are indeed identical, which proves the indistinguishability of the two transcripts in the case Alice is corrupted.

    \textbf{Bob is corrupted: } Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ starts by sampling $\varSecKeyAlice, \varNonceAlice \sample \cnstIntegersPrimeWithoutZero{*}$, calls $\procZkf{\cnstRelation_1}{(\varSecKeyAlice, \funGen{\varSecKeyAlice})}$ and $\procZkf{\cnstRelation_2}{(\varNonceAlice, \funGen{\varNonceAlice})}$ and proceeds by setting up the initial signature context as defined in the protocol:
        \begin{gather*}
            \varSigContext \opAssign \{ \varPubKey \opAssign 1, \varRand \opAssign 1 \} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyAlice}}{\funGen{\varNonceAlice}} \\
        \end{gather*}
        \item $\cnstSimulator$ now invokes $\cnstAdversary$ and sends $(\varSigContext, \varPubKeyAlice, \varRandAlice)$ as if coming from Alice.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_1}$ and $\procZKfId{\cnstRelation_2}$ (as verifier) $\cnstSimulator$ checks equality to the parameters he sent in step 1 and returns either 1 or 0.
        When $\cnstAdversary$ calls $\procZkf{\cnstRelation_3}{(\varSecKeyBob, \varPubKeyBob)}$ and $\procZkf{\cnstRelation_4}{(\varNonceBob, \varRandBob)}$ the simulator saves those values to its memory.
        If $\cnstAdversary$ does not call $\procZKfId{\cnstRelation_3}$ and $\procZKfId{\cnstRelation_4}$ or sends invalid values which are not in a relation as specified, $\cnstSimulator$ sends $\cnstAbort$ to the TTP and outputs $\cnstFalsum$.
        \item Now $\cnstSimulator$ externally sends the inputs $(\varMsg, \varSecKeyBob, \varNonceBob)$ to the TTP and receives back $(\varSigFin, \varPubKey)$
        \item When $\cnstAdversary$ queries $\funHash{\varMsg \opConc \varRandAlice \opAddPoint \varRandBob \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob}$ $\cnstSimulator$ sends back $\funStar{\varSchnorrChallenge}$ such that:
        \begin{gather*}
            \varSigFin \opEqNoQ \varNonceAlice \opAddScalar \varSecKeyAlice \opTimesScalar \funStar{\varSchnorrChallenge} \opAddScalar \varNonceBob \opAddScalar \varSecKeyBob \opTimesScalar \funStar{\varSchnorrChallenge} \\
            \funStar{\varSchnorrChallenge} \opEqNoQ \frac{\varSigFin \opSub \varNonceAlice \opSub \varNonceBob}{\varSecKeyAlice \opAddScalar \varSecKeyBob}
        \end{gather*}
        \item $\cnstSimulator$ receives $(\varSigBob, \varSigContext, \varPubKeyBob)$ from $\cnstAdversary$.
        (In case he does not $\cnstSimulator$ sends $\cnstAbort$ to the TTP and outputs $\cnstFalsum$).
        He verifies the values sent to him by comparing them with $\varPubKeyBob$ and $\varRandBob$ from it's memory, if they are found to be invalid $\cnstSimulator$ sends $\cnstAbort$ to the TTP, otherwise it sends $\cnstContinue$.
        \item $\cnstSimulator$ calculates as defined in the protocol as $\varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}$ and then sends it to $\cnstAdversary$ as if coming from Alice and finally outputs $(\varSigFin, \varPubKey)$.
    \end{enumerate}
    Again we argue why the transcript is indistinguishable from the real one for each of the three phases layed out before:
    \begin{itemize}
        \item \textbf{Phase 1: } The values $(\varPubKeyAlice, \varRandAlice)$ sent by $\cnstSimulator$ to $\cnstAdversary$ only depend on Alice's input parameters (and to some extend on the public elliptic curve parameters).
        As $\cnstAdversary$ does not know $\varSecKeyAlice$ or $\varNonceAlice$, he has no way of determining for two public keys $\varPubKeyAlice, \funStar{\varPubKeyAlice}$ which of the two is the correct one (other than guessing).
        \item \textbf{Phase 2: } If $\cnstAdversary$ calls $\procZKfId{\cnstRelation_1}$ and $\procZKfId{\cnstRelation_2}$ with the parameters sent to him he will still receive 1 back, and 0 otherwise, which is again exactly the same as in the real execution.
        The hash function $\funHash{\cdot}$ is expected to output a random value for the schnorr challenge as defined by the hiding property of the hash function.
        In the simulated case $\cnstSimulator$ calculates the output value from the final signature and depends on the input values of Alice and Bob of which at least Alice input is chosen randomly by $\cnstSimulator$.
        As dependent on randomly chosen inputs the calculation output will as well be distributed uniformly across the possible values and is therefore indistinguishable from a real hash function output.
        The remaining messages sent by $\cnstAdversary$ are identical to those of the real execution due to the deterministic nature of $\cnstAdversary$.
        \item \textbf{Phase 3: } The simulator will now verify the values sent to him by $\cnstAdversary$ and will halt and output $\cnstFalsum$ in the case that he send something invalid which is identical to the real execution.
        Otherwise $\cnstSimulator$ will calculate his part of the partial signature as defined by the protocol.
        It will therefore found to be valid by $\cnstAdversary$ and it will complete to $\varSigFin$ with $\procFinSigId$ (which $\cnstAdversary$ might call) because of the fixed, calculated schnorr challenger $\cnstSimulator$ has returned $\cnstAdversary$ in Phase 2.
        $\cnstSimulator$ proceeds by outputting $(\varSigFin, \varPubKey)$ as he would in a real execution.
        $\varSigFin$ would match with the $\varSigFin$ output by $\cnstAdversary$ if he or she were to compute it honestly, therefore the output values are again a perfect simulation of the real execution.
    \end{itemize}

    We have managed to show that in the case that Bob is corrupted the transcript is indistinguishable to a real transcript and even identical for the most part.
    We can therefore conclude that the transcript output will be indistinguishable from a real one in all cases and have thereby proven that the protocol $\procDSignId$ is secure.
\end{proof}

We now do the same for $\procDAptSignId$:
Again we adjust the protocol with calls to $\procZKfId{\cnstRelation}$, note that we now have one additional call $\procZKfId{\cnstRelation_5}$, for the pair $(\varWit, \varStatement)$.
\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procDAptSign{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSecKeyBob}{\varNonceBob}{\varWit}$} {
        Alice \< \< Bob \\
        \cdots \< \< \\
        \procZkf{\cnstRelation_1}{(\varSecKeyAlice, \funGen{\varSecKeyAlice})} \\
        \procZkf{\cnstRelation_2}{(\varNonceAlice, \funGen{\varRandAlice})} \\
        \< \sendmessageright*{\varSigContext, \varPubKeyAlice} \< \\
        \< \< \cdots \\
        \< \< \pcif \procZkf{\cnstRelation_1}{\varPubKeyAlice} \opEqNoQ 0 \opOr \procZkf{\cnstRelation_2}{\varSigContext.\varRand} \opEqNoQ 0 \\
        \< \< \t \pcreturn \cnstFalsum \\
        \< \< \procZkf{\cnstRelation_3}{(\varSecKeyBob, \varPubKeyBob)} \\
        \< \< \procZkf{\cnstRelation_4}{(\varNonceBob, \varRandBob)} \\
        \< \< \procZkf{\cnstRelation_5}{(\varWit, \varStatement)} \\
        \< \sendmessageleft*{\varSigBob, \varSigContext, \varPubKeyBob} \< \\
        \cdots \< \< \\
        \pcif \procZkf{\cnstRelation_3}{\varPubKeyBob} \opEqNoQ 0 \opOr \\
        \t \procZkf{\cnstRelation_4}{\varSigContext.\varRand \opAddPoint \varRandAlice^{-1}} \opEqNoQ 0 \opOr \\
        \t \procZkf{\cnstRelation_5}{\varStatement} \opEqNoQ 0 \opOr \\
        \t \pcreturn \cnstFalsum \\
        \< \cdots \< \\
        \pcreturn (\varWit (\varSigFin, \varPubKey)) \< \< \pcreturn (\varSigFin, \varPubKey)
        }
    \end{varwidth}
    }
\end{center}

\begin{theorem}
    Assume we have two key pairs $\varKeyPairAlice$ and $\varKeyPairBob$ which were setup securly as for instance with the distributed keygen protocol $\procKeyGenPtId$.
    Additionally we have a pair $(\varWit, \varStatement)$ in the relation $\varStatement \opEqNoQ \funGen{\varWit}$ for which $\varWit$ was chosen randomly.
    Then $\procDAptSignId$ securely computes a signature $\varSigFin$ under the composite public key $\varPubKey \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ after which $\varWit$ is revealed to Alice, in the $(\procZKfId{\cnstRelation_1}, \procZKfId{\cnstRelation_2}, \procZKfId{\cnstRelation_3}, \procZKfId{\cnstRelation_4}, \procZKfId{\cnstRelation_5})$-model.
\end{theorem}

\begin{proof}
    We proof the security of $\procDAptSignId$ by constructing a simulator $\cnstSimulator$ who is given the output $(\varSigFin, \varPubKey)$ (resp. ($\varWit, (\varSigFin, \varPubKey)$)) from a TTP that securly computes the protocol in the ideal world, receiving the inputs from Alice and Bob.
    From this output the simulator $\cnstSimulator$ will output a transcript that is indistinguishable from the protocol transcript in the real world.
    The simulator uses the calls to $(\procZKfId{\cnstRelation_1},\procZKfId{\cnstRelation_2},\procZKfId{\cnstRelation_3},\procZKfId{\cnstRelation_4},\procZKfId{\cnstRelation_5})$ in order to do this.
    As in the proof before we assume the message $\varMsg$ is known to both participants.
    We proof that the transcript is indistinguishable in case Alice is corrupted as well as in the case Bob is corrupted.

    \textbf{Alice is corrupted: } Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$.
        When $\cnstAdversary$ internally calls $\procZKfId{\cnstRelation_1}$ and $\procZKfId{\cnstRelation_2}$ $\cnstSimulator$ saves $(\varSecKeyAlice, \varPubKeyAlice)$ and $(\varNonceAlice, \varRandBob)$ to its memory.
        \item $\cnstSimulator$ receives $\varSigContext, \funStar{\varPubKeyAlice}, \funStar{\varPubKeyBob}$ from $\cnstAdversary$.
        $\cnstSimulator$ checks the equalities $\funStar{\varPubKeyAlice} \opEqNoQ \varPubKeyAlice$ and $\funStar{\varRandAlice} \opEqNoQ \varRandAlice$ as well as checking $\varPubKeyAlice \opEqNoQ \funGen{\varSecKeyAlice}$ and $\varRandAlice \opEqNoQ \funGen{\varNonceAlice}$.
        If any of those checks fail $\cnstSimulator$ sends $\cnstAbort$ to the TTP and outputs $\cnstFalsum$.
        Otherwise he sends $(\varMsg, \varSecKeyAlice, \varNonceAlice)$ to the TTP and receives $(\varWit, (\varSigFin, \varPubKey))$
        \item Again $\cnstSimulator$ calculates $\varSigBob, \varPubKeyBob, \varRandBob$ and finalizes the context $\varSigContext$ as layed out in the proof beforehand in step 3.
        \item $\cnstSimulator$ calculates $\funStar{\varSBob} \opAssign \varSBob \opAddScalar \varWit$ (received from the TTP) from which he sets $\varSigAptBob \opAssign (\funStar{\varSBob}, \varRandBob, \varSigContext)$.
        \item $\cnstSimulator$ sends $\varSigAptBob, \varSigContext, \varPubKeyBob, \varStatement \opAssign \funGen{\varWit}$ as if coming from Bob.
        \item $\cnstSimulator$ receives $\funStar{\varSigAlice}$ from $\cnstAdversary$ and checks $\varSigAlice \opEqNoQ \funStar{\varSigAlice}$.
        If the equality holds $\cnstAdversary$ sends $\cnstContinue$ to the TTP and finally sends $\varSigFin$ to $\cnstAdversary$ as if coming from Bob and outputs $(\varSigFin, \varPubKey)$.
    \end{enumerate}

    We reuse the phases defined in the previous proof with two adjustments:
    \begin{itemize}
        \item In \textit{Phase 2} Bob additionally sends $\varStatement$ to Alice
        \item We introduce \textit{Phase 4} in which Bob sends $\varSigFin$ to Alice
    \end{itemize}

    We now again argue why each phase in the simulation is indistinguishable from a real execution
    \begin{itemize}
        \item \textit{Phase 1:} This phase is identical to phase 1 the previous proof, thereby the argument is the same
        \item \textit{Phase 2:} In this base $\cnstSimulator$ sends $\varStatement \opAssign \funGen{\varWit}$ to $\cnstAdversary$ for which $\varWit$ was received from the TTP, therefor it will be the same $\varWit$ sent in the real execution which makes the simulation perfect.
        \item \textit{Phase 3:} Again the messages send in this phase are produced by the deterministic $\cnstAdversary$ which will be identical to the real execution.
        In contrast to the $\procDSignId$ protocol now the adversary does not yet finish the protocol
        \item \textit{Phase 4:} Now the $\cnstAdversary$ expects to receive $\varSigFin$, from which he is able to extract the witness $\varWit$.
        Indeed he will receive a $\varSigFin$ which is identical to the one sent in a real execution, furthermore he will be able to extract $\varWit$ such that $\varStatement \opEqNoQ \funGen{\varWit}$, which again makes this phase identical to the real execution.
    \end{itemize}

    We have shown that in the case Alice is corrupt the simulated transcript produced by $\cnstSimulator$ is indeed distributed equally to a real execution and is thereby computationally indistinguishable.

    \textbf{Bob is corrupted: } Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ starts by sampling $\varSecKeyAlice, \varNonceAlice \sample \cnstIntegersPrimeWithoutZero{*}$, calls $\procZkf{\cnstRelation_1}{(\varSecKeyAlice, \funGen{\varSecKeyAlice})}$ and $\procZkf{\cnstRelation_2}{(\varNonceAlice, \funGen{\varNonceAlice})}$ and proceeds by setting up the initial signature context as defined in the protocol:
        \begin{gather*}
            \varSigContext \opAssign \{ \varPubKey \opAssign 1, \varRand \opAssign 1 \} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyAlice}}{\funGen{\varNonceAlice}} \\
        \end{gather*}
        \item $\cnstSimulator$ now invokes $\cnstAdversary$ and sends $(\varSigContext, \varPubKeyAlice, \varRandAlice)$ as if coming from Alice.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_{1,2}}$ (as the verifier) $\cnstSimulator$ checks for equality with the values sent by him and returns either 0 or 1.
        Once he sends $(\varSecKeyBob, \varPubKeyBob)$, $(\varNonceBob, \varRandBob)$, $(\varWit, \varStatement)$ internally to $\procZKfId{\cnstRelation_{1,2,3}}$ $\cnstSimulator$ saves them to his memory.
        \item $\cnstSimulator$ sends $(\varMsg, \varSecKeyAlice, \varNonceAlice, \varWit)$ to the TTP and receives $(\varSigFin, \varPubKey)$.
        \item When $\cnstAdversary$ queries $\funHash{\cdot}$ the simulator again sets the output to $\funStar{\varSchnorrChallenge}$ calculated with the same steps as layed out in the previous proof
        \item $\cnstSimulator$ receives $(\varSigAptBob, \varPubKeyBob, \varSigContext, \varStatement)$ from $\cnstAdversary$ and can verify those values checking equality with the ones stored in its memory.
        If the equality checks succeed $\cnstSimulator$ sends $\cnstContinue$ to the TTP, otherwise sends $\cnstAbort$ and outputs $\cnstFalsum$.
        \item The simulator now calculates $\varSigAlice$ as defined by the protocol using the $\procSignPrtId$ procedure and sents the result to $\cnstAdversary$ as if coming from Alice.
        \item Finally $\cnstSimulator$ will receive $\funStar{\varSigFin}$ from $\cnstAdversary$ (if not he outputs $\cnstFalsum$) and will verify that $\funStar{\varSigFin} \opEqNoQ \varSigFin$.
        If the equalty hold he will output $(\varWit, (\varSigFin, \varPubKey))$, if not $\cnstFalsum$.
    \end{enumerate}
\end{proof}