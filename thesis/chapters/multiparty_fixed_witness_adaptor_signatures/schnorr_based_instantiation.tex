\urldef\urlbiptaproot\url{https://en.bitcoin.it/wiki/BIP_0341}

We start by providing a general instantiation of a signature scheme (see~\cref{def:pre:signature-scheme}):
We assume we have a group $\cnstGroup$ with prime $\varPrime$ and generator point $\varG$, $\cnstHash$ is a secure hash function as defined in~\cref{def:pre:hash-function} and $\varMsg \opIn \cnstBinary{*}$ is a message.


A concrete implementation can be seen in~\cref{fig:schnorr} .
The signature scheme is called Schnorr signature scheme, first defined in~\cite{schnorr1989efficient} and valued for its simplicity and extensively analyzed security.
Due to being patented its practical use originally was limited, however since the patent expired in 2008 the signature scheme sees increasing interest.
Cryptocurrencies such as Grin and Beam now use Schnorr as its primary signature scheme, also Bitcoin is planning to add Schnorr signatures as an alternative to the currently used ECDSA signatures. \footnote{\urlbiptaproot}
\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSetup{\varSecParam}$} {
            \varKey \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \pcreturn (\varSecKey \opAssign \varKey \opSeperate \varPubKey \opAssign \funGen{\varKey})
            }
            \procedure[linenumbering]{$\procSign{\varMsg}{\varSecKey}$}{
            \varNonce \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varRand \opAssign \funGen{\varNonce} \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \varS \opAssign \varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey \\
            \pcreturn \varSignature \opAssign (\varS, \varRand)
            }
            \procedure[linenumbering]{$\procVerf{\varMsg}{\varSignature}{\varPubKey}$} {
            (\varS \opSeperate \varRand) \opFunResult \varSignature \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varS} \opEqNoQ \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Schnorr Signature Scheme as first defined in~\cite{schnorr1989efficient}}
    \label{fig:schnorr}
\end{figure}


Correctness of the scheme can be derived as following:
As shown in~\cref{fig:schnorr}, $\procVerfId$, line 3 we need to show that $\funGen{\varS} \opEqNoQ \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}$ returns $1$ for correct signatures.
As $\varS$ is calculated as $\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey$ ($\procSignId$, line 4), when generator $\varG$ is raised to $\varS$, we get $\funGen{\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey}$ which we can transform into $\funGen{\varNonce} \opAddPoint \funGen{\varSecKey \opTimesScalar \varSchnorrChallenge}$, and finally into $\varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}$ which is the same as the right side of the equation.

From the regular Schnorr signature scheme we now provide an instantiation for the two-party case defined in~\cref{def:sig:two-party-sig} .
Note that this two-party variant of the scheme is what is currently implemented in the Mimblewimble-based Cryptocurrencies and will provide a basis from which we can then build an instantiation for the Two Party Fixed Witness Adaptor Signature Scheme.

First we define a auxiliary function $\procSetupCtxId$ to use for the instantion:

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procSetupCtx{\varSigContext}{\varPubKeyAlice}{\varRandAlice}$} {
        \opAccess{\varSigContext}{\varPubKey} \opAssign \opAccess{\varSigContext}{\varPubKey} \opAddPoint \varPubKeyAlice \\
        \opAccess{\varSigContext}{\varRand} \opAssign \opAccess{\varSigContext}{\varRand} \opAddPoint \varRandAlice \\
        \pcreturn \varSigContext
        } \\
    \end{varwidth}
    }
\end{center}

This function helps the participants to setup and update the signature context shared between them.
In~\cref{fig:twoparty-schnorr} we show a concrete instantiation of the protocol and functions.

In $\procKeyGenPtId$ Alice and Bob will each randomly chose their secret key and nonce.
They further require to create a zero-knowledge proof attesting to the fact that they have generated their key before any message was exchanged.
This is essential to avoid the rogue key attacks mentioned earlier.
The idea of achieving this using zero-knowledge proofs of knowledge was introduced by Thomas Ristenpart and Scott Yilek in~\cite{ristenpart2007power}.
Another secure key generation setup for a Schnorr-based multi-signature protocol was found by Micali et al. in~\cite{micali2001accountable}.
However, the protocol requires additional impractical steps such as splitting signers into individual subgroups $\cnstSubGroup_1, \cnstSubGroup_{2}, \cdots$ of a group $\cnstGroup$.
In our instantiation of $\procKeyGenPtId$ Alice will initially setup the signature context and send it to Bob, together with her public key and zk-proof of knowledge.
Bob verifies the proof and will then proceed by adding his parameters to the shared signature context and send it back to Alice, together with his parameters, which then again Alice will verify.

We note here that this is only one possible way of securely computing the parties keypairs and nonce values, as well as setting up the shared context.
Alternative ways of generating these values could be employed, depending on the use case.
For instance one might envision a scenario in which Alice and Bob would like to reuse their keypairs multiple times and only regenerate the random nonces before each signing process, in this case we could split up $\procKeyGenPtId$ into two separate functions.
Another scenario, one which we will encounter throughout this thesis, is that both the keypairs and nonce values have been generated by a protocol similar to $\procKeyGenPtId$ beforehards, but the the shared context $\varSigContext$ is not yet setup.
In this case the $\procSetupCtxId$ can be incorporated into the signing protocol as we shall see in~\cref{sec:sig:protocols}.
Whatever method of key generation is used, it must not be vulnerable to rogue key attacks.

$\procSignPrtId$ and $\procVerfPtSigId$ are generally similar to the instantiation of the normal Schnorr signature scheme.
Note however that for computing the Schnorr challenge $\varSchnorrChallenge$ the input into the hash function will be the combined public key $\varPubKey$ and combined nonce commitment $\varRand$, which the participants can read from the context object $\varSigContext$.
This has the effect that the partial signature itself are not yet a valid signature (neither under $\varPubKey$ nor under $\varPubKeyAlice$ or $\varPubKeyBob$).
This is because to be valid under $\varPubKey$ the partial signatures are missing the $\varS$ values from the other participants.
They are also not valid under the partial public keys $\varPubKeyAlice$ or $\varPubKeyBob$ because the Schnorr challenge is computed already with the combined values.
Therefore we have to introduce the slightly adjusted $\procVerfPtSigId$ to be able to verify specifically the partial signatures.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering,skipfirstln]{$\procKeyGenPt{\varSecParam}{\varSecParam}$} {
            \textbf{Alice} \< \< \textbf{Bob} \\
            \varSecKeyAlice \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \varSecKeyBob \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varNonceAlice \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \varNonceBob \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varPubKeyAlice \opAssign \funGen{\varSecKeyAlice} \< \< \varPubKeyBob \opAssign \funGen{\varSecKeyBob} \\
            \varRandAlice \opAssign \funGen{\varNonceAlice} \< \< \varRandBob \opAssign \funGen{\varNonceBob} \\
            \varZkpStatementAlice \opAssign \exists \varSecKeyAlice \textit{ s.t. } \funGen{\varSecKeyAlice} \opEqNoQ \varPubKeyAlice \< \< \varZkpStatementBob \opAssign \exists \varSecKeyBob \textit{ s.t. } \funGen{\varSecKeyBob} \opEqNoQ \varPubKeyBob \\
            \varProofAlice \opFunResult \procZkpProve{\varSecKeyAlice}{\varZkpStatementAlice} \< \< \varProofBob \opFunResult \procZkpProve{\varSecKeyBob}{\varZkpStatementBob} \\
            \varSigContext \opAssign \langle \varPubKey \opAssign \cnstIdentityElement \opSeperate \varRand \opAssign \cnstIdentityElement \rangle \< \< \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyAlice}{\varRandAlice} \< \< \\
            \< \sendmessageright*{\varSigContext, \varPubKeyAlice, \varProofAlice} \< \\
            \< \< \pcif \procZkpVerify{\varProofAlice} \opEqNoQ 0 \\
            \< \< \t \pcreturn \cnstFalsum \\
            \< \< \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyBob}{\varRandBob} \\
            \< \sendmessageleft*{\varSigContext, \varPubKeyBob, \varProofBob} \< \\
            \pcif \procZkpVerify{\varProofBob} \opEqNoQ 0 \< \< \\
            \t \pcreturn \cnstFalsum \< \< \\
            \pcreturn (\varSecKeyAlice,\varPubKeyAlice,\varNonceAlice,\varSigContext) \< \< \pcreturn (\varSecKeyBob,\varPubKeyBob,\varNonceBob,\varSigContext)
            } \\
            \procedure[linenumbering]{$\procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}$} {
            (\varRand \opSeperate \varPubKey) \opFunResult \varSigContext \\
            \varRandAlice \opAssign \funGen{\varNonceAlice} \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \varSAlice \opAssign \varNonceAlice \opAddScalar \varSecKeyAlice \opTimesScalar \varSchnorrChallenge \\
            \pcreturn \varSigAlice \opAssign (\varSAlice, \varRandAlice, \varSigContext)
            }
            \procedure[linenumbering]{$\procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice}$} {
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAlice \\
            (\varPubKey \opSeperate \varRand) \opFunResult \varSigContext \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varSAlice} \opEq \varRandAlice \opAddPoint \opPointScalar{\varPubKeyAlice}{\varSchnorrChallenge}
            }
            \procedure[linenumbering]{$\procFinSig{\varSigAlice}{\varSigBob}$} {
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAlice \\
            (\varSBob \opSeperate \varRandBob \opSeperate \varSigContext) \opFunResult \varSigBob \\
            (\varPubKey \opSeperate \varRand) \opFunResult \varSigContext \\
            \varS \opAssign \varSAlice \opAddScalar \varSBob \\
            \varSigFin \opAssign (\varS, \varRand) \\
            \pcreturn \varSigFin
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Two Party Schnorr Signature Scheme}
    \label{fig:twoparty-schnorr}
\end{figure}

For a correctness proof and a generally more extensive explanation of this two-party Schnorr signature scheme we refer the reader to a paper by Maxwell et al.~\cite{maxwell2019simple}.

In~\cref{fig:aptSchnorr} we further provide a Schnorr-based instantiation for the fixed witness adapted signature scheme as defined in~\cref{def:sig:two-party-fixed-wit-apt-sig} .

$\procAptSigId$ will add the secret witness $\varWit$ to the $\varS$ value of the signature, changing the partial signature it this way means that it can't be verified using $\procVerfId$ any longer.
Therefore we introduce $\procVerifyAptSigId$ which takes as additional parameter the statement $\varStatement$ which will be included in the verifiers equation.
Now the function verifies not only validity of the partial signature, but also that it indeed has been adapted with the witness value $\varWit$, being the discrete logarithm of $\varStatement$. After obtaining $\varSigFin$, we can then cleverly unpack the secret $\varWit$, which is shown in the $\procExtWitId$ function.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procAptSig{\varSigPt}{\varWit}$}{
            (\varS \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigPt \\
            \varSStar \opAssign \varS \opAddScalar \varWit \\
            \pcreturn \varSigApt \opAssign (\varSStar \opSeperate \varRandAlice \opSeperate \varSigContext)
            } \\
            \procedure[linenumbering]{$\procVerifyAptSig{\varSigAptAlice}{\varMsg}{\varPubKeyAlice}{\varStatement}$} {
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAptAlice \\
            (\varPubKey \opSeperate \varRand) \opFunResult \varSigContext \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varSAlice} \opEq \varRandAlice \opAddPoint \opPointScalar{\varPubKeyAlice}{\varSchnorrChallenge} \opAddPoint \varStatement
            }
            \procedure[linenumbering]{$\procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}$}{
            (\varS \opSeperate \varRand) \opFunResult \varSigFin \\
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAlice \\
            (\varSAptBob \opSeperate \varRandBob \opSeperate \varSigContext) \opFunResult \varSigAptBob \\
            \varSBob \opAssign \varS \opSub \varSAlice \\
            \varWit \opAssign \varSAptBob \opSub \varSBob \\
            \pcreturn (\varWit)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Fixed Witness Adaptor Schnorr Signature Scheme}
    \label{fig:aptSchnorr}
\end{figure}