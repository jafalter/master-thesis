With the outlined Adapted Mimblewimble Transaction Scheme from definition~\ref{def:atom:apt-ext-mw-tx-scheme} and protocols from \ref{sec:atom:protocols} we can now construct an Atomic Swap protocol with another cryptocurrency.
In this thesis we will explain a swap with Bitcoin, as at present Bitcoin and Bitcoin-like cryptocurrencies are the most widely adopted.
We will generally refer to the ``Bitcoin side`` and the ``Mimblewimble side`` of the swap to be most generic.
Upon implementation one has to decide for a specific implementation, for example BTC on the Bitcoin side and Grin on
the Mimblewimble side.
On the Bitcoin side we define three DPT functions $(\procLockAddrId, \procVerifyLockId, \procSpendBtcId)$.
\begin{itemize}
    \item $(\varScriptPubKey) \opFunResult \procLockAddr{\varPubKeyAlice}{\varPubKeyBob}{\varStatement}{\varTime}$:
    The locking script function lets Bob construct a Bitcoin script only spendable by Alice if she receives the discrete logarithm $\varWit$ of $\varStatement$ with $\varStatement \opEqNoQ \funGen{\varWit}$.
    Additionally, the function requires Bobs public key $\varPubKeyBob$ and a timelock $\varTime$ (given as a block number) as input which allows Bob to reclaim his funds after some time if the atomic swap was not completed successfully.
    The function will create and return a Bitcon script $\varScriptPubKey$ to which Bob can send funds using a P2SH transaction.
    To spend this output Alice will have to provide a signature under her public key $\varPubKeyAlice$ and $\varStatement$, which she is able to provide, once acquired $\varWit$.
    This construction is similar although simpler to the locking mechanism described by Malavolta et al.
    For a in-depth security analysis of this concept we refer the interested reader to their paper ~\cite{malavolta2019anonymous}.
    For a concrete Bitcoin Script realizing this functionality see section~\ref{ch:implementation}.
    \item $\{ 1,0 \} \opFunResult \procVerifyLock{\varPubKeyAlice}{\varPubKeyBob}{\varStatement}{\varValue}{\varTime}{\varUTXO_{lock}}$:
    The lock verification algorithm takes as input Alices, Bobs public keys and the statement $\varStatement$ and the UTXO $\varUTXO_{lock}$.
    The function will compute the Bitcoin lock script $\varScriptPubKey$ as created by $\procLockAddrId$ check equality with $\varUTXO_{lock}$ and if the value locked under the UTXO equals $\varValue$.
    Upon successful verification the function returns 1, otherwise 0.
    \item $\varTx \opFunResult \procSpendBtc{\varInputs}{\varOutputs}{\varSecKey}$:
    The spend Bitcoin functionality is a wrapper around the $\procBuildTransactionId, \procSignTransactionId$ defined in~\ref{subsec:pre:bitcointx}.
    It constructs and signs a transaction spending the UTXOs given in $\varInputs$ and creates the fresh UTXOs in $\varOutputs$.
    It returns a signed transaction which then can be broadcast.
\end{itemize}

\subsection{Setup phase}\label{subsec:atom:setup}

We assume Alice owns Mimblewimble coins $\funArray{\varSpendableCoin}$ with the total value $\varValueMw$ and Bob
Bitcoin locked in some UTXO $\varUTXO$ with a value of $\varValueBtc$ and secret spending key $\varSecKey_{btc}$.
Before the protocol can start the two parties must agree on the value they want to swap, the exchange rate of the currencies and a time after which the swap should be canceled.
After coming to an agreement the following variables are defined and known by both Alice and Bob:
\begin{itemize}
    \item $\varSecParam$ A security parameter.
    \item $\varAmountBtc$ The amount of Bitcoin Bob will swap to Alice.
    \item $\varAmountMW$ The amount of the Mimblewimble coin Alice will swap to Bob.
    \item $\varTimeBTC$ The locktime as a blockheight for the Bitcoin side.
    \item $\varTimeMW$ The locktime as a blockheight for the Mimblewimble side.
\end{itemize}
We collect this shared variables in an initial swap state $\varSwpState$:
\[ \varSwpState \opAssign \{ \varSecParam, \varAmountBtc, \varAmountMW, \varTimeBTC, \varTimeMW \} \]

In practice, we need to consider that exchange rates might fluctuate, furthermore timeouts have to be calculated separately for each chain.
The problems with cross chain payments are discussed by Tairi et al. in~\cite{tairi2019a2l}, they propose to use a fixed exchange rate for each day and to use a real world timeout like one day and then calculate the specific block numbers by taking the average block time of the blockchain into account.
In our setup we can also fix the exchange rate at the beginning of the protocol, which stays unchanged during protocol execution.
If the exchange rate fluctuates and one party is negatively impacted he or she could still decide to stop being cooperative which means the coins would be returned to the original owners after the timeout.

There is furthermore the problem of transaction fees, which we do not consider for this formalization.
Depending on the current network load the participants need to agree on a fee that they are willing to pay for each network.
It needs to be considered that if fees are picked to low, it might take time for transactions to be confirmed, and the swap will take longer, if they are picked high the participants will lose funds.

We formalize the protocol $\procSetupSwapId$ in figure~\ref{fig:setup-swap}.
The protocol takes as input the shared swap state $\varSwpState$ from both parties.
From Alice her Mimblewimble input coins $\funArray{\varSpendableCoin}$ with the summed up value $\varValueMw$ is furthermore required as an input.
From Bob we require a list of UTXO's $\funArray{\varUTXO}$ he wants to spend, he also needs to provide their spending keys $\funArray{\varSecKey_{btc}}$ and their summed of total value $\varValueBtc$, although this could also be read from the blockchain.

The protocol starts by both parties creating and exchanging keys.
Bob now creates two new Bitcoin outputs $\varUTXO_{lock}$ and $\varUTXO_{B}$, of which one is the locked Bitcoins which Alice might retrieve later (or Bob after time $\varTimeBTC$ has passed), and the other Bobs change output. (Difference between what is stored in the input UTXO and what should be sent to Alice).
After Bob has published the transaction sending value to the new outputs, he will provide Alice with the statement $\varStatement$ under which the Bitcoins' are locked together with Alice's public key.
Alice can now verify that the funds on Bitcoin side are indeed correctly locked.
After that she will collaborate with Bob to spend her Mimblewimble coins into an output shared by both parties.
Immediately after, both parties collaborate again to spend this shared coin back to Alice with a timelock of $\varTimeMW$.
It is immanent that Alice does not publish the first transaction (A -> AB) before the timelocked refund transaction (AB -> A) was signed, otherwise her funds are locked in the shared output without the possibility of refund if Bob refuses to cooperate.
The setup protocol concludes with the funds locked up in both chains and ready to be swapped and outputs the updated swap state $\varSwpState$ to both parties.
Additionally, it outputs Alice's part $\funStar{\varPtSpendableCoinAlice}$ of the locked mimblewimble coin, her change output on the mimbewimble side $\funStar{\varSpendableCoinAlice}$, her secret key $\varSecKeyAlice$ for the Bitcoin side and $\funStarAlt{\varSpendableCoinAlice}$, which is refund coin, only valid after $\varTimeMW$.
For Bob it furthermore outputs his part $\funStar{\varPtSpendableCoinBob}$ of the locked mimblewimble coin, his change output on the bitcoin side $\varUTXO_{B}$ and the secret witness value $\varWit$, which shall be revealed to Alice in the execution phase.

\newgeometry{margin=2cm}
\begin{landscape}
    \thispagestyle{plain}
    \begin{figure}
        \fbox{
        \procedure[linenumbering,skipfirstln]{$\procSetupSwap{\varSwpState}{\funArray{\varSpendableCoin}}{\varValueMw}{\funArray{\varUTXO}}{\funArray{\varSecKey_{btc}}}{\varValueBtc}$} {
        Alice \< \< \< \< Bob \\
        \varKeyPairAlice \opFunResult \procSetup{\varSecParam} \< \< \< \< \varKeyPairBob \opFunResult \procSetup{\varSecParam} \\
        \< \< \< \< (\varWit, \varStatement) \opFunResult \procSetup{\varSecParam} \\
        \< \sendmessagerightx{4}{\varPubKeyAlice} \< \\
        \< \sendmessageleftx{4}{\varPubKeyBob} \< \\
        \< \< \< \< \varScriptPubKey \opFunResult \procLockAddr{\varPubKeyAlice}{\varStatement}{\varPubKeyBob}{\varTimeBTC} \\
        \< \< \< \< \varUTXO_{lock} \opFunResult \procCreateUTXO{\varAmountBtc}{\varScriptPubKey} \\
        \< \< \< \< \varUTXO_{B} \opFunResult \procCreateUTXO{\varValueBtc - \varAmountBtc}{\varPubKeyBob} \\
        \< \< \< \< \varBtcTx \opFunResult \procSpendBtc{\funArray{\varUTXO}}{\funArray{\varUTXO_{lock}, \varUTXO_{B}}}{\funArray{\varSecKey_{btc}}} \\
        \< \< \< \< \procPublishBtc{\funArray{\varBtcTx}} \\
        \< \< \< \< \varSwpState \opAssign \varSwpState \opUnion (\varStatement, \varUTXO_{lock}) \\
        \< \sendmessageleftx{4}{\varStatement,\varUTXO_{lock}} \< \\
        \pcif \procVerifyLock{\varPubKeyAlice}{\varPubKeyBob}{\varStatement}{\varAmountBtc}{\varTimeBTC}{\varUTXO_{lock}} \opEqNoQ 0 \\
        \t \pcreturn \cnstFalsum \< \< \< \< \\
        \varSwpState \opAssign \varSwpState \opUnion (\varStatement, \varUTXO_{lock}) \\
        (\varMwFundTx, \funStar{\varSpendableCoinAlice},\funStar{\varPtSpendableCoinAlice}) \< \< \< \< (\funStar{\varPtSpendableCoinBob}) \pcskipln \\
        \opFunResult \procDSharedOutputMwTxL{\funArray{\varSpendableCoin}}{\varAmountMW}{\cnstFalsum} \< \< \< \< \opFunResult \procDSharedOutputMwTxR{\varAmountMW} \\
        (\varMwRefundTx, \funStarAlt{\varSpendableCoinAlice}) \< \< \< \< \varMwRefundTx \pcskipln \\
        \opFunResult \procDSharedInpMwTxL{\funStar{\varPtSpendableCoinAlice}}{\varAmountMW}{\varTimeMW} \< \< \< \< \opFunResult \procDSharedInpMwTxR{\funStar{\varPtSpendableCoinBob}}{\varAmountMW} \\
        \procPublishMW{\funArray{\varMwFundTx,\varMwRefundTx}}  \\
        \pcreturn (\varSwpState, \funStar{\varPtSpendableCoinAlice}, \funStar{\varSpendableCoinAlice}, \varSecKeyAlice, \funStarAlt{\varSpendableCoinAlice}) \< \< \< \< \pcreturn (\varSwpState, \funStar{\varPtSpendableCoinBob}, \varUTXO_{B}, \varWit)
        }
        }
        \caption{Atomic Swap - $\procSetupSwapId$.}\label{fig:setup-swap}
    \end{figure}
\end{landscape}
\restoregeometry

\subsection{Execution Phase}\label{subsec:atom:exec}

First we need to define an additional auxiliary function $\procVerifyTimeId$ with the following interface:
\[ \{0,1\} \opFunResult \procVerifyTime{\varChain}{\varTime} \]
This function will verify that there is sufficient time to execute the atomic swap protcol.
As input it takes a chain paramter $\varChain$ (in our case this could be either BTC or MW) and a block height $\varTime$.
The routine will verify that the current height of the blockchain is marginally below $\varTime$.
If this is the case it will return 1, or 0 otherwise.
How much time exactly should be left for the function to return 1 is implementation specific, and could be set to for instance one day.
We now define a protocol $\procExcSwapId$ to execute the Atomic Swap between some amount $\varAmountBtc$ on the Bitcoin side and some amount on the Mimblewimble side $\varAmountMW$.
We assume the participants have successfully run the $\procSetupSwapId$ protocol and both know the updated swap state $\varSwpState$ as returned by the setup protocol.
Both parties need to provide their part of the locked mimblewimble coins as input to the protocol.
Additionally, Alice needs to provide her secret key for the bitcoin side $\varSecKeyAlice$ and Bob the secret witness value $\varWit$.
The protocol starts with both parties checking that there is enough time left to complete the protocol.
After the check they will run the $\procDScriptMwTxId$ protocol in which they spend the locked Mimblewimble output to Bob, while at the same time revealing $\varWit$ to Alice.
Either one of the parties can now publish the transaction to the mimblewimble network, which concludes the swap on the mimbewimble side, as Bob is now in full control of the funds.
Alice, knowing $\varWit$, creates now a new UTXO where she then sends the funds from the Bitcoin lock.
After publishing this transaction to the Bitcoin network, Alice is in full possession of the swapped funds on the Bitcoin side and the Atomic Swap is completed.
The protocol outputs their newly created output/coin to each party.

\newgeometry{margin=2cm}
\begin{landscape}
    \thispagestyle{plain}
    \begin{figure}
        \fbox{
        \procedure[linenumbering,skipfirstln]{$\procExcSwap{\varSwpState}{\funStar{\varPtSpendableCoinAlice}}{\varSecKeyAlice}{\funStar{\varPtSpendableCoinBob}}{\varWit}$} {
        Alice \< \< \< \< Bob \\
        (\varAmountMW, \varAmountBtc, \varTimeMW, \varTimeBTC, \varUTXO_{lock}, \varStatement) \opFunResult \varSwpState \< \< \< \< (\varAmountMW, \varAmountBtc, \varTimeMW, \varTimeBTC) \opFunResult \varSwpState \\
        \pcif \procVerifyTime{BTC}{\varTimeBTC} \opEqNoQ 0 \opOr \procVerifyTime{MW}{\varTimeMW} \opEqNoQ 0 \< \< \< \< \pcif \procVerifyTime{BTC}{\varTimeBTC} \opEqNoQ 0 \opOr \procVerifyTime{MW}{\varTimeMW} \opEqNoQ 0 \\
        \t \pcreturn \cnstFalsum \< \< \< \< \t \pcreturn \cnstFalsum \\
        (\varMwTx, \cnstEmptySet, \varWit) \< \< \< \< (\varMwTx, \funStar{\varSpendableCoinBob}) \pcskipln \\
        \opFunResult \procDScriptMwTxL{\funStar{\varPtSpendableCoinAlice}}{\varAmountMW}{\cnstFalsum}{\varStatement} \< \< \< \< \opFunResult \procDScriptMwTxR{\funStar{\varPtSpendableCoinBob}}{\varAmountMW}{\varWit} \\
        \procPublishMW{\varMwTx} \< \< \< \< \procPublishMW{\varMwTx} \\
        (\funStarAlt{\varSecKeyAlice}, \funStarAlt{\varPubKeyAlice}) \opFunResult \procSetup{\varSecParam} \< \< \< \< \\
        \varUTXO_{A} \opFunResult \procCreateUTXO{\varAmountBtc}{\funStarAlt{\varPubKeyAlice}} \< \< \< \< \\
        \varBtcTx \opFunResult \procSpendBtc{\funArray{\varUTXO_{lock}}}{\funArray{\varUTXO_{A}}}{\funArray{\varSecKeyAlice, \varWit}} \< \< \< \< \\
        \procPublishBtc{\funStar{\varBtcTx}} \< \< \< \< \\
        \pcreturn (\varUTXO_{A}) \< \< \< \< \pcreturn (\funStar{\varSpendableCoinBob})
        }
        }
        \caption{Atomic Swap - $\procSetupSwapId$. \label{fig:exec-swap}}
    \end{figure}
\end{landscape}
\restoregeometry

\subsection{Refunding}\label{subsec:atom:refund}

If one party refused to cooperate or goes offline the coins can be returned to the original owner.
On the Bitcoin side this is the case as Bob can simply spend the locked output with his private key $\varSecKeyBob$ after the timeout $\varTimeBTC$ has passed.
He then can simply construct and sign a transaction spending the output to a new UTXO which is in his full possession.
He even could prepare this transaction upfront and broadcast it, once the the blocknumber hits $\varTimeBTC$ the transaction will become valid and get mined.
Again we stress the importance of using appropriate timeouts, if a timeout is too short the swap might get cancelled if there are some delays, if the timeout is too long the funds might be locked for an unnessary amount of time.

On the Mimblewimble side the second transaction spending the shared output back to Alice guarantees that her funds are returned to her after the timeout $\varTimeMW$ hits.
For this reason it is so important that Alice publishes both the fund and refund transaction at the same time.
If she would publish the funding transaction first, Bob could refuse to cooperate for the refund transaction, in which case the funds would stay in the locking output only retrievable if both parties cooperate.
If the swap executes successful the refund transaction would get discarded by miners, as it then is no longer valid even after the timeout $\varTimeMW$.