In this section, we will prove the orrectness and security of the instantiation described in~\cref{sec:atom:inst}.
We start by proving \emph{Transaction Scheme Correctness}, \emph{Extended Transaction Scheme Correctness}, and \emph{Adapted Transaction Scheme Correctness} for the three outlined transaction schemes $\varMWScheme, \varextMWScheme$, and $\varaptMWScheme$.
We then show that all protocols described in~\cref{sec:atom:protocols} are secure in the malicious models as defined in~\cref{subsec:pre:security}.

\subsection{Correctness} \label{subsec:atom:correctness}

We will argue \emph{Transaction Scheme Correctness} follows from Correctness of the Commitment Scheme $\varCommitScheme$, Two-Party Signature Scheme $\varSigScheme$ as well as the correctness of the Range Proof System $\varRProofSystem$ used in the transaction protocol.
If the transaction was constructed correctly (that is, by calling the procedures $\procSendCoinsId, \procRecvCoinsId, \procFinTxId$, the distributed variants $\procDSendCoinsId, \procDRecvCoinsId, \procDFinTxId$ or the adapted ones $\procAptRecvCoinsId, \procDAptFinTxId$ with valid inputs) it must follow that the final transaction has correct Commitments, range proofs, and a valid signature, and $\procVerfTxId$ will therefore return 1.
We construct the following theorem:

\begin{theorem}
    \label{lem:atom:correctness}
    \emph{Transaction Scheme Correctness}, \emph{Extended Transaction Scheme Correctness} or \emph{Adapted Transaction Scheme Correctness} for a transaction system $\varMWSchemeParams{\varCommitScheme}{\varSigScheme}{\varRProofSystem}$, $\varextMWSchemeParams{\varCommitScheme}{\varSigScheme}{\varRProofSystem}$ or $\varaptMWSchemeParams{\varCommitScheme}{\varSigScheme}{\varRProofSystem}$ holds if the underlying Commitment Scheme $\varCommitScheme,$ Two-Party Signature Scheme $\varSigSchemeMP$ and Range Proof System $\varRProofSystem$ are correct.
\end{theorem}

\begin{proof}
    We assume there are two honest participants Alice and Bob.
    There exists a list of input coins $\funArray{\varCoinInp}$ with blinding factors $\funArray{\varBlindingFactor_i}$ and values $\funArray{\varValue_i}$ wrapped inside a list $\funArray{\varSpendableCoin}$ known to Alice and some amount $\varFundValue$ which Alice wants to transfer to Bob.
    For \emph{Transaction Scheme Correctness} to hold $\procVerfTx{\varTx}$ must return 1 with overwhelming probability for the two parties creating the transaction $\varTx$ in the following three steps:
    \begin{enumerate}
        \item $(\varPreTx, (\varSecKeyAlice, \varNonceAlice)) \opFunResult \procSendCoins{\funArray{\varSpendableCoin}}{\varFundValue}{\cnstFalsum}$
        \item $\funStar{\varPreTx} \opFunResult \procRecvCoins{\varPreTx}{\varFundValue}$
        \item $\varTx \opFunResult \procFinTx{\funStar{\varPreTx}}{\varSecKeyAlice}{\varNonceAlice}$
    \end{enumerate}
    We recall the conditions for $\procVerfTx{\varTx}$ to return 1 found in~\cref{def:atom:mw-tx-scheme} and show that each of them must hold:

    Condition 1 and 2 both must hold if the participants are honest, that is, compute their coins as given by protocol definition and provide valid input parameters.
    If the sending party provides duplicate inputs, the check at the beginning of the $\procSendCoinsId$ procedure will fail and return $\cnstFalsum$ and thereby halting the protocol.
    The blinding factors to the output coins created in $\procSendCoinsId$ and $\procRecvCoinsId$ are generated randomly, which means a duplication can only appear with negligible probability.

    Condition 3 follows from the implementation of the $\procCreateCoinId$ function called in $\procSendCoinsId$ as well as $\procRecvCoinsId$.
    In the procedure, a range proof is computed for the new coin $\varCoin$ with value $\varValue$ and blinding factor $\varBlindingFactor$ as $\varProof \opFunResult \procProof{\varCoin}{\varValue}{\varBlindingFactor}$.
    Given that our Range Proof System $\varRProofSystem$ system has to be correct $\procVerfProof{\varProof}{\varCoin} \opEqNoQ 1$ must hold for all coins created with the $\procCreateCoinId$ routine.
    Therefore Condition 3 must hold if the transaction is computed honestly.

    we must look at how the secret keys $\varSecKeyAlice$, and $\varSecKeyBob$ are constructed, for condition 4.
    From the instantiation of $\procSendCoinsId$, we can see that Alice's share will be $\varSecKeyAlice \opAssign \funStar{\varBlindingFactorAlice} \opSub \cnstSumZeroToN \funArray{\varBlindingFactorAlice}$, where $\funStar{\varBlindingFactorAlice}$ is the blinding factor to her output and $\funArray{\varBlindingFactorAlice}$ are the blinding factors to her input coins.
    Bob's secret key is constructed like $\varSecKeyBob \opAssign \funStar{\varBlindingFactorBob}$, so it corresponds to his output's blinding factor.
    From the construction of the Two-Party Signature Scheme in~\cref{def:sig:two-party-sig}, we know that, therefore, the final signature will be valid under the following public key:
    \[ \funStarAlt{\varExcess} \opAssign \funGen{\varSecKeyAlice} \opAddPoint \funGen{\varSecKeyBob} \]
    Given how the secret keys are constructed, we arrive at:
    \[ \funStarAlt{\varExcess} \opAssign \funGen{\funStar{\varBlindingFactorAlice}} \opAddPoint \cnstSumZeroToN \funArray{\funGen{- \varBlindingFactorAlice}} \opAddPoint \funGen{\varBlindingFactorBob} \]
    If we can show that the excess value $\varExcess$ computed in $\procVerfTxId$ is the same as above, $\procVerf{\varMsg}{\varSignature}{\varPubKey} \opEqNoQ 1$ must hold, and therefore condition 3 would be proven.
    We show this by a stepwise conversion of the initial equation computing $\varExcess$ until we arrive at the equation for $\funStarAlt{\varExcess}$:
    \begin{gather}
        \varExcess \opEqNoQ \funStarAlt{\varExcess} \\
        \cnstSumZeroToN \varOutputs \opSub \cnstSumZeroToN \varInputs \opSub \funGenH{\varFee}  \opEqNoQ \funGen{\funStar{\varBlindingFactorAlice}} \opAddPoint \cnstSumZeroToN \funArray{\funGen{- \varBlindingFactorAlice}} \opAddPoint \funGen{\varBlindingFactorBob} \opSub \funGenH{\varFee} \\
        \varCoinOutAlice \opAddPoint \varCoinOutBob \opAddPoint \cnstSumZeroToN \funArray{(\varCoinInp)^{-1}} \opAddPoint \funGenH{- \varFee}  \opEqNoQ\\
        (\funGen{\funStar{\varBlindingFactorAlice}} \opAddPoint \funGenH{\varValue \opSub \varFundValue}) \opAddPoint
        (\funGen{\funStar{\varBlindingFactorBob}} \opAddPoint \funGenH{\varFundValue}) \opAddPoint
        \cnstSumZeroToN \funArray{(\funGen{- \varBlindingFactorAlice}, \funGenH{- \varValue_i})} \opAddPoint \funGenH{- \varFee} \opEqNoQ \\
        \funGen{\funStar{\varBlindingFactorAlice}} \opAddPoint \funGen{\funStar{\varBlindingFactorBob}} \opAddPoint \cnstSumZeroToN \funGen{- \varBlindingFactorAlice} \opEqNoQ \funGen{\funStar{\varBlindingFactorAlice}} \opAddPoint \funGen{\funStar{\varBlindingFactorBob}} \opAddPoint \cnstSumZeroToN \funGen{- \varBlindingFactorAlice} \\
        1 \opEqNoQ 1
    \end{gather}
    From step 5.3 to 5.4, we replace every coin $\varCoin$ by its instantiation for a Pedersen Commitment $\varCoin \opEqNoQ \funGen{\varBlindingFactor} \opAddPoint \funGenH{\varValue}$.

    From step 5.4 to 5.5, we rely on the fact that if Alice is honest $\varValue \opEqNoQ \sum \varValue_i \opAddScalar \varFee$, therefore also $(\varValue \opSub \varFundValue) \opAddScalar \varFundValue \opEqNoQ \sum \varValue_i$ must hold.
    We can infer that $\funGenH{\varValue \opSub \varFundValue} \opAddPoint \funGenH{\varFundValue} \opAddPoint \sum \funGenH{- \varValue_i} \opAddPoint \funGenH{\varFee}$ must cancel out.
    Otherwise, the transaction would either create or burn value, which is not allowed and in which case $\procVerfTxId$ should again return 0.

    We have shown that conditions 1-4 must hold for a valid transaction and conclude that \emph{Transaction Scheme Correctness} holds for $\varMWSchemeParams{\varCommitScheme}{\varRProofSystem}{\varSigSchemeMP}$.

    We will now argue that the same derivation holds for \emph{Extended Transaction Scheme Correctness} and \emph{Adapted Transaction Scheme Correctness}.

    Condition 1-2 again follow trivially from the construction of $\procDSendCoinsId$ and \\$\procDRecvCoinsId$ for the same reasons we have already laid out in the previous proof.

    $\procDSendCoinsId$, $\procDRecvCoinsId$, $\procAptRecvCoinsId$ all rely on the same $\procCreateCoinId$ routine to create output coins.
    Thereby condition 3 also holds for valid transactions with the same argument as for the previous proof.

    In \emph{Extended Transaction Scheme Correctness}, the blinding factors for the input coins $\funArray{\varCoinInp}$ are shared.
    However, we can quickly reduce this case to the proof for the regular case:
    In $\procDSendCoinsId$, Alice and Carol construct their secret keys as follows:
    \begin{gather}
        \varSecKeyAlice \opAssign \funStar{\varBlindingFactorAlice} \opSub \cnstSumZeroToN \varBlindingFactorAlice \\
        \varSecKeyCarol \opAssign \funStar{\varBlindingFactorCarol} \opSub \cnstSumZeroToN \varBlindingFactorCarol
    \end{gather}
    $\varSecKeyAlice$ and $\varSecKeyCarol$ are then inputs to $\procDFinTxId$ in which a partial signature $\varSigAliceCarol$ is calculated by both Alice and Carol signing with their secret key.
    Recall the case we have proven above, in which we have a single secret key $\varSecKeyAlice$:
    We can split $\varSecKeyAlice$ into arbitrarily chosen shares $(\varSecKeyAlice)_1, (\varSecKeyAlice)_2$ with $\varSecKeyAlice \opEqNoQ (\varSecKeyAlice)_1 + (\varSecKeyAlice)_2$.
    By the definition of Two-Party Signatures~\cref{def:sig:two-party-sig}, the combined signature from $(\varSecKeyAlice)_1, (\varSecKeyAlice)_2$ will be valid under $\funGen{\varSecKeyAlice}$.
    Thereby we can treat $\varSecKeyAlice$ and $\varSecKeyCarol$ from $\procSendCoinsId$ as arbitrary shares of a combined $\varSecKeyAliceCarol$.
    It follows from the additive homomorphic property of the elliptic curve that a signature valid under $\funGen{\varSecKeyAliceCarol}$ must also be valid under $\funGen{\varSecKeyAlice} \opAddPoint \funGen{\varSecKeyCarol}$.
    The case of two receivers calling $\procDRecvCoinsId$ is symmetric.
    From this, we can conclude that condition 4 must also hold for the \emph{Extended Transaction Scheme}. \\
    Now for the \emph{Adapted Extended Transaction Scheme} the same argument holds.
    The only difference in this scheme is that in $\procDAptFinTxId$ Bob (instead of Alice) will call $\procFinSigId$, as only he knows his unmasked partial signature $\varSigBob$.
    However, the signature's construction remains unchanged.
    Therefore the reduction we provided before must hold for the same reasons.
    We have thereby proven that if $\varCommitScheme, \varRProofSystem, \varSigSchemeMP$ are correct and the participants behave honestly (that is, providing valid inputs and calling the respective routines in the given order), $\procVerfTx{\varTx}$ will return 1 for the resulting transaction $\varTx$ and therefore~\cref{lem:atom:correctness} holds.
\end{proof}

\subsection{Security}\label{subsec:atom:security}

We now want to prove security in the malicious setting as described in~\cref{subsec:pre:security} for the protocols defined in~\cref{sec:atom:protocols}.
Again we show that the distributed protocols are secure in the hybrid $\procZKfId{\cnstRelation}$-model as already explained in~\cref{subsec:sig:secureaptscheme}.
We start by proving security of the simple transaction protocol $\procDBuildMwTxId$.

\textbf{Hybrid functionalities}: The parties have access to a trusted third party computing the zero-knowledge proof of knowledge functionalities $\procZKfId{\cnstRelation_1}$, $\procZKfId{\cnstRelation_2}$, and $\procZKfId{\cnstRelation_2*}$.
$\cnstRelation_1$ is the relation between a secret key $\varSecKey$ and its public key $\varPubKey \opEqNoQ \funGen{\varSecKey}$ for the elliptic curve generator point $\varG$.
$\cnstRelation_2$ is the relation between two private inputs $\varBlindingFactor, \varValue$, and its Pedersen Commitment $\varCommitment \opEqNoQ \funGen{\varBlindingFactor} \opAddPoint \funGenH{\varValue}$ for two adjacent generators $\varG, \varH$ as defined in~\cref{def:pre:pedersen}.
We shorten the prover's call to provide $\varSpendableCoin$ because it is a wrapper containing the coin Commitment, and its openings.
$\cnstRelation_2*$ is the same as $\cnstRelation_2$ just for a list of secrets inputs $\funArray{(\varBlindingFactor, \varValue)}$ and its list of Commitments $\funArray{\varCommitment}$.
Again to shorten the prover's calls we simplify the call to $\procZkf{\cnstRelation_2*}{\funArray{\varSpendableCoin}}$.

\textbf{Proof Idea}: We extend the protocol $\procDBuildMwTxId$ instantiated in ~\cref{sec:atom:protocols} with the following calls to the zero-knowledge proof of knowledge functionalities as depicted in~\cref{fig:atom:hybrid-dbuild}.
Again as already pointed out in the previous section, we must make adjustments to the protocol to prove their security.
That, in turn, does not mean that the original protocols are insecure.
We add calls to make a security proof of this sort possible.
When one implements these protocols with security in mind, one should also implement the additional calls added with the adjusted versions.
The same holds for all modified protocols throughout this section.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering,skipfirstln]{$\procDBuildMwTx{\funArray{\varSpendableCoin}}{\varFundValue}{\varTime}$}{
            Alice \< \< Bob \\
            \color{blue} \procZkf{\cnstRelation_2*}{\funArray{\varSpendableCoin}} \\
            (\varPreTx, \funStar{\varSpendableCoinAlice}, (\varSecKeyAlice, \varNonceAlice)) \\ \opFunResult \procSendCoins{\funArray{\varSpendableCoin}}{\varFundValue}{\varTime} \\
            \color{blue} \procZkf{\cnstRelation_1}{(\varSecKeyAlice, \funGen{\varSecKeyAlice})} \\
            \color{blue} \procZkf{\cnstRelation_1}{(\varNonceAlice, \funGen{\varNonceAlice})} \\
            \color{blue} \procZkf{\cnstRelation_2}{\funStar{\varSpendableCoinAlice}} \\
            \< \sendmessageright*{\varPreTx} \< \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation_2*}{\varTx.\varInputs} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation_1}{\varTx.\varSigContext.\varPubKey} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation_1}{\varTx.\varSigContext.\varRand} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation_2}{\varTx.\varOutputs[0]} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< (\funStarAlt{\varPreTx}, \funStar{\varSpendableCoinBob}) \opFunResult \procRecvCoins{\varPreTx}{\varFundValue} \\
            \< \< \color{blue} \procZkf{\cnstRelation_2}{\funStar{\varSpendableCoinBob}} \\
            \< \sendmessageleft*{\funStarAlt{\varPreTx}} \\
            \pcif \color{blue} \procZkf{\cnstRelation_2}{\varTx.\varOutputs[1]} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \\
            \varTx \opFunResult \procFinTx{\funStarAlt{\varPreTx}}{\varSecKeyAlice}{\varNonceAlice} \\
            \< \sendmessageright*{\varTx} \\
            \pcreturn (\varTx, \funStar{\varSpendableCoinAlice}) \< \< \pcreturn (\varTx, \funStar{\varSpendableCoinBob})
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Extension of $\procDBuildMwTxId$ (\cref{fig:d-build-mw-tx}) in the hybrid model} \label{fig:atom:hybrid-dbuild}
\end{figure}

\begin{theorem}
    \label{theo:atom:sec-tx}
    Let $\varCommitScheme$ be a correct and secure Pedersen Commitment Scheme, $\varRProofSystem$ be a correct and secure Range Proof System, and $\varSigSchemeMP$ be a secure and correct Two-Party Signature Scheme.
    $\procDBuildMwTxId$ securely computes a Mimblewimble transaction transferring the value $\varFundValue$ from a sender (denoted as Alice) to a receiver (denoted as Bob) in the hybrid $\procZKfId{\cnstRelation_1}, \procZKfId{\cnstRelation_2}, \procZKfId{\cnstRelation_2*}$-model.
\end{theorem}

\begin{proof}
    \label{prf:atom:sec-dbuildmw}
    We proof the security of $\procDBuildMwTxId$ by constructing a simulator $\cnstSimulator$ with access to a TTP computing the protocol in the ideal setting upon receiving the participants' inputs.
    For this, the simulator has to extract the inputs used by the adversary.
    The TTP returns the outputs $(\varTx, \funStar{\varSpendableCoinAlice})$ (resp. $(\varTx, \funStar{\varSpendableCoinBob})$) from which he has to construct an indistinguishable transcript from a real world's protocol transcript.
    The simulator uses the calls to $\procZKfId{\cnstRelation_1}, \procZKfId{\cnstRelation_2}, \procZKfId{\cnstRelation_2*}$ to achieve this.
    We prove that the transcript is indistinguishable when either Alice or Bob is corrupt and controlled by a deterministic polynomial adversary $\cnstAdversary$.

    \textbf{Alice is corrupt}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$, and once it calls $\procZKfId{\cnstRelation_2*}, \procZKfId{\cnstRelation_1}$ $\procZKfId{\cnstRelation_2}$ saves the values $\funArray{\varSpendableCoin}, \varSecKeyAlice, \varNonceAlice, \funStar{\varSpendableCoinAlice}$ to its memory.
        \item $\cnstSimulator$ calculates the transaction value $\varFundValue$ as follows:
        \begin{gather*}
            \varValue \opEqNoQ \sum_{\varI \opAssign 0}^{\varI \opSm \varN}(\varSpendableCoin_i.\varValue) \\
            \varFundValue \opEqNoQ \varValue \opSub \funStar{\varSpendableCoinAlice}.\varValue
        \end{gather*}
        \item $\cnstSimulator$ receives $\varPreTx$ from $\cnstAdversary$ and checks for every transaction input $\varI$ if $\varPreTx.\varInputs[\varI] \opEqNoQ \varSpendableCoin[\varI].\varCoin$, and that $\varTx.\varOutputs \opEqNoQ \funArray{\funStar{\varSpendableCoinAlice}.\varCoin}$.
        He also compares $\varTx.\varSigContext.\varPubKey \opEqNoQ \funGen{\varSecKeyAlice}$, $\varTx.\varSigContext.\varRand \opEqNoQ \funGen{\varNonceAlice}$, $\varTx.\varProof[0] \opEqNoQ \funStar{\varSpendableCoinAlice}.\varProof$ and $\varTx.\varCommits[0] \opEqNoQ \funGen{\varSecKeyAlice}$.
        If any of the equalities are invalid $\cnstSimulator$ sends $\cnstAbort$ to the TTP computing $\procDBuildMwTxId$ and returns whatever $\cnstAdversary$ returns.
        Otherwise, he extracts $\varTime \opEqNoQ \varTx.\varTime$ and sends the inputs $(\funArray{\varSpendableCoin}, \varFundValue, \varTime)$ to the TTP and receives back the outputs $(\varTx, \funStar{\varSpendableCoinAlice})$.
        \item The simulators task is now to construct $\funStarAlt{\varPreTx}$, which he can achieve in the following steps:
        \begin{enumerate}
            \item He takes the signature context $\varSigContext$ and final signature $\varSigFin$ from the final transaction $\varSigContext \opEqNoQ \varTx.\varSigContext$ and $\varSigFin \opEqNoQ \varTx.\varSignature$.
            \item He computes the adversaries partial signature as $\varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}$
            \item He further computes:
            \begin{gather*}
                \varPubKey \opFunResult \varSigContext.\varPubKey \\
                \varPubKeyAlice \opEqNoQ \funGen{\varSecKeyAlice} \\
                (\varSAlice, \varRandAlice, \varSigContext) \opFunResult \varSigAlice \\
                (\varS, \varRand) \opFunResult \varSigFin \\
                \varSBob \opEqNoQ \varS \opSub \varSAlice \\
                \varRandBob \opEqNoQ \varRand \opAddPoint \varRandAlice^{-1} \\
                \varPubKeyBob \opEqNoQ \varPubKey \opAddPoint \varPubKeyAlice^{-1} \\
                \varSigBob \opEqNoQ (\varSBob, \varRandBob, \varSigContext)
            \end{gather*}
            \item He other takes values from the final transaction:
            \begin{gather*}
                \varCoinOutBob \opEqNoQ \varTx.\varOutputs[1] \\
                \varProofBob \opEqNoQ \varTx.\varProof[1] \\
                \varCommitment_\varBob \opEqNoQ \varTx.\varCommits[1]
            \end{gather*}
            \item Now he can compute $\funStarAlt{\varPreTx} \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs \opConc \varCoinOutBob}{\varProofs \opConc \varProofBob}{\varSigContext}{\varCommits \opConc \varCommitment_\varBob}{\varSigBob}{\varTime}$
        \end{enumerate}
        Finally, $\cnstSimulator$ will send $\funStarAlt{\varPreTx}$ as if coming from Bob and sends $\cnstContinue$ to the TTP.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_2}$ he checks equality to $\varCoinOutBob$ and returns either 0 or 1.
        \item Eventually, $\cnstAdversary$ will send a $\funStarAlt{\varTx}$, after which the simulator will output whatever $\cnstAdversary$ outputs.
    \end{enumerate}
    Next we need to prove that $\cnstSimulator$'s transcript is indistinguishable from a real one in every protocol phase.
    We separate between the following three phases:
    \textbf{Phase 1}: Alice sends her input coins, signing key and nonce, and her change output coin to $\procZKfId{\cnstRelation_1}$ and $\procZKfId{\cnstRelation_2}$ and sends the pre-transaction $\varPreTx$ to Bob.
    \textbf{Phase 2}: Bob calls $\procZKfId{\cnstRelation_1}$ and $\procZKfId{\cnstRelation_2}$ as the verifier, after which he calls $\procZKfId{\cnstRelation_2}$ as the prover and proceeds by sending the updated pre-transaction $\funStarAlt{\varPreTx}$ to Alice.
    \textbf{Phase 3}: Alice calls $\procZKfId{\cnstRelation_2}$ as the verifier and sends back the final transaction $\varTx$ to Bob, which they then output.
    Finally, $\cnstSimulator$'s output needs to be indistinguishable from that of $\cnstAdversary$ in a real execution.
    \begin{itemize}
        \item \textit{Phase 1}: Due to $\cnstAdversary$'s deterministic nature, we can conclude that this phase has to be indistinguishable as there is not yet any simulation required.
        \item \textit{Phase 2}: If any of the values that $\cnstAdversary$ sends to the trusted party computing the zero-knowledge proofs of knowledge are different from the value that $\cnstAdversary$ sends in the pre-transaction $\cnstSimulator$'s equality checks will fail.
        In this case, he will halt the simulated protocol and return whatever $\cnstAdversary$ outputs, which would be expected in a real execution.
        We further argue that the updated pre-transaction $\funStarAlt{\varPreTx}$ is identical to the pre-transaction expected in a real execution by Bob.
        The signatures $\varSigAlice$ and $\varSigBob$ have to add up to $\varSigFin$, which is the final signature.
        $\cnstSimulator$ can read $\varSigFin$ from the transaction in the output he received from the TTP.
        He can further calculate the adversaries' signatures because he knows their signing secrets.
        From those two values, he can then compute the value that $\varSigBob$ must have such that it will complete to $\varSigFin$ when added to Alice's share of the signature.
        All other values $\cnstSimulator$ needs to build $\funStarAlt{\varPreTx}$ he can read from the final transaction $\varTx$.
        Therefore $\funStarAlt{\varPreTx}$ is identical to one that would be expected in a real execution.
        \item \textit{Phase 3}: When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_2}$ as the verifier, $\cnstSimulator$ can check equality with the correct value and return 0 or 1, which is what would be expected in a real execution.
    \end{itemize}


    We have managed to show that in the case that Alice is corrupted, the simulated transcript is indistinguishable from a transcript that the protocol would produce in a real execution.

    \textbf{Bob is corrupt}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ computes one (or multiple) input coins as follows:
        \begin{gather*}
            \varBlindingFactor, \varValue \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varSpendableCoin \opFunResult \procCreateCoin{\varBlindingFactor}{\varValue}
        \end{gather*}
        He chooses $\varFundValue$ randomly and sets $\varTime \opEqNoQ \cnstFalsum$.
        Now he can call $\procSendCoinsId$ and get:
        \[ (\varPreTx, \funStar{\varSpendableCoinAlice}, (\varSecKeyAlice, \varNonceAlice)) \opFunResult \procSendCoins{\funArray{\varSpendableCoin}}{\varFundValue}{\varTime} \]
        \item The simulator invokes $\cnstAdversary$ and sends $\varPreTx$ as if coming from Alice.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_1},\procZKfId{\cnstRelation_2},\procZKfId{\cnstRelation_2*}$ as the verifier, $\cnstSimulator$ checks equality with the values he sent earlier and returns either 0 or 1.
        The adversary proceeds by calling $\procZkf{\cnstRelation_2}{\funStar{\varSpendableCoinBob}}$, $\cnstSimulator$ saves $\funStar{\varSpendableCoinBob}$, and extracts $\varFundValue \opEqNoQ \funStar{\varSpendableCoinBob}.\varValue$
        He then calls the TTP computing $\procDBuildMwTxId$ with the input $\varFundValue$ and receives $(\varTx, \funStar{\varSpendableCoinBob})$.
        \item Next, $\cnstAdversary$ sends an updated pre-transaction $\funStarAlt{\varPreTx}$.
        $\cnstSimulator$ verifies that the output coin added by $\cnstAdversary$ matches with $\funStar{\varSpendableCoinBob}$.
        If it does not, he sends $\cnstAbort$ to the TTP and outputs whatever $\cnstAdversary$ outputs.
        Otherwise, $\cnstSimulator$ computes the following values from the signature context $\varSigContext$ provided in the final transaction and $\funStarAlt{\varSigContext}$ provided by $\cnstAdversary$:
        \begin{gather*}
            \varPubKeyBob \opEqNoQ \funStarAlt{\varSigContext}.\varPubKey \opAddPoint {\funGen{\varSecKeyAlice}}^{-1} \\
            \varRandBob \opEqNoQ \funStarAlt{\varSigContext}.\varRand \opAddPoint {\funGen{\varNonceAlice}}^{-1} \\
            \varPubKeyAlice \opEqNoQ \varSigContext.\varPubKey \opAddPoint \varPubKeyBob^{-1} \\
            \varRandAlice \opEqNoQ \varSigContext.\varRand \opAddPoint \varRandBob^{-1}
        \end{gather*}
        \item The simulator rewinds to the first step of the simulation.
        Instead of choosing the values for the pre-transaction, he now uses $\varTx.\varInputs$ as the pre-transaction input values, $\varTx.\varOutputs[0]$ as the single output value, $\varTx.\varProofs[0]$ as the single range proof value, and $\varTx.\varCommits[0]$ as the single value in the Commitment field.
        Furthermore, he constructs the initial signature context as given by protocol specification:
        \begin{gather*}
            \varSigContext \opAssign \{ \varPubKey \opEqNoQ 1, \varRand \opEqNoQ 1 \} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyAlice}{\varRandAlice}
        \end{gather*}
        And again sends the pre-transaction to $\cnstAdversary$ as if coming from Alice.
        \item The simulator repeats the steps until step 5, where he rewinded earlier.
        Now instead of rewinding $\cnstSimulator$ sends $\cnstContinue$ to the TTP and sends $\varTx$ as if coming from Alice, and finally outputs whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    Again we now claim that the simulation is indistinguishable from a real execution.
    Note that we need to consider the message sent before and after the rewind.

    \begin{itemize}
        \item \textit{Phase 1:} In the first iteration, the simulator constructs the input values $\funArray{\varSpendableCoin}$ from random values and chooses a random transaction value $\varFundValue$.
        $\cnstSimulator$ creates the pre-transaction using those computed values rather than the real ones.
        We claim that the adversary cannot distinguish the chosen from the real coin Commitments (except with negligible probability).
        If we assume that he would be able to do so, that means he could distinguish for two Pedersen Commitments $\varCommitment_1 \opEqNoQ \funGen{\varBlindingFactor_1} \opAddPoint \funGenH{\varValue}, \varCommitment_2 \opEqNoQ \funGen{\varBlindingFactor_2} \opAddPoint \funGenH{\funStarAlt{\varValue}}$ which one commits to $\varValue$, from which follows that he could break the hiding property of perdersen commitments.
        Not being able to extract the coin values, the adversary has no chance of knowing if they are correct at this point.
        For the same reasons $\cnstSimulator$'s pre-transaction after the rewind will be indistinguishable from a real one.
        However, this time the pre-transaction is constructed from the real $\varTx$ that $\cnstSimulator$ received from the TTP, the pre-transaction is identical to a pre-transaction that would be expected in a real execution.
        The calls to $\procZKfId{\cnstRelation_1}, \procZKfId{\cnstRelation_2}$ and $\procZKfId{\cnstRelation_2*}$ also behave identically as what would be expected in a real execution.
        \item \textit{Phase 2:} This phase will be identical to the real execution because the adversary is deterministic.
        \item \textit{Phase 3:} The transaction sent to $\cnstAdversary$ in this phase is the one received from the TTP and is therefore identical to what would have been sent in a real execution, given $\cnstAdversary$ sends correct values. (Otherwise, the execution would have halted).
        We like to emphasize that in the case that we wouldn't have done the rewind step, $\cnstAdversary$ would distinguish the transcript from the real one.
        That is because he can identify differences in the inputs, outputs, proofs, and Commitment and the signature context of the final transaction $\varTx$ and the pre-transaction $\varPreTx$ sent in the first phase.
        For instance, inputs which are spent in the last transaction are not present in the pre-transaction.
        However, due to the rewinding step $\cnstSimulator$ manages to construct the correct pre-transaction, which will finalize into $\varTx$ such that $\cnstAdversary$ again has no chance of distinguishing the two transcripts.
        \item Regarding protocol outputs, if the adversary misbehaves at any point by sending invalid (or no) values, the simulator will notice, halt the protocol, and return whatever $\cnstAdversary$ returns.
        If $\cnstAdversary$ behaves honestly, $\cnstSimulator$ would run the protocol simulation until the end and then again output whatever $\cnstAdversary$ outputs.
        In both cases, the output would be the same as expected from $\cnstAdversary$ in a real execution.
    \end{itemize}

    We have managed to show that the transcripts produced by $\cnstSimulator$ in the case that Alice and in the case that Bob is corrupt are indistinguishable from the transcript of a real execution and can therefore conclude that the protocol is secure and~\cref{theo:atom:sec-tx} holds.

\end{proof}

Before we can continue to prove the security of the three other protocols \\$\procDSharedInpMwTxId$, $\procDSharedOutputMwTxId$, $\procDScriptMwTxId$, we first have to prove that all the run protocols as part of those executions are secure.
That is we have to show security for $\procDSendCoinsId$, $\procDRecvCoinsId$, $\procDFinTxId$, $\procDAptFinTxId$.

We start with the proof for $\procDSendCoinsId$ which is called inside $\procDSharedInpMwTxId$,
as well as $\procDScriptMwTxId$.

\textbf{Hybrid functionalities}: For this proof, we need to extend our hybrid model.
As previously, the parties have access to a trusted third party computing the zero-knowledge proof of knowledge functionalities $\procZKfId{\cnstRelation_1}, \procZKfId{\cnstRelation_2}$ and $\procZKfId{\cnstRelation_2*}$.
Additionally, we introduce $\procZKfId{\cnstRelation_3}$, whereas $\cnstRelation_3$ is the relation between a value $\varValue$, two secrets $\varBlindingFactorAlice, \varBlindingFactorCarol$ and the Commitment $\varCoin \opEqNoQ \funGenH{\varValue} \opAddPoint \funGen{\varBlindingFactorAlice} \opAddPoint \funGen{\varBlindingFactorCarol}$.
This means that for $\cnstRelation_3$ we have two provers, one of them having to provide $\varBlindingFactorAlice$, the other $\varBlindingFactorCarol$.
Both will have to give the Commitment $\varCoin$ and the value $\varValue$.
Both parties can then call the protocol again as the verifier providing the Commitment $\funStar{\varCoin}$ and receiving 1 if $\funStar{\varCoin} \opEqNoQ \varCoin_\varAlice \opEqNoQ \varCoin_\varCarol$ (whereas $\varCoin_\varAlice$ is the commitment received from Bob as the prover, resp. for Carol) $\varValue_\varAlice \opEqNoQ \varValue_\varCarol$ and $\funStar{\varCoin} \opEqNoQ \funGenH{\varValue_{\cdot}} \opAddPoint \funGen{\varBlindingFactorAlice} \opAddPoint \funGen{\varBlindingFactorCarol}$.
A proof system that would support such a relation is zk-SNARKS as can be seen in~\cite{ben2013snarks}.
To simplify the call made by the prover, we write $\procZkf{\cnstRelation_3}{\varPtSpendableCoin}$ as $\varPtSpendableCoin$ is, just like $\varSpendableCoin$, a wrapper around $\varCoin$, $\varBlindingFactor$, $\varValue$.
As for $\cnstRelation_2$, we again allow calling the protocol with an array of inputs by calling $\procZKfId{\cnstRelation_{3*}}$

\textbf{Proof Idea}: We extend the protocol $\procDSendCoinsId$ instantiated in~\cref{sec:atom:inst} with the following calls to the zero-knowledge proof of knowledge functionalities, as shown in~\cref{fig:atom:hybrid-dsend}.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering,skipfirstln]{$\procDSendCoins{\funArray{\varPtSpendableCoinAlice}}{\funArray{\varPtSpendableCoinCarol}}{\varFundValue}{\varTime}$}{
            Alice \< \< Carol \\
            \color{blue} \procZkf{\cnstRelation_{3*}}{\funArray{\varPtSpendableCoinAlice}} \< \< \color{blue} \procZkf{\cnstRelation_{3*}}{\funArray{\varPtSpendableCoinCarol}} \\
            \cdots \\
            \color{blue} \procZkf{\cnstRelation_2}{\funStar{\varSpendableCoinAlice}} \\
            \color{blue} \procZkf{\cnstRelation_1}{(\varSecKeyAlice, \funGen{\varSecKeyAlice})} \\
            \color{blue} \procZkf{\cnstRelation_1}{(\varNonceAlice, \funGen{\varNonceAlice})} \\
            \< \sendmessageright*{\varPreTx} \< \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation_{3*}}{\varPreTx.\varInputs} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \color{blue} \procZkf{\cnstRelation_2}{\varPreTx.\varOutputs[0]} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation_1}{\varSigContext.\varPubKey} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation_1}{\varSigContext.\varRand} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \cdots \\
            \< \< \color{blue} \procZkf{\cnstRelation_2}{\funStar{\varSpendableCoinCarol}} \\
            \< \< \color{blue} \procZkf{\cnstRelation_1}{(\varSecKeyCarol, \funGen{\varSecKeyCarol})} \\
            \< \< \color{blue} \procZkf{\cnstRelation_1}{(\varNonceCarol, \funGen{\varNonceCarol})} \\
            \< \sendmessageleft*{\funStarAlt{\varPreTx}} \< \\
            \color{blue} \pcif \procZkf{\cnstRelation_{3*}}{\funStarAlt{\varPreTx}.\varInputs} \opEqNoQ 0 \\
            \color{blue} \t \pcreturn \cnstFalsum \\
            \color{blue} \pcif \procZkf{\cnstRelation_2}{\funStarAlt{\varPreTx}.\varOutputs[1]} \opEqNoQ 0 \\
            \color{blue} \t \pcreturn \cnstFalsum \\
            \{ \varPubKey, \varRand \} \opFunResult \funStarAlt{\varPreTx}.\varSigContext \\
            \color{blue} \pcif \procZkf{\cnstRelation_1}{\varPubKey \opAddPoint \varPubKeyAlice^{-1}} \opEqNoQ 0 \\
            \color{blue} \t \pcreturn \cnstFalsum \\
            \color{blue} \pcif \procZkf{\cnstRelation_1}{\varRand \opAddPoint \varRandAlice^{-1}} \opEqNoQ 0 \\
            \color{blue} \t \pcreturn \cnstFalsum \\
            \pcreturn (\funStarAlt{\varPreTx}, \funStar{\varSpendableCoinAlice}, (\varSecKeyAlice, \varNonceAlice)) \< \< \pcreturn (\funStarAlt{\varPreTx}, \funStar{\varSpendableCoinCarol}, (\varSecKeyCarol, \varNonceCarol))
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Extension of $\procDSendCoinsId$ (\cref{fig:atom:dsendcoins}) in the hybrid model} \label{fig:atom:hybrid-dsend}
\end{figure}

\begin{theorem}
    \label{teo:atom:sec-dspend}
    Let $\varCommitScheme$ be a correct and secure Pedersen Commitment Scheme, $\varRProofSystem$ be a correct and secure Range Proof System and $\varSigSchemeMP$ be a secure and correct Two-Party Signature Scheme, then $\procDSendCoinsId$ securely computes a Mimblewimble pre-transaction $\funStarAlt{\varPreTx}$ spending a coin $\varCoinShared$ owned by the two parties in the hybrid $\procZKfId{\cnstRelation_1}$,$\procZKfId{\cnstRelation_2}$,$\procZKfId{\cnstRelation_3}$-model.
\end{theorem}

\begin{proof}
    The proof strategy is the same as already mentioned in the previous proof for~\cref{theo:atom:sec-tx}.

    \textbf{Alice is corrupted}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and saves $\funArray{\varPtSpendableCoinAlice}$, $\funStar{\varSpendableCoinAlice}$, $\varSecKeyAlice$, $\varNonceAlice$ when he calls $\procZKfId{\cnstRelation_{1,2,3}}$
        \item The simulator then receives $\varPreTx$ from $\cnstAdversary$ and compares the input coins, output coin, proof and signature context values with what he has stored in the first step.
        If any of those are not equal $\cnstSimulator$ sends $\cnstAbort$ to the TTP and outputs $\cnstFalsum$.
        Otherwise, he extracts $\varFundValue \opAssign \sum \funArray{\varPtSpendableCoinAlice.\varValue} \opSub \funStar{\varSpendableCoinAlice}.\varValue$ as well as $\varTime \opAssign \varPreTx.\varTime$ and sends the inputs $(\funArray{\varPtSpendableCoinAlice}, \varFundValue, \varTime)$ to the TTP and receives the outputs $(\funStarAlt{\varPreTx}, \funStar{\varSpendableCoinAlice}, (\varSecKeyAlice, \varNonceAlice))$.
        \item $\cnstSimulator$ sends $\funStarAlt{\varPreTx}$ to $\cnstAdversary$ as if coming from Carol and sends $\cnstContinue$ to the TTP to make $\cnstAdversary$ receive the outputs in the ideal setting.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_{1,2,3}}$ as the verifier he compares the values to what he has sent in $\funStarAlt{\varPreTx}$ and returns either 0 or 1.
        \item Finally, the simulator outputs whatever $\cnstAdversary$ outputs.
    \end{enumerate}
    We separate between the following three phases:
    \textbf{Phase 1}: Alice sends her partially owned inputs coins, newly created output coins, as well as her signing secrets to $\procZKfId{\cnstRelation_{1,2,3}}$ and sends $\varPreTx$.
    Carol sends her partially owned input coins to $\procZKfId{\cnstRelation{3}}$
    \textbf{Phase 2}: Carol calls $\cnstRelation_{1,2,3}$ as the verifier constructs her output coin and signing secrets, now calls $\cnstRelation_{1,2}$ as the prover and sends the updated $\funStarAlt{\varPreTx}$ to Alice.
    \textbf{Phase 3}: Alice calls $\cnstRelation_{1,2,3}$ as the verifier.
    Again the output returned by $\cnstSimulator$ must be indistinguishable from that of $\cnstAdversary$ in a real execution.

    We now argue why each phase is indistinguishable from a real execution if Alice is corrupted.

    \begin{itemize}
        \item \textit{Phase 1}: No simulation is required in this phase.
        We, therefore, conclude that it is indistinguishable from a real execution due to the deterministic nature of $\cnstAdversary$.
        \item \textit{Phase 2}: If $\cnstAdversary$ tried to cheat by providing invalid values in $\varPreTx$, the equalities that $\cnstSimulator$ checks will fail and will lead him to halt the protocol and return, which is the same as expected in a real execution.
        $\cnstSimulator$ then sends $\funStarAlt{\varPreTx}$ to $\cnstAdversary$, which he received from the TTP and therefore has to be identically distributed as in a real execution.
        \item \textit{Phase 3}: Again, if $\cnstAdversary$ tries to cheat by sending an invalid value, he will receive a 0 bit, which would also happen in the real execution.
        \item In the case that $\cnstAdversary$ would deviate from the protocol specification, and in the case that he follows it, $\cnstSimulator$ will always output whatever $\cnstAdversary$ outputs, which has to be indistinguishable from what is expected in a real execution.
    \end{itemize}

    As the transcript is identically distributed to a transcript of a real protocol execution, we conclude that the simulation, in this case, is perfect.

    \textbf{Carol is corrupt}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and saves $\funArray{\varPtSpendableCoinCarol}$ when the adversary calls $\procZKfId{\cnstRelation_{3*}}$
        \item The simulator then chooses $\varBlindingFactorAlice, \funStar{\varBlindingFactorAlice}, \varFundValue \sample \cnstIntegersPrimeWithoutZero{\varPrime}$ and sets \\ $\varPtSpendableCoinAlice \opAssign \{ \varCoin \opAssign \varPtSpendableCoinCarol.\varCoin, \varBlindingFactor \opAssign \varBlindingFactorAlice, \varValue \opAssign \varPtSpendableCoinCarol.\varValue \}$.
        He then proceeds by building $\varPreTx$ as given by the protocol specification with the chosen values and $\funArray{\varPtSpendableCoinAlice}$ and sends it to $\cnstAdversary$ as if coming from Alice.
        \item When Carol calls $\procZKfId{\cnstRelation_{1,2,3}}$ as the verifier, $\cnstSimulator$ checks the passed values for equality and returns either 0 or 1.
        As soon as Carol calls $\procZkf{\cnstRelation_{2}}{\varSpendableCoinCarol}$ $\cnstSimulator$ will extract $\varFundValue \funStar{\varSpendableCoinCarol}.\varValue$ and finally call the TTP with inputs $(\funArray{\varPtSpendableCoinCarol}, \varFundValue)$ to receive $\funStarAlt{\varPreTx}, \funStar{\varSpendableCoinCarol}, (\varSecKeyCarol, \varNonceCarol)$.
        \item Now the simulator rewinds to step 1 and constructs the actual $\varPreTx$ from $\funStarAlt{\varPreTx}$ as follows:
        \begin{gather*}
            \{ \varMsg, \varInputs, \varOutputs, \varProofs, \varSigContext, \varCommits, \cnstEmptySet, \varTime \} \opFunResult \funStarAlt{\varPreTx} \\
            \varPubKeyAlice \opAssign \funStarAlt{\varPreTx}.\varSigContext.\varPubKey \opAddPoint {\funGen{\varSecKeyCarol}}^{-1} \\
            \varRandAlice \opAssign \funStarAlt{\varPreTx}.\varSigContext.\varRand \opAddPoint {\funGen{\varNonceCarol}}^{-1} \\
            \funStar{\varSigContext} \opAssign \{ \varPubKey \opAssign \varPubKeyAlice, \varRand \opAssign \varRandAlice \} \\
            \varPreTx \opAssign \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs[0]}{\varProofs[0]}{\funStar{\varSigContext}}{\varCommits[0]}{\cnstEmptySet}{\varTime}
        \end{gather*}
        he then sends again $\varPreTx$ as if coming from Carol and continues as before.
        \item When $\cnstAdversary$ sends $\funStarAlt{\varPreTx}$, he compares its inputs, outputs, proofs, and signature context to $\funStarAlt{\varPreTx}$ received from the trusted third party and sends $\cnstAbort$ to the TTP and returns whatever $\cnstAdversary$ if any do not match.
        Otherwise, he sends $\cnstContinue$ to the TTP and again outputs whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    We again show that the transcript produced by the simulator is computationally indistinguishable from a real transcript in each phase.

    \begin{itemize}
        \item \textit{Phase 1}: In the first iteration (before the rewind), the pre-transaction that is sent to $\cnstAdversary$ will be constructed from randomly chosen values except for the transaction inputs given by the Commitments in $\funArray{\varPtSpendableCoinCarol}$.
        Due to the hiding property of the Pedersen Commitment the adversary cannot determine if the correct value $\varFundValue$ has been used to construct the output coin, even though he knows the right value for $\varFundValue$ but does not know the blinding factor $\funStar{\varBlindingFactorAlice}$.
        $\cnstAdversary$ does know the correct values for the input coins from $\funArray{\varPtSpendableCoinCarol}$.
        Thereby $\cnstSimulator$ must use the Commitments extracted from $\funArray{\varPtSpendableCoinCarol}$ to build the transaction.
        Otherwise, one could detect the simulation.
        In the second iteration (after the rewind), $\cnstSimulator$ sends the same $\varPreTx$, which would be expected in a real execution which is therefore identically distributed.
        \item \textit{Phase 2}: When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_{1,2,3}}$ he will receive 0 or 1 again identically to what is expected in a real execution.
        \item \textit{Phase 3}: If $\cnstAdversary$ sends invalid input, output, proof, or context values, in the final pre-transaction $\funStarAlt{\varPreTx}$ the simulator detects this and returns.
        Otherwise the protocol concludes.
        \item Both in the case in which $\cnstAdversary$ behaves as of protocol specification and where he deviates, $\cnstSimulator$ will always output whatever $\cnstAdversary$ outputs, making the simulator's output indistinguishable from what would be expected in a real scenario.
    \end{itemize}

    We have managed to show that the simulator $\cnstSimulator$ can produce an indistinguishable transcript both in the case that Alice and in that Carol is corrupted and conclude that $\procDSendCoinsId$ is secure in the $\procZKfId{\cnstRelation_1}$,$\procZKfId{\cnstRelation_2}$,$\procZKfId{\cnstRelation_3}$-model and~\cref{teo:atom:sec-dspend} holds.
\end{proof}

We continue by proofing the security of the $\procDRecvCoinsId$, which is called inside the \\$\procDSharedOutputMwTxId$ protocol.

\textbf{Hybrid functionalities}: Again, the parties have access to a trusted third party computing the zero-knowledge proof of knowledge functionalities $\procZKfId{\cnstRelation_1}$, $\procZKfId{\cnstRelation_2}$, and $\procZKfId{\cnstRelation_2*}$.
For this proof, we do not need $\cnstRelation_3$ as defined in the previous proof.
However, we extend the model with two other protocols which have already been proven secure.
We extend our model including the $\procDSignId$ protocol, proven to be secure in~\cref{sec:sig:two-party-apt-security} and the $\procDRProofId$ for which one can find a secure protocol in~\cite{klinec2020privacy}.

\textbf{Proof idea}: We extend the protocol $\procDRecvCoinsId$ instantiated in~\cref{sec:atom:inst} with the following calls to the zero-knowledge proof of knowledge functionalities as outlined in~\cref{fig:atom:hybrid-drecv}.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering,skipfirstln]{$\procDRecvCoins{\varPreTx}{\varFundValue}$} {
            Bob \< \< \< \< Carol \\
            \cdots \\
            \color{blue} \procZkf{\cnstRelation_2}{(\varCoinShared, (\varFundValue, \funStar{\varBlindingFactorBob}))} \\
            \< \sendmessageright*[3cm]{\varPreTx, \varCoinShared} \< \\
            \< \< \< \< \color{blue} \pcif \procZkf{\cnstRelation_2}{\varCoinShared} \opEqNoQ 0 \\
            \< \< \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \< \< \cdots \\
            \< \< \< \< \color{blue} \procZkf{\cnstRelation_1}{(\varSecKeyCarol, \funGen{\varSecKeyCarol})} \\
            \< \sendmessageleft*[3cm]{\funStarAlt{\varPreTx}, \funGen{\varSecKeyCarol}} \< \\
            \color{blue} \pcif \procZkf{\cnstRelation_1}{\funGen{\varSecKeyCarol}} \opEqNoQ 0 \\
            \t \color{blue} \pcreturn \cnstFalsum \\
            \cdots \< \< \< \< \cdots \\
            \varProofBobCarol \opFunResult \procDRProofL{\funStarAlt{\varCoinShared}}{\varFundValue}{\varSecKeyBob} \< \< \< \< \varProofBobCarol \opFunResult \procDRProofL{\funStarAlt{\varCoinShared}}{\varFundValue}{\varSecKeyCarol} \\
            (\varSigBobCarol, \varPubKeyBobCarol) \opFunResult \< \< \< \< (\varSigBobCarol, \varPubKeyBobCarol) \opFunResult \pcskipln \\
            \procDSignL{\varMsg}{\varSecKeyBob}{\varNonceBob} \< \< \< \< \procDSignR{\varMsg}{\varSecKeyCarol}{\varNonceCarol} \\
            \cdots \< \< \< \< \cdots \\
            \pcreturn (\funStar{\varPreTx}, \funStar{\varPtSpendableCoinBob}) \< \< \< \< \pcreturn (\funStar{\varPreTx}, \funStar{\varPtSpendableCoinCarol})
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Extension of $\procDRecvCoinsId$ (\cref{fig:atom:drecv}) in the hybrid model} \label{fig:atom:hybrid-drecv}
\end{figure}

\begin{theorem}
    \label{teo:atom:sec-drecv}
    Let $\varCommitScheme$ be a correct and secure Pedersen Commitment Scheme, $\varMPRProofSystem$ be a correct and secure Two-Party Range Proof System, and $\varSigSchemeMP$ be a secure and correct Two-Party Signature Scheme, then $\procDRecvCoinsId$ securely updates a Mimblewimble pre-transaction by creating a new output coin $\funStarAlt{\varCoinShared}$ for which the key is shared between two parties Bob and Carol in the $\procZKfId{\cnstRelation_1}$,$\procZKfId{\cnstRelation_2}$,$\procDSignId$,$\procDRProofId$-model.
\end{theorem}

\begin{proof}
    The proof strategy again is as specified in the proof for~\cref{theo:atom:sec-tx}.

    \textbf{Bob is corrupted}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and saves ($\varCoinShared$, ($\varFundValue, \funStar{\varBlindingFactorBob}$)) when the adversary calls $\procZKfId{\cnstRelation_2}$.
        \item $\cnstAdversary$ sends $(\varPreTx,\varCoinShared)$ to Alice.
        The simulator then compares $\varCoinShared$ with the values saved in its memory and sends $\cnstAbort$ to the TTP, halts the protocol, and outputs whatever $\cnstAdversary$ outputs if they don't match.
        Otherwise, he sends $(\varPreTx, \varFundValue)$ to the TTP computing $\procRecvCoinsId$ and receives the results $(\funStar{\varPreTx}, \funStar{\varPtSpendableCoinBob})$.
        \item $\cnstSimulator$ proceeds by taking the last output $\funStarAlt{\varCoinShared}$ from $\funStar{\varPreTx}.\varOutputs$ and computes $\funGen{\varSecKeyCarol} \opAssign \funStarAlt{\varCoinShared} \opAddPoint {\varCoinShared}^{-1}$.
        The simulator computes $\funStarAlt{\varPreTx}$ by adding $\funStarAlt{\varCoinShared}$ to $\varPreTx$ sending it together with $\funGen{\varSecKeyCarol}$ to $\cnstAdversary$ as if coming from Carol and sends $\cnstContinue$ to the TTP.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_1}$ as the verifier $\cnstSimulator$ check equality with the correct value and returns either 0 or 1.
        \item When the adversary calls $\procDRProofId$, the simulator saves $\varSecKeyBob$ to its memory and returns the last element of $\funStar{\varPreTx}.\varProofs$ as received from the TTP.
        \item For the call to $\procDSignId$, the simulator returns the $\varPreTx.\varSignature$ as the signature and $\funGen{\varSecKeyBob} \opAddPoint \funGen{\varSecKeyCarol}$ as the public key.
        \item $\cnstSimulator$ concludes by outputting whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    We find the following phases:
    \textbf{Phase 1}: Bob calls $\procZKfId{\cnstRelation_2}$ and sends $\varPreTx$ to Carol.
    \textbf{Phase 2}: Carol calls $\procZKfId{\cnstRelation_2}$ as the verifier adds her public key to the Commitment and sends back an updated pre-transaction and her public key.
    \textbf{Phase 3}: Bob calls $\procZKfId{\cnstRelation_1}$ as the verifier, and the parties call the trusted third parties computing $\procDRProofId$ and $\procDSignId$.
    Finally, we again have to show that the simulator's output is indistinguishable from that of $\cnstAdversary$ in a real execution.

    We argue that in this case, the simulation is perfect.
    That is the transcript produced by $\cnstSimulator$ is identically distributed as a transcript produced during a real execution.
    \begin{itemize}
        \item \textit{Phase 1}: No simulation is done during this phase, and the transcript is thereby indistinguishable from a real one simply by the deterministic nature of $\cnstAdversary$.
        \item \textit{Phase 2}: In case $\cnstAdversary$ sends an invalid value for $\varCoinShared$ the execution will stop, which is the same as would happen in a real execution.
        The simulator proceeds by sending the updated pre-transaction and the extracted value for $\funGen{\varSecKeyCarol}$, exactly as would be expected from honest Carol.
        \item \textit{Phase 3}: $\cnstAdversary$ will receive 0 or 1 to the call to $\procZKfId{\cnstRelation_1}$ as in the real execution, depending on if he sends a valid or invalid value.
        In the case that $\cnstAdversary$ behaves dishonestly, $\cnstSimulator$ will notice and halt the protocol.
        If he instead acts honestly, the simulator will simulate the protocol until the end.
        $\cnstSimulator$ will return whatever $\cnstAdversary$ returns making the output indistinguishable from an output produced by $\cnstAdversary$ in a real execution.
    \end{itemize}

    \textbf{Carol is corrupted}: The simulator works as follows:
    \begin{enumerate}
        \item Since Carol does not have any inputs in this protocol, $\cnstSimulator$ can send $\cnstEmptySet$ to the TTP to receive ($\funStar{\varPreTx}, \funStar{\varSpendableCoinCarol}$), from which he extracts Carol's blinding factor (and secret key) as $\varSecKeyCarol \opAssign \funStar{\varSpendableCoinCarol}.\varBlindingFactor$.
        He can now create the initial shared coin $\varCoinShared$ by taking the last output of $\funStar{\varPreTx}.\varOutputs$ as $\funStarAlt{\varCoinShared}$ and calculating $\varCoinShared \opAssign \funStarAlt{\varCoinShared} \opAddPoint {\funGen{\varSecKeyCarol}}^{-1}$.
        he can further create the initial pre-transaction by removing the last entry of the output coin list, last entry of the proof list, and signature from $\funStar{\varPreTx}$.
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and sends $\varPreTx, \varCoinShared$ (as calculated in step 1) as if coming from Bob.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_2}$ as the verifier, the simulator checks equality with what he sent in the last step and returns 0 or 1.
        \item The adversary then sends the updated $\funStarAlt{\varPreTx}$ which the simulator validates by checking if the last entry in $\funStarAlt{\varPreTx}.\varOutputs$ equals $\funStarAlt{\varCoinShared}$.
        If they don't $\cnstSimulator$ will send $\cnstAbort$ to the TTP halting the execution and returning whatever $\cnstAdversary$ returns.
        Otherwise, he will send $\cnstContinue$.
        \item Upon the adversary calling $\procDRProofId$, the simulator will return the proof at the last position in the proofs array of $\funStar{\varPreTx}.\varProofs$ received from the TTP.
        \item The simulator then extracts $\varFundValue \opAssign \funStar{\varPtSpendableCoinCarol}$ and computes $\varPubKeyBob \opAssign \varCoinShared \opAddPoint {\funGenH{\varValue}}^{-1}$ and returns $\funStar{\varPreTx}.\varSignature$ and $\funStar{\varSecKeyCarol} \opAddPoint \varPubKeyBob$ when $\cnstAdversary$ calls $\procDSignId$.
        \item The simulation completes with $\cnstSimulator$ outputting whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    We now argue why in each of the three phases, the transcript produced by $\cnstSimulator$ is indistinguishable from a real transcript.

    \begin{itemize}
        \item \textit{Phase 1}: Because $\cnstSimulator$ can call the TTP already in the first step, he can receive the protocol outputs instantly.
        The simulator can then extract Carol's secret key $\varSecKeyCarol$ from Carol's $\funStar{\varPtSpendableCoinCarol}$ output, which must also be her blinding factor in $\funStarAlt{\varCoinShared}$.
        He, therefore, can reconstruct $\varCoinShared$ which would have been sent by Bob in a real execution, by subtracting Carol's part from the output, which is present in $\funStar{\varPreTx}.\varOutputs$.
        $\cnstSimulator$ is further able to reconstruct the $\varPreTx$, which would have been sent by Bob in a real execution by removing the values from $\funStar{\varPreTx}$ which get added at a later point in the protocol.
        Therefore the transcript in this phase is exactly how it would be expected in a real execution.
        \item \textit{Phase 2}: If $\cnstAdversary$ tries do cheat by sending an invalid value to $\procZKfId{\cnstRelation_2}$ as the verifier, he will receive 0 as a response and 1 otherwise, which is identical to what would happen in a real execution.
        Similarly, the execution will halt if $\cnstAdversary$ sends invalid values as $\funStarAlt{\varPreTx}$ and $\funGen{\varSecKeyCarol}$, again how it would happen in a real execution.
        \item \textit{Phase 3}: $\cnstSimulator$ is able to read the output values for $\varProofBobCarol$ and $\varSigBobCarol$ from $\funStar{\varPreTx}$.
        He further is able to calculate $\varPubKeyBobCarol$ as he knows $\funGen{\varSecKeyCarol}$ and can reconstruct $\varPubKeyBob$ from $\varCoinShared$.
        Therefore, the simulation again is perfect also in this phase.
        \item Regarding protocol outputs, the simulator will again detect if $\cnstAdversary$ deviates from the protocol specification at any point and will output whatever $\cnstAdversary$ outputs in any case, making the protocol output indistinguishable from one of a real execution.
    \end{itemize}

    Both in the case, Bob and Carol are corrupted, $\cnstSimulator$ can produce a transcript indistinguishable from a transcript produced on a real execution.
    Therefore, we can conclude that the protocol is secure in the $\procZKfId{\cnstRelation_1}$,$\procZKfId{\cnstRelation_2}$,$\procDSignId$,$\procDRProofId$-model, and ~\cref{teo:atom:sec-drecv} holds.
\end{proof}

We claim that the security proof of the protocols $\procDFinTxId$ and $\procDAptFinTxId$ can be reduced to the proof for $\procDSignId$ as all interaction between the two parties happens in the call to $\procDSignId$.
We have already proven the security of $\procDSignId$ in~\cref{sec:sig:two-party-apt-security} and can reuse the simulator for the protocols $\procDFinTxId$ and $\procDAptFinTxId$.

We can now continue to prove the security of the protocols found in~\cref{sec:atom:protocols}.
We start with $\procDSharedOutputMwTxId$.

\textbf{Hybrid functionalities}: For this proof, we again assume access to a trusted third party computing the zero-knowledge proof of knowledge functionalities $\procZKfId{\cnstRelation_1}$, $\procZKfId{\cnstRelation_2}$ and $\procZKfId{\cnstRelation_{3*}}$, with the three relations defined as in previous proofs.
We further require a trusted third-party computing $\procDRecvCoinsId$, which we have already proven to be secure in the hybrid model.

\textbf{We extend the protocol $\procDSharedOutputMwTxId$} instantiated in~\cref{sec:atom:protocols} with the following calls to the zero-knowledge proof of knowledge functionalities shown in~\cref{fig:atom:hybrid-sharedinp}.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering,skipfirstln]{$\procDSharedOutputMwTx{\funArray{\varSpendableCoin}}{\varFundValue}{\varTime}$}{
            Alice \< \< Bob \\
            \color{blue} \procZkf{\cnstRelation_{3*}}{\funArray{\varSpendableCoin}} \\
            (\varPreTx, \funStar{\varSpendableCoinAlice}, (\varSecKeyAlice, \varNonceAlice)) \pcskipln \\
            \opFunResult \procSendCoins{\funArray{\varSpendableCoin}}{\varFundValue}{\varTime} \\
            \color{blue} \procZkf{\cnstRelation_{2}}{\funStar{\varSpendableCoinAlice}} \\
            \color{blue} \procZkf{\cnstRelation_{1}}{(\varSecKeyAlice, \funGen{\varSecKeyAlice})} \\
            \color{blue} \procZkf{\cnstRelation_{1}}{(\varNonceAlice, \funGen{\varNonceAlice})} \\
            \< \sendmessageright*{\varPreTx} \< \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation_{3*}}{\varPreTx.\varInputs} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation_{2}}{\varPreTx.\varOutputs[0]} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation_{1}}{\varPreTx.\varSigContext.\varPubKey} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            \< \< \color{blue} \pcif \procZkf{\cnstRelation_{1}}{\varPreTx.\varSigContext.\varRand} \opEqNoQ 0 \\
            \< \< \color{blue} \t \pcreturn \cnstFalsum \\
            (\funStarAlt{\varPreTx}, \funStar{\varPtSpendableCoinAlice}) \< \< (\funStarAlt{\varPreTx}, \funStar{\varPtSpendableCoinBob}) \pcskipln \\
            \opFunResult \procDRecvCoinsL{\varPreTx}{\varFundValue}  \< \< \opFunResult \procDRecvCoinsR \\
            \varTx \opFunResult \procFinTx{\funStarAlt{\varPreTx}}{\varSecKeyAlice}{\varNonceAlice} \\
            \< \sendmessageright*{\varTx} \\
            \pcreturn (\varTx, \funStar{\varSpendableCoinAlice}, \funStar{\varPtSpendableCoinAlice}) \< \< \pcreturn (\varTx, \funStar{\varPtSpendableCoinBob})
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Extension of $\procDSharedOutputMwTxId$(\cref{fig:d-shared-out-mw-tx}) in the hybrid model}  \label{fig:atom:hybrid-sharedinp}
\end{figure}

\begin{theorem}
    \label{teo:atom:sec-sharedout-tx}
    Let $\varCommitScheme$ be a correct and secure Pedersen Commitment Scheme, $\varRProofSystem$ be a correct and secure Range Proof System and $\varSigSchemeMP$ be a secure and correct Two-Party Signature Scheme, then $\procDSharedOutputMwTxId$ securely computes a Mimblewimble transaction with a output coin $\funStarAlt{\varCoinShared}$ which spending secret is shared between Alice and Bob.
\end{theorem}

\begin{proof}
    The proof strategy is again as defined in the proof for~\cref{theo:atom:sec-tx}.

    \textbf{Alice is corrupted}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and saves $\funArray{\varSpendableCoin}$, $\varSecKeyAlice$, $\varNonceAlice$ and $\funStar{\varSpendableCoinAlice}$ to its memory.
        \item $\cnstAdversary$ sends $\varPreTx$ from which $\cnstSimulator$ extracts $\varTime \opAssign \varPreTx.\varTime$. \\
        He further extracts $\varFundValue \opAssign \sum\varSpendableCoin_i.\varValue \opSub \funStar{\varSpendableCoinAlice}.\varValue$.
        $\cnstSimulator$ verifies that the values $\varPreTx.\varInputs$, $\varPreTx.\varOutputs$, $\varPreTx.\varProof$ and $\varPreTx.\varSigContext$ correspond to what he has saved to its memory.
        In case this verification fails he sends $\cnstAbort$ to the TTP and outputs whatever $\cnstAdversary$ outputs.
        \item $\cnstSimulator$ sends ($\funArray{\varSpendableCoin}$, $\varFundValue$, $\varTime$) to the TTP and receives ($\varTx$, $\funStar{\varSpendableCoinAlice}$, $\varPtSpendableCoinAlice$).
        \item When $\cnstAdversary$ calls $\procDRecvCoinsId$, $\cnstSimulator$ verifies that $\varPreTx$ and $\varFundValue$ passed by $\cnstAdversary$ are correct and only then forwards them to the TTP to receive ($\funStarAlt{\varPreTx}, \funStar{\varPtSpendableCoinAlice}$) which he then sends to $\cnstAdversary$.
        Otherwise, he returns $\cnstFalsum$ to $\cnstAdversary$ and sends $\cnstAbort$ to the TTP, and halts the protocol returning whatever $\cnstAdversary$ returns.
        \item $\cnstSimulator$ sends $\cnstContinue$ to TTP.
        Eventually, $\cnstAdversary$ sends $\varTx$, after which $\cnstSimulator$ outputs whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    It is easy to see that the simulation is perfect as every simulated message exchanged between the party is identical to what is expected in a real execution.
    Also, if the adversary cheats (by sending an invalid $\varPreTx$), this is noticed by the simulator, who then halts the protocol and outputs whatever $\cnstAdversary$ outputs, which is again what would be expected in a real protocol execution.

    \textbf{Bob is corrupted}: Simulator works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and sends $()$ to the TTP to receive the outputs ($\varTx$, $\funStar{\varPtSpendableCoinBob}$)
        \item $\cnstSimulator$ now has the following challenge: $\cnstAdversary$ first expects the first pre-transaction $\varPreTx$ coming from Alice, which should not have any signature, only one output (Alice change output), and only a partially set up signature context $\varSigContext$.
        To achieve this, $\cnstSimulator$ clones $\varTx$ into $\varPreTx$ removes the last output coin (and proof) and sets the signature field to $\cnstEmptySet$.
        The simulator can now construct the partially set up signature context as follows:
        \begin{gather*}
            \varSecKeyAlice, \varNonceAlice \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \funStarAlt{\varSigContext} \opAssign \{ \varPubKey \opAssign \funGen{\varSecKeyAlice}, \funGen{\varNonceAlice} \}
        \end{gather*}
        He then sets $\varPreTx.\varSigContext \opAssign \funStarAlt{\varSigContext}$ and sends $\varPreTx$ to $\cnstAdversary$ as if coming from Alice.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_{1,2,3}}$ as the verifier $\cnstSimulator$ compares the values with what he sent in step 1 in $\varPreTx$ and returns either 0 or 1.
        \item $\cnstAdversary$ will call $\procDRecvCoinsId$, upon which $\cnstSimulator$ calls the TTP computing $\procDRecvCoinsId$ to receive $\funStarAlt{\varPreTx}$, $\funStar{\varPtSpendableCoinBob}$, which $\cnstSimulator$ then returns to $\cnstAdversary$.
        \item Finally, $\cnstSimulator$ sends $\varTx$ as if coming from Alice and outputs whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    It is easy to see that $\cnstSimulator$'s $\varTx$ sent in the last step is exactly what would be expected in a real execution as the TTP has computed it.
    When $\cnstAdversary$ tries to cheat by sending invalid values to $\procZKfId{\cnstRelation_{1,2,3}}$ he will receive 0, as would be the case in a real execution.
    $\funStarAlt{\varPreTx}$ must be as expected in a real execution as it is computed by the trusted third-party computing $\procDRecvCoinsId$.
    Therefore the only thing that remains to show is that $\varPreTx$ constructed by the simulator is indistinguishable from a $\varPreTx$ exchanged in a real transcript.
    We note that $\varSecKeyAlice$ and $\varNonceAlice$ in a real execution are uniformly distributed values in $\cnstIntegersPrimeWithoutZero{\varPrime}$.
    Consequently, $\funGen{\varSecKeyAlice}$ and $\funGen{\varNonceAlice}$ are uniformly distributed in $\cnstGroup$.
    By construction of $\cnstSimulator$, this must also hold in the simulated case.
    Therefore the signature context built in step 2 for $\varPreTx$ must be indistinguishable from a real one, which means that the $\varPreTx$ is indistinguishable, as the rest of the values are taken from $\varTx$ as computed by the TTP.
    We must also note that even when $\cnstAdversary$ receives $\funStarAlt{\varPreTx}$ and $\varTx$ later in the protocol, he has no way of realizing that $\varTx$ was constructed by $\cnstSimulator$.
    This follows from the fact that the final $\varRand$ and $\varPubKey$ in the final signature context of $\funStarAlt{\varPreTx}$ and $\varTx$ is composed of three values:
    $\varSigContext \opEqNoQ {\varPubKeyAlice}_1 \opAddPoint {\varPubKeyAlice}_2 \opAddPoint {\varPubKeyBob}$ (similar for $\varRand$).
    $\cnstAdversary$ only learns one of Alice's public keys (from step 2) and knows his own but does not know anything about Alice's second key pair.
    Therefore he has no way of learning that the final $\varPubKey$ was not computed as of protocol specification.
    The same argument holds for $\varRand$.

    We have shown that the simulator $\cnstSimulator$ can produce an indistinguishable transcript both in the case that Alice and Bob are corrupted and conclude that $\procDSharedOutputMwTxId$ is secure in the $\procZKfId{\cnstRelation_1}$,$\procZKfId{\cnstRelation_2}$,$\procZKfId{\cnstRelation_3}$,$\procDRecvCoinsId$-model, and consequently~\cref{teo:atom:sec-sharedout-tx} holds.
\end{proof}

Next, we proof security for $\procDSharedInpMwTxId$.

\textbf{Hybrid functionalities}: For this proof, it is enough to give the parties access to a trusted third party computing the $\procDSendCoinsId$ and the $\procDFinTxId$ protocol.
Further calls to a zero-knowledge proof of knowledge functionality are not needed.
That means that we do not have to extend to original protocol instantiation seen in~\cref{fig:d-shared-inp-mw-tx} any further.

\begin{theorem}
    \label{teo:atom:sec-dshared-inp}
    Let $\varCommitScheme$ be a correct and secure Pedersen Commitment Scheme, $\varMPRProofSystem$ a correct and secure Two-Party Range Proof system, and $\varSigSchemeMP$ be a secure and correct Two-Party Signature Scheme, then $\procDRecvCoinsId$ securely computes a Mimewimble transaction spending an input coin $\varCoinShared$ shared between Alice and Bob in the hybrid $\procDSendCoinsId,\procDFinTxId$-model
\end{theorem}

\begin{proof}
    The proof strategy is as defined in the proof for~\cref{theo:atom:sec-tx}.

    \textbf{Alice is corrupted}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and saves $\funArray{\varPtSpendableCoinAlice}$, $\varFundValue$ and $\varTime$ when $\cnstAdversary$ calls $\procDSendCoinsId$.
        \item He then forwards those values as the inputs to the TTP computing $\procDSendCoinsId$ and receives ($\varPreTx$, $\funStar{\varSpendableCoinAlice}, (\varSecKeyAlice, \varNonceAlice)$), which he returns to $\cnstAdversary$.
        He proceeds by sending the inputs ($\funArray{\varPtSpendableCoinAlice}, \varFundValue, \varTime$) to the TTP computing $\procDSharedInpMwTxId$ and receives ($\varTx, \funStar{\varSpendableCoinBob}$).
        \item The simulator now has the challenge to construct a $\funStarAlt{\varPreTx}$, which is partially signed.
        The final signature is composed of A + B1 + B2, where B2 is the signature share from Bob's output coins and A + B1 are the signature shares from the shared input coin.
        $\funStarAlt{\varPreTx}$ has to contain the partial signature B2, such that the partial signature verification algorithm verifies and such that when combined with the signatures A and B1, it will complete into the final signature $\varTx.\varSignature$.
        Therefore the only way for the simulator to create a valid simulation is to calculate the actual value for the B2 signature, which is challenging since he does not know $\varSecKeyBob$ and $\varNonceBob$.
        However, he knows the final signature $\varSigFin \opAssign \varTx.\varSignature$ and he can create the signature A as $\varSigAlice \opFunResult \procSignPrt{\varTx.\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varTx.\varSigContext}$.
        $\cnstSimulator$ can recompute the value for the B2 signature as follows:
        \begin{enumerate}
            \item $\cnstSimulator$ chooses $(\funStarAlt{\varSecKeyBob}, \funStarAlt{\varNonceBob}) \sample \cnstIntegersPrimeWithoutZero{\varPrime}$
            \item He then computes a temporary $\funStarAlt{\varSigBob} \opFunResult \procSignPrt{\varTx.\varMsg}{\funStarAlt{\varSecKeyBob}}{\funStarAlt{\varNonceBob}}{\varTx.\varSigContext}$
            \item He clones $\varTx$ into $\funStarAlt{\varPreTx}$ and sets $\funStarAlt{\varPreTx}.\varSignature \opAssign \funStarAlt{\varSigBob}$
            \item Now the simulator calls the TTP computing $\procDFinTxId$ with the inputs $\funStarAlt{\varPreTx}$, $\varSecKeyAlice$, $\varNonceAlice$ to receive $\funStarAlt{\varTx}$
            \item Note that the signature in $\funStarAlt{\varTx}$ now contains a signature composed of A + B1 + B2', where B2' is the partial signature computed in step b.
            Therefore now it is possible to recompute the value of the partial signature for B1 as follows:
            \begin{gather*}
                (\funStarAlt{\varS}, \funStarAlt{\varRand}) \opFunResult \funStarAlt{\varTx} \\
                (\varSAlice, \varRandAlice, \varSigContext) \opFunResult \varSigAlice \\
                (\funStarAlt{\varSBob}, \funStarAlt{\varRandBob}, \varSigContext) \opFunResult \funStarAlt{\varSigBob} \\
                {\varSBob}_1 \opAssign \funStarAlt{\varS} \opSub \varSAlice \opSub \funStarAlt{\varSBob} \\
                {\varRandBob}_1 \opAssign \funStarAlt{\varRand} \opAddPoint {\varRandAlice}^{-1} \opAddPoint {\funStarAlt{\varRandBob}}^{-1} \\
                {\varSigBob}_1 \opAssign \{ {\varSBob}_1, {\varRandBob}_1, \varSigContext \}
            \end{gather*}
            \item $\cnstSimulator$ now has the correct values for the signatures A and B1 and can therefore recompute the right value for the partial signature B2 from $\varTx.\varSignature$ with the same calculation as shown in the previous step
        \end{enumerate}
        \item $\cnstSimulator$ can now construct $\funStarAltDouble{\varPreTx}$ by again cloning $\varTx$ and setting $\funStarAltDouble{\varPreTx}.\varSignature \opAssign {\varSigBob}_2$.
        The simulator will rewind the call to the TTP computing $\procDFinTxId$ and send $\funStarAltDouble{\varPreTx}$ to $\cnstAdversary$ as if coming from Bob.
        \item When $\cnstAdversary$ calls $\procDFinTxId$ $\cnstSimulator$ will forward the inputs to the TTP party computing $\procDFinTxId$, return the TTP outputs to $\cnstAdversary$ and finally output whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    As only $\funStarAlt{\varPreTx}$ is constructed by $\cnstSimulator$, it is the only value for which we have to prove indistinguishability.
    We have already shown that $\varTx$'s final signature is composed of three parts A, B1, and B2.
    Through the calculations laid out the simulator can recompute the actual value of B2, as it would be in real execution, which must make $\funStarAlt{\varPreTx}$ identical to what would be sent by an honest Bob in a real execution.

    \textbf{Bob is corrupted}: Simulation, in this case, is trivial, as there is no message sent from Alice to Bob, and $\cnstSimulator$ doesn't need to extract any inputs.
    Therefore, a perfect simulation is achieved by forwarding the inputs sent by $\cnstAdversary$ to the TTP computing $\procDSendCoinsId$ and $\procDFinTxId$ and finally outputting whatever $\cnstAdversary$ outputs.

    We have managed to construct a simulator in the case the Alice and Bob are corrupted, which produced a protocol transcript indistinguishable from a real one and therefore conclude, that $\procDSharedInpMwTxId$ is secure in the $\procDSendCoinsId$,$\procDFinTxId$-model, and~\cref{teo:atom:sec-dshared-inp} must hold.
\end{proof}

We now move to the final proof, proving security of $\procDScriptMwTxId$:

\textbf{Hybrid functionalities}: We prove the security of $\procDScriptMwTxId$ in the hybrid model in which the participants have access to a trusted third party computing $\procDSendCoinsId$ and $\procDAptFinTxId$.
We also again require access to a trusted third party computing the zero-knowledge proof of knowledge functionality $\procZKfId{\cnstRelation_1}$, with $\cnstRelation_1$ being defined equally in previous proofs.

\textbf{Proof idea}: We extend the original $\procDScriptMwTxId$ with a single call to $\procZKfId{\cnstRelation_1}$ from Alice and Bob.
On Bob's side, we extend the protocol with the following call at the beginning of the protocol: $\color{blue} \procZkf{\cnstRelation_1}{(\varWit, \funGen{\varWit})}$.
On Alice side, we add the following verification at line 2 of the protocol: $\color{blue} \textbf{If}\; \procZkf{\cnstRelation_1}{\varStatement} \opEqNoQ 0 \; \textbf{return}\; \cnstFalsum$.

\begin{theorem}
    \label{teo:atom:sec-dcontract-mw}
    Let $\varCommitScheme$ be a correct and secure Pedersen Commitment Scheme, $\varMPRProofSystem$ be a correct and secure Two-Party Range Proof System, and $\varSigSchemeMP$ be a secure and correct Two-Party Signature Scheme, then $\procDScriptMwTxId$ securely computes a Mimblewimble transaction transferring value from a shared input coin $\varCoinShared$ to Bob, while at the same time revealing a secret witness value $\varWit$ to Alice, for which she knows $\varStatement \opEqNoQ \funGen{\varWit}$.
\end{theorem}

\begin{proof}
    The proof strategy is as defined in the proof for~\cref{theo:atom:sec-tx}.

    \textbf{Alice is corrupted}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and saves the inputs $\funArray{\varPtSpendableCoinAlice}$, $\varFundValue$ and $\varTime$ when the adversary calls $\procDSendCoinsId$.
        \item He forwards the inputs received in step 1 to the TTP computing $\procDSendCoinsId$ to receive the outputs ($\varPreTx$, $\funStar{\varSpendableCoinAlice}$, $\varKeyPairAlice$), which he then forwards to $\cnstAdversary$ as the protocol results.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_1}$ as the verifier, $\cnstSimulator$ saves $\varStatement$ to his memory and sends the inputs ($\funArray{\varPtSpendableCoinAlice}$, $\varFundValue$, $\varTime$, $\varStatement$) to the TTP computing $\procDScriptMwTxId$ to receive the outputs ($\varTx$, $\funStar{\varSpendableCoinAlice}$, $\varWit$).
        \item As in the previous proof, the simulator now has the task to construct a pre-transaction $\funStarAlt{\varPreTx}$ with a partial signature B2 of A, B1, B2.
        The simulator can compute $\varSigBob$ in the same way as we laid out in the previous proof, we still lay it out here again for completeness:
        \begin{enumerate}
            \item $\cnstSimulator$ chooses $(\funStarAlt{\varSecKeyBob}, \funStarAlt{\varNonceBob}) \sample \cnstIntegersPrimeWithoutZero{\varPrime}$
            \item He then computes a temporary $\funStarAlt{\varSigBob} \opFunResult \procSignPrt{\varTx.\varMsg}{\funStarAlt{\varSecKeyBob}}{\funStarAlt{\varNonceBob}}{\varTx.\varSigContext}$
            \item He clones $\varTx$ into $\funStarAlt{\varPreTx}$ and sets $\funStarAlt{\varPreTx}.\varSignature \opAssign \funStarAlt{\varSigBob}$
            \item Now the simulator calls the TTP computing $\procDFinTxId$ with the inputs $\funStarAlt{\varPreTx}$, $\varSecKeyAlice$, $\varNonceAlice$ to receive $\funStarAlt{\varTx}$
            \item Note that the signature in $\funStarAlt{\varTx}$ now contains a signature composed of A + B1 + B2', where B2' is the partial signature computed in step b.
            Therefore now it is possible to recompute the value of the partial signature for B1 as follows:
            \begin{gather*}
                (\funStarAlt{\varS}, \funStarAlt{\varRand}) \opFunResult \funStarAlt{\varTx} \\
                (\varSAlice, \varRandAlice, \varSigContext) \opFunResult \varSigAlice \\
                (\funStarAlt{\varSBob}, \funStarAlt{\varRandBob}, \varSigContext) \opFunResult \funStarAlt{\varSigBob} \\
                {\varSBob}_1 \opAssign \funStarAlt{\varS} \opSub \varSAlice \opSub \funStarAlt{\varSBob} \\
                {\varRandBob}_1 \opAssign \funStarAlt{\varRand} \opAddPoint {\varRandAlice}^{-1} \opAddPoint {\funStarAlt{\varRandBob}}^{-1} \\
                {\varSigBob}_1 \opAssign \{ {\varSBob}_1, {\varRandBob}_1, \varSigContext \}
            \end{gather*}
            \item $\cnstSimulator$ now has the correct values for the signatures A and B1 and can therefore recompute the right value for the partial signature B2 from $\varTx.\varSignature$ with the same calculation as shown in the previous step
        \end{enumerate}
        Note, however, that in this case, $\cnstAdversary$ expects a masked partial signature $\varSigAptBob$ which will verify with the masked partial signature verification routine passing $\varStatement$.
        $\cnstSimulator$ can easily calculate the masked signature as by running $\varSigAptBob \opFunResult \procAptSig{{\varSigBob_1}}{\varWit}$ and constructing $\funStarAlt{\varPreTx}$ by cloning $\varTx$ and setting the signature field to $\varSigAptBob$.
        Finally, $\cnstSimulator$ sends $(\funStarAlt{\varPreTx},\varStatement)$ to $\cnstAdversary$ as if coming from Bob.
        \item When $\cnstAdversary$ calls $\procDAptFinTxId$, $\cnstSimulator$ forwards the inputs to the TTP computing $\procDAptFinTxId$ and returns the TTP outputs to $\cnstAdversary$.
        If the output returned to the adversary was not $\cnstFalsum$, the simulator will send $\varTx$ to $\cnstAdversary$ as if coming from Bob, send $\cnstContinue$ to the TTP computing $\procDScriptMwTxId$, and output whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    In this proof, only $\funStarAlt{\varPreTx}$ and $\varStatement$ sent in Bob's first message to Alice is constructed by $\cnstSimulator$.
    All other values are directly forwarded from a trusted third party and must therefore trivially be indistinguishable from the real execution.
    As $\cnstSimulator$ knows $\varWit$, constructing the real value of $\varStatement$ is simply calculating $\funGen{\varWit}$.
    That $\funStarAlt{\varPreTx}$ is the same as expected in a real execution must hold because the simulator was able to reconstruct the original signature shares from the final signature and by the fact that $\cnstSimulator$ knows $\varWit$ and can therefore call $\procAptSigId$ as given by the protocol specification.

    \textbf{Bob is corrupted}: Again finding a perfect simulator is trivial in this case as there are no messages are sent directly from Alice to Bob, and $\cnstSimulator$ doesn't need to extract any inputs.
    Whenever $\cnstAdversary$ calls one of the trusted third parties to compute a hybrid functionality, $\cnstSimulator$ externally forwards the call to the TTP and returns the result to $\cnstAdversary$.

    We have managed to construct a simulator producing a transcript indistinguishable from a real one both in the case that Alice and Bob are corrupted and controlled by an adversary $\cnstAdversary$. Therefore, we conclude that $\procDScriptMwTxId$ is secure in the $\procDSendCoinsId,\procDAptFinTxId,\procZKfId{\cnstRelation_1}$-model and~\cref{teo:atom:sec-dcontract-mw} must hold.
\end{proof}