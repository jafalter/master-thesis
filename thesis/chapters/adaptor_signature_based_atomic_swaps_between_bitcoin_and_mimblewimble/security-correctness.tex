In this section we will prove the correctness and security of the instantiation described in~\ref{sec:atom:inst}.
We start by proving \emph{Transaction Scheme Correctness}, \emph{Extended Transaction Scheme Correctness} and \emph{Adapted Transaction Scheme Correctness} for the three outlined transaction schemes $\varMWScheme, \varextMWScheme$ and $\varaptMWScheme$.
We then continue by showing that all protocols described in~\ref{sec:atom:protocols} are secure in the malicious models as defined in~\ref{subsec:pre:security}.

\subsection{Correctness} \label{subsec:atom:correctness}

We will argue \emph{Transaction Scheme Correctness} follows from the correctness of the commitment scheme $\varCommitScheme$, two-party signature scheme $\varSigScheme$ as well as the correctness of the range proof system $\varProofSystem$ used in the transaction protocol.
If the transaction was constructed correctly (that is by calling the procedures $\procSendCoinsId, \procRecvCoinsId, \procFinTxId$, the distributed variants $\procDSendCoinsId, \procDRecvCoinsId, \procDFinTxId$ or the adapted ones $\procAptRecvCoinsId, \procDAptFinTxId$ with valid inputs) it must follow that the final transaction has correct commitments, rangeproofs and a valid signature and $\procVerfTxId$ will therefore return 1.
We construct the following theorem:

\begin{theorem}\label{lem:atom:correctness}
    \emph{Transaction Scheme Correctness}, \emph{Extended Transaction Scheme Correctness} or \emph{Adapted Transaction Scheme Correctness} for a transaction system $\varMWSchemeParams{\varCommitScheme}{\varSigScheme}{\varProofSystem}$, $\varextMWSchemeParams{\varCommitScheme}{\varSigScheme}{\varProofSystem}$ or $\varaptMWSchemeParams{\varCommitScheme}{\varSigScheme}{\varProofSystem}$ holds if and only if the underlying Commitment Scheme $\varCommitScheme,$ Two-Party Signature Scheme $\varSigSchemeMP$ and Rangeproof system $\varProofSystem$ are correct.
\end{theorem}

\begin{proof}
    We assume there are two honest participants Alice and Bob, there exists a list of input coins $\funArray{\varCoinInp}$ with blinding factors $\funArray{\varBlindingFactor_i}$ and values $\funArray{\varValue_i}$ wrapped inside a list $\funArray{\varSpendableCoin}$ known to Alice, and some amount $\varFundValue$ which Alice wants to transfer to Bob.
    For \emph{Transaction Scheme Correctness} to hold $\procVerfTx{\varTx}$ must return 1 with overwhealming probability for the two parties creating the transaction $\varTx$ in the following three steps:
    \begin{enumerate}
        \item $(\varPreTx, (\varSecKeyAlice, \varNonceAlice)) \opFunResult \procSendCoins{\funArray{\varSpendableCoin}}{\varFundValue}{\cnstFalsum}$
        \item $\funStar{\varPreTx} \opFunResult \procRecvCoins{\varPreTx}{\varFundValue}$
        \item $\varTx \opFunResult \procFinTx{\funStar{\varPreTx}}{\varSecKeyAlice}{\varNonceAlice}$
    \end{enumerate}
    We recall the conditions for $\procVerfTx{\varTx}$ to return 1 found in~\ref{def:atom:mw-tx-scheme} and show that each of them must hold:

    Condition 1 and 2 both must hold if the participants are honest.
    In the case that the sending party provides duplicate inputs the check at the beginning of the $\procSendCoinsId$ procedure will fail and consequently $\procVerfTx{\varTx}$ will return 0.
    The blinding factors to the ouput coins created in $\procSendCoinsId$ and $\procRecvCoinsId$ are generated randomly, which means a duplication can only appear with negligible probability.

    Condition 3 follows from the implementation of the $\procCreateCoinId$ function called in $\procSendCoinsId$ as well as $\procRecvCoinsId$.
    In the function a rangeproof is computed for the new coin $\varCoin$ with value $\varValue$ and blinding factor $\varBlindingFactor$ as $\varProof \opFunResult \procProof{\varCoin}{\varValue}{\varBlindingFactor}$.
    Given that our Rangeproof system $\varProof$ system has to be correct $\procVerfProof{\varProof}{\varCoin} \opEqNoQ 1$ must hold for all coins created with the $\procCreateCoinId$ routine.
    Therefore Condition 2 must hold if the transaction is computed honestly.

    For condition 4 we must look at how the secret keys $\varSecKeyAlice$ and $\varSecKeyBob$ are constructed.
    From the instantiation of $\procSendCoinsId$ we can see that Alice's share will be $\varSecKeyAlice \opAssign \funStar{\varBlindingFactorAlice} \opSub \cnstSumZeroToN \funArray{\varBlindingFactorAlice}$, where $\funStar{\varBlindingFactorAlice}$ is the blinding factor to her output and $\funArray{\varBlindingFactorAlice}$ are the blinding factors to her input coins.
    Bobs secret key is constructed like $\varSecKeyBob \opAssign \funStar{\varBlindingFactorBob}$, so it corresponds to the blinding factor of his output.
    From the construction of the two-party signature scheme in~\ref{def:sig:two-party-sig} we know that therefore the final signature will be valid under the following public key:
    \[ \funStar{\varPubKey} \opAssign \funGen{\varSecKeyAlice} \opAddPoint \funGen{\varSecKeyBob} \]
    Given how the secret keys are constructed we arrive at:
    \[ \funStar{\varPubKey} \opAssign \funGen{\funStar{\varBlindingFactorAlice}} \opAddPoint \cnstSumZeroToN \funArray{\funGen{- \varBlindingFactorAlice}} \opAddPoint \funGen{\varBlindingFactorBob} \]
    If we can show that the public key $\varPubKey$ computed in $\procVerfTxId$ is the same as above, $\procVerf{\varMsg}{\varSignature}{\varPubKey} \opEqNoQ 1$ must hold and therefore condition 3 would be proven.
    We show this by a stepwise conversion of the initial equation computing $\varPubKey$ until we arrive at the equation for $\funStar{\varPubKey}$:
    \begin{gather}
        \varPubKey \opEqNoQ \funStar{\varPubKey} \\
        \cnstSumZeroToN \varOutputs \opSub \cnstSumZeroToN \varInputs \opEqNoQ \funGen{\funStar{\varBlindingFactorAlice}} \opAddPoint \cnstSumZeroToN \funArray{\funGen{- \varBlindingFactorAlice}} \opAddPoint \funGen{\varBlindingFactorBob} \\
        \varCoinOutAlice \opAddPoint \varCoinOutBob \opAddPoint \cnstSumZeroToN \funArray{(\varCoinInp)^{-1}}  \opEqNoQ\\
        (\funGen{\funStar{\varBlindingFactorAlice}} \opAddPoint \funGenH{\varValue \opSub \varFundValue}) \opAddPoint
        (\funGen{\funStar{\varBlindingFactorBob}} \opAddPoint \funGenH{\varFundValue}) \opAddPoint
        \cnstSumZeroToN \funArray{(\funGen{- \varBlindingFactorAlice}, \funGenH{- \varValue_i})} \opEqNoQ \\
        \funGen{\funStar{\varBlindingFactorAlice}} \opAddPoint \funGen{\funStar{\varBlindingFactorBob}} \opAddPoint \cnstSumZeroToN \funGen{- \varBlindingFactorAlice} \opEqNoQ \funGen{\funStar{\varBlindingFactorAlice}} \opAddPoint \funGen{\funStar{\varBlindingFactorBob}} \opAddPoint \cnstSumZeroToN \funGen{- \varBlindingFactorAlice} \\
        1 \opEqNoQ 1
    \end{gather}
    From step 5.3 to 5.4 we replace every coin $\varCoin$ by its instantiation for a pedersen commitment $\varCoin \opEqNoQ \funGen{\varValue} \opAddPoint \funGenH{\varValue}$.

    From step 5.4 to 5.4 we rely on the fact that if Alice is honest $\varValue \opEqNoQ \cnstSumZeroToN \varValue_i$, therefore also $(\varValue \opSub \varFundValue) \opAddScalar\varFundValue \opEqNoQ \cnstSumZeroToN \varValue_i$ must hold.
    From that we can infer that $\funGenH{\varValue \opSub \varFundValue} \opAddPoint \funGenH{\varFundValue} \opAddPoint \cnstSumZeroToN \funGenH{- \varValue_i}$ must cancel out, otherwise the transaction would either create or burn value, which is not allowed and in which case $\procVerfTxId$ should again return 0.

    We have managed to show that condition 1-4 must hold for a valid transaction and can conclude that \emph{Transaction Scheme Correctness} holds for $\varMWSchemeParams{\varCommitScheme}{\varProofSystem}{\varSigSchemeMP}$.

    We will now argue that the same deriviation holds for \emph{Extended Transaction Scheme Correctness} and \emph{Adapted Transaction Scheme Correctness}.

    Condition 1-2 again follow trivially from the construction of $\procDSendCoinsId$ and $\procDRecvCoinsId$ for the same reasons we have already layed out in the previous proof.

    $\procDSendCoinsId$, $\procDRecvCoinsId$, $\procAptRecvCoinsId$ all rely on the same $\procCreateCoinId$ routine to create output coins, thereby condition 3 also holds for valid transactions with the same argument as for the previous proof.

    In the case of \emph{Extended Transaction Scheme Correctness} the blinding factors for the input coins $\funArray{\varCoinInp}$ are shared.
    However, we can easily reduce this case to the proof for the regular case:
    In $\procDSendCoinsId$ Alice and Carol construct their secret keys as follows:
    \begin{gather}
        \varSecKeyAlice \opAssign \funStar{\varBlindingFactorAlice} \opSub \cnstSumZeroToN \varBlindingFactorAlice \\
        \varSecKeyCarol \opAssign \funStar{\varBlindingFactorCarol} \opSub \cnstSumZeroToN \varBlindingFactorCarol
    \end{gather}
    $\varSecKeyAlice$ and $\varSecKeyCarol$ are then inputs to $\procDFinTxId$ in which a partial signature $\varSigAliceCarol$ is calculated, by both Alice and Carol signing with their secret key.
    Assume the general key from before, in which we have a single secret key $\varSecKeyAlice$.
    We can split $\varSecKeyAlice$ into arbitrarily chosen shares $(\varSecKeyAlice)_1, (\varSecKeyAlice)_2$ with $\varSecKeyAlice \opEqNoQ (\varSecKeyAlice)_1 + (\varSecKeyAlice)_2$.
    By the definition of Two-Party Signatures~\ref{def:sig:two-party-sig} the combined signature from $(\varSecKeyAlice)_1, (\varSecKeyAlice)_2$ will be valid under $\funGen{\varSecKeyAlice}$.
    Thereby we can treat $\varSecKeyAlice$ and $\varSecKeyCarol$ from $\procSendCoinsId$ as arbitrary shares of a combined $\varSecKeyAliceCarol$.
    It follows from the addtive homomorphic property of the elliptic curve that a signature valid under $\funGen{\varSecKeyAliceCarol}$ must also be valid under $\funGen{\varSecKeyAlice} \opAddPoint \funGen{\varSecKeyCarol}$.
    The case of two receivers calling $\procDRecvCoinsId$ is symmetric.
    From this we can conclude that condition 4 must also hold for the \emph{Extended Transaction Scheme}. \\
    Now for the \emph{Adapted Extended Transaction Scheme} the same argument holds.
    The only difference in this scheme is that in $\procDAptFinTxId$ Bob (instead of Alice) will call $\procFinSigId$, as only he knows his unadapted partial signature $\varSigBob$.
    However, the construction of the signature remains unchanged, therefore the reduction we provided before must hold for the same reasons.

    We have thereby proven that if $\varCommitScheme, \varProofSystem, \varSigSchemeMP$ are correct and the participants behave honestly (that is by providing valid inputs and calling the respective routines in the given order) $\procVerfTx{\varTx}$ will return 1 for the resulting transaction $\varTx$ and therefore theorem~\ref{lem:atom:correctness} holds.
\end{proof}

\subsection{Security}\label{subsec:atom:security}

We now want to prove security in the malicious setting as defined in~\ref{subsec:pre:security} for the protocols defined in~\ref{sec:atom:protocols}.
Again we show that the distributed protocols are secure in the hybrid $\procZKfId{\cnstRelation}$-model as already explained in~\ref{subsec:sig:secureaptscheme}.
We start by proving security of the simple transaction protocol $\procDBuildMwTxId$.

\textbf{Hybrid functionalities}: The parties have access to a trusted third party computing the zero-knowledge proof of knowledge functionalities $\procZKfId{\cnstRelation_1}$, $\procZKfId{\cnstRelation_2}$ and $\procZKfId{\cnstRelation_2*}$.
$\cnstRelation_1$ is the relation between a secret key $\varSecKey$ and its public key $\varPubKey \opEqNoQ \funGen{\varSecKey}$ for the elliptic curve generator point $\varG$.
$\cnstRelation_2$ is the relation between two secret inputs $\varBlindingFactor, \varValue$ and its pedersen commitment $\varCommitment \opEqNoQ \funGen{\varBlindingFactor} \opAddPoint \funGenH{\varValue}$ for two adjacent generators $\varG, \varH$ as defined in~\ref{def:pre:pedersen}.
We shorten the call by the prover to just provide $\varSpendableCoin$ because it is a wrapper that contains the coin commitment, as well as its openings.
$\cnstRelation_2*$ is the same as $\cnstRelation_2$ just for a list of secrets inputs $\funArray{(\varBlindingFactor, \varValue)}$ and its list of commitments $\funArray{\varCommitment}$.
Again to shorten the calls by the prover we simplify the call to $\procZkf{\cnstRelation_2*}{\funArray{\varSpendableCoin}}$.

\textbf{Proof Idea}: We extend the protocol $\procDBuildMwTxId$ instantiated in section~\ref{sec:atom:protocols} with the following calls to the zero-knowledge proof of knowledge functionalities:

\fbox{
\begin{varwidth}{\textwidth}
    \procedure[linenumbering,skipfirstln]{$\procDBuildMwTx{\funArray{\varSpendableCoin}}{\varFundValue}{\varTime}$}{
    Alice \< \< Bob \\
    \procZkf{\cnstRelation_2*}{\funArray{\varSpendableCoin}} \\
    (\varPreTx, \funStar{\varSpendableCoinAlice}, (\varSecKeyAlice, \varNonceAlice)) \\ \opFunResult \procSendCoins{\funArray{\varSpendableCoin}}{\varFundValue}{\varTime} \\
    \procZkf{\cnstRelation_1}{(\varSecKeyAlice, \funGen{\varSecKeyAlice})} \\
    \procZkf{\cnstRelation_1}{(\varNonceAlice, \funGen{\varNonceAlice})} \\
    \procZkf{\cnstRelation_2}{\funStar{\varSpendableCoinAlice}} \\
    \< \sendmessageright*{\varPreTx} \< \\
    \< \< \pcif \procZkf{\cnstRelation_2*}{\varTx.\varInputs} \opEqNoQ 0 \\
    \< \< \t \pcreturn \cnstFalsum \\
    \< \< \pcif \procZkf{\cnstRelation_1}{\varTx.\varSigContext.\varPubKey} \opEqNoQ 0 \\
    \< \< \t \pcreturn \cnstFalsum \\
    \< \< \pcif \procZkf{\cnstRelation_1}{\varTx.\varSigContext.\varRand} \opEqNoQ 0 \\
    \< \< \t \pcreturn \cnstFalsum \\
    \< \< \pcif \procZkf{\cnstRelation_2}{\varTx.\varOutputs[0]} \opEqNoQ 0 \\
    \< \< \t \pcreturn \cnstFalsum \\
    \< \< (\funStarAlt{\varPreTx}, \funStar{\varSpendableCoinBob}) \opFunResult \procRecvCoins{\varPreTx}{\varFundValue} \\
    \< \< \procZkf{\cnstRelation_2}{\funStar{\varSpendableCoinBob}} \\
    \< \sendmessageleft*{\funStarAlt{\varPreTx}} \\
    \pcif \procZkf{\cnstRelation_2}{\varTx.\varOutputs[1]} \opEqNoQ 0 \\
    \t \pcreturn \cnstFalsum \\
    \varTx \opFunResult \procFinTx{\funStarAlt{\varPreTx}}{\varSecKeyAlice}{\varNonceAlice} \\
    \< \sendmessageright*{\varTx} \\
    \pcreturn (\varTx, \funStar{\varSpendableCoinAlice}) \< \< \pcreturn (\varTx, \funStar{\varSpendableCoinBob})
    }
\end{varwidth}
}

\begin{theorem} \label{theo:atom:sec-tx}
    Let $\varCommitScheme$ be a correct and secure pedersen commitment scheme, $\varProofSystem$ be a correct and secure rangeproof system and $\varSigSchemeMP$ be a secure and correct two-party signature scheme, then $\procDBuildMwTxId$ securly computes a Mimblewimble transaction transfering the value $\varFundValue$ from a sender (denoted as Alice) to a receiver (denoted as Bob) in the hybrid $\procZKfId{\cnstRelation_1}, \procZKfId{\cnstRelation_2}$-model.
\end{theorem}

\begin{proof}
    We proof the security of $\procDBuildMwTxId$ by constructing a simulator $\cnstSimulator$ with access to a TTP computing the protocol in the ideal setting upon receiving the inputs from the participants.
    For this the simulator has to extract the inputs used by the adversary.
    The TTP returns the outputs $(\varTx, \funStar{\varSpendableCoinAlice})$ (resp. $(\varTx, \funStar{\varSpendableCoinBob})$) from which he has to construct a transcript that is indistinguishable from the protcol transcript in the real world. The simulator uses the calls to $\procZKfId{\cnstRelation_1}, \procZKfId{\cnstRelation_2}, \procZKfId{\cnstRelation_2*}$ to achieve this.
    We proof that the transcript is indistinguishable in the cases that either Alice or Bob is corrupt and controlled by a deterministic polynomial adversary $\cnstAdversary$.

    \textbf{Alice is corrupt}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and once it calls $\procZKfId{\cnstRelation_2*}, \procZKfId{\cnstRelation_1}$ $\procZKfId{\cnstRelation_2}$ saves the values $\funArray{\varSpendableCoin}, \varSecKeyAlice, \varNonceAlice, \funStar{\varSpendableCoinAlice}$ to its memory.
        \item $\cnstSimulator$ calculates the transaction value $\varFundValue$ as follows:
        \begin{gather*}
            \varValue \opEqNoQ \sum_{\varI \opAssign 0}^{\varI \opSm \varN}(\varSpendableCoin_i.\varValue) \\
            \varFundValue \opEqNoQ \varValue \opSub \funStar{\varSpendableCoinAlice}.\varValue
        \end{gather*}
        \item $\cnstSimulator$ receives $\varPreTx$ from $\cnstAdversary$ and checks for every transaction input $\varI$ if $\varPreTx.\varInputs[\varI] \opEqNoQ \varSpendableCoin[\varI].\varCoin$, and that $\varTx.\varOutputs \opEqNoQ \funArray{\funStar{\varSpendableCoinAlice}.\varCoin}$.
        He also compares $\varTx.\varSigContext.\varPubKey \opEqNoQ \funGen{\varSecKeyAlice}$, $\varTx.\varSigContext.\varRand \opEqNoQ \funGen{\varNonceAlice}$, $\varTx.\varProof[0] \opEqNoQ \funStar{\varSpendableCoinAlice}.\varProof$ and $\varTx.\varCommits[0] \opEqNoQ \funGen{\varSecKeyAlice}$.
        If any of the equalities were invalid $\cnstSimulator$ sends $\cnstAbort$ to the TTP computing $\procDBuildMwTxId$ and returns $\cnstFalsum$.
        Otherwise he extracts $\varTime \opEqNoQ \varTx.\varTime$ and sends the inputs $(\funArray{\varSpendableCoin}, \varFundValue, \varTime)$ to the TTP and receives back the outputs $(\varTx, \funStar{\varSpendableCoinAlice})$.
        \item The simulators task is it now to construct $\funStarAlt{\varPreTx}$ which he can achieve in the following steps:
        \begin{enumerate}
            \item He takes the signature context $\varSigContext$ and final signature $\varSigFin$ from the final transaction $\varSigContext \opEqNoQ \varTx.\varSigContext$ and $\varSigFin \opEqNoQ \varTx.\varSignature$.
            \item He computes the adversaries partial signature as $\varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}$
            \item He further computes
            \begin{gather*}
                \varPubKey \opFunResult \varSigContext.\varPubKey \\
                \varPubKeyAlice \opEqNoQ \funGen{\varSecKeyAlice} \\
                (\varSAlice, \varRandAlice, \varSigContext) \opFunResult \varSigAlice \\
                (\varS, \varRand) \opFunResult \varSigFin \\
                \varSBob \opEqNoQ \varS \opSub \varSAlice \\
                \varRandBob \opEqNoQ \varRand \opAddPoint \varRandAlice^{-1} \\
                \varPubKeyBob \opEqNoQ \varPubKey \opAddPoint \varPubKeyAlice^{-1} \\
                \varSigBob \opEqNoQ (\varSBob, \varRandBob, \varSigContext)
            \end{gather*}
            \item He takes further values from the final transaction:
            \begin{gather*}
                \varCoinOutBob \opEqNoQ \varTx.\varOutputs[1] \\
                \varProofBob \opEqNoQ \varTx.\varProof[1] \\
                \varCommitment_\varBob \opEqNoQ \varTx.\varCommits[1]
            \end{gather*}
            \item Now he can compute $\funStarAlt{\varPreTx} \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs \opConc \varCoinOutBob}{\varProofs \opConc \varProofBob}{\varSigContext}{\varCommits \opConc \varCommitment_\varBob}{\varSigBob}{\varTime}$
        \end{enumerate}
        Finally $\cnstSimulator$ will send $\funStarAlt{\varPreTx}$ as if coming from Bob and sends $\cnstContinue$ to the TTP.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_2}$ he checks equality to $\varCoinOutBob$ and returns either 0 or 1.
        \item Eventually $\cnstAdversary$ will send a $\funStarAlt{\varTx}$ after which the simulator will output whatever $\cnstAdversary$ outputs.
    \end{enumerate}
    Next we need to proof that the transcript produced by $\cnstSimulator$ is indistinguishable from a real one in every phase of the protocol.
    We separate between the following three phases:
    \textbf{Phase 1}: Alice sends her input coins, signing key and nonce as well as her change output coin to $\procZKfId{\cnstRelation_1}$ and $\procZKfId{\cnstRelation_2}$ and sends the pre-transaction $\varPreTx$ to Bob.
    \textbf{Phase 2}: Bob calls $\procZKfId{\cnstRelation_1}$ and $\procZKfId{\cnstRelation_2}$ as the verifier, after which he calls $\procZKfId{\cnstRelation_2}$ as the prover and proceeds by sending the updated pre-transaction $\funStarAlt{\varPreTx}$ to Alice.
    \textbf{Phase 3}: Alice calls $\procZKfId{\cnstRelation_2}$ as the verifier and sends back the final transaction $\varTx$ to Bob which they then both output.

    \begin{itemize}
        \item \textit{Phase 1}: Due to the deterministic nature of $\cnstAdversary$ we can conclude that this phase has to be indistinguishable as there is not yet any simulation required.
        \item \textit{Phase 2}: If any of the values that $\cnstAdversary$ send to the trusted party computing the zero-knowledge proofs of knowledge are different from the value that $\cnstAdversary$ sends in the pre-transaction the equality checks done by $\cnstSimulator$ will fail in which case he will output $\cnstFalsum$ which is identical to what happens in the real execution.
        We further argue that the updated pre-transaction $\funStarAlt{\varPreTx}$ is identical to the one send in the real execution by Bob.
        The signatures $\varSigAlice$ and $\varSigBob$ have to add up to $\varSigFin$ which is the final signature.
        $\cnstSimulator$ can read $\varSigFin$ from the transaction in the output he received from the TTP, he can further calculate the adversaries signature because he knows their signing secrets.
        From those two values he can then compute the value that $\varSigBob$ must have such that it will complete to $\varSigFin$ when added to Alice's part of the signature.
        All further values $\cnstSimulator$ needs to build $\funStarAlt{\varPreTx}$ he can simply read from the final transaction $\varTx$.
        Therefore $\funStarAlt{\varPreTx}$ is identical to the one sent in the real execution.
        \item \textit{Phase 3}: When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_2}$ as the verifier, $\cnstSimulator$ can simply check equality with the correct value and return 0 or 1, which is identical to the real execution.
    \end{itemize}

    We have managed to show that in the case that Alice is corrupted the simulation is perfect, because the transcript is in fact identical to the transcript of the real execution.

    \textbf{Bob is corrupt}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ computes one (or multiple) input coins as follows:
        \begin{gather*}
            \varBlindingFactor, \varValue \sample \cnstIntegersPrimeWithoutZero{*} \\
            \varSpendableCoin \opFunResult \procCreateCoin{\varBlindingFactor}{\varValue}
        \end{gather*}
        He chooses $\varFundValue$ randomly and sets $\varTime \opEqNoQ \cnstFalsum$.
        Now he can call $\procSendCoinsId$ and get:
        \[ (\varPreTx, \funStar{\varSpendableCoinAlice}, (\varSecKeyAlice, \varNonceAlice)) \opFunResult \procSendCoins{\funArray{\varSpendableCoin}}{\varFundValue}{\varTime} \]
        \item The simulator invokes $\cnstAdversary$ and sends $\varPreTx$ as if coming from Alice.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_1},\procZKfId{\cnstRelation_2}$ as the verifier $\cnstSimulator$ simply checks equality we the values he sent and returns either 0 or 1.
        The adversary proceeds by calling $\procZkf{\cnstRelation_2}{\funStar{\varSpendableCoinBob}}$, $\cnstSimulator$ saves $\funStar{\varSpendableCoinBob}$ and extracts $\varFundValue \opEqNoQ \funStar{\varSpendableCoinBob}.\varValue$
        He then calls the TTP computing $\procDBuildMwTxId$ with the input $\varFundValue$ and receives $(\varTx, \funStar{\varSpendableCoinBob})$.
        \item Next $\cnstAdversary$ sends an updated pre-transaction $\funStarAlt{\varPreTx}$.
        $\cnstSimulator$ verifies the output coin added by $\cnstAdversary$ matches with $\funStar{\varSpendableCoinBob}$, if it does not he sends $\cnstAbort$ to the TTP and outputs $\cnstFalsum$.
        Otherwise $\cnstSimulator$ computes the following values from the signature context $\varSigContext$ provided in the final transaction and $\funStarAlt{\varSigContext}$ provided by $\cnstAdversary$:
        \begin{gather*}
            \varPubKeyBob \opEqNoQ \funStarAlt{\varSigContext}.\varPubKey \opAddPoint {\funGen{\varSecKeyAlice}}^{-1} \\
            \varRandBob \opEqNoQ \funStarAlt{\varSigContext}.\varRand \opAddPoint {\funGen{\varNonceAlice}}^{-1} \\
            \varPubKeyAlice \opEqNoQ \varSigContext.\varPubKey \opAddPoint \varPubKeyBob^{-1} \\
            \varRandAlice \opEqNoQ \varSigContext.\varRand \opAddPoint \varRandBob^{-1}
        \end{gather*}
        \item Next the simulator rewinds to the first step of the simulation but instead of choosing the values for the pre-transacion now he uses $\varTx.\varInputs$ as the pre-transaction input values, $\varTx.\varOutputs[0]$ as the single output value, $\varTx.\varProofs[0]$ as the single rangeproof value and $\varTx.\varCommits[0]$ as the single value in the commitment field.
        Furthermore he constructs the initial signature context as:
        \begin{gather*}
            \varSigContext \opAssign \{ \varPubKey \opEqNoQ 1, \varRand \opEqNoQ 1 \} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyAlice}{\varRandAlice}
        \end{gather*}
        And again sends the pre-transaction to $\cnstAdversary$ as if coming from Alice.
        \item The simulator repeats the steps until step 5. where he rewinded earlier, now instead of rewinding $\cnstSimulator$ sends $\cnstContinue$ to the TTP and sends $\varTx$ as if coming from Alice, and finally outputs whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    Again we now claim that the simulation is indistinguishable from a real execution in all three phases.
    Note that due to the rewinding step we need to consider both the message sent before and after the rewind.

    \begin{itemize}
        \item \textit{Phase 1:} In the first iteration the simulator constructs the input values $\funArray{\varSpendableCoin}$ from random values and also chooses a random transaction value $\varFundValue$.
        $\cnstSimulator$ constructs the pre-transaction using those chosen value rather than the real ones.
        We claim that the adversary cannot distinguish the chosen from the real coin commitments (Except with neglible probability).
        If we assume that he would be able to do so, that means he could distinguish for two pedersen commitments $\varCommitment_1 \opEqNoQ \funGen{\varBlindingFactor_1} \opAddPoint \funGenH{\varValue}, \varCommitment_2 \opEqNoQ \funGen{\varBlindingFactor_2} \opAddPoint \funGenH{\funStarAlt{\varValue}}$ which one commits to $\varValue$, from which follows that he could break the hiding property of perdersen commitments.
        Not being able to extract the coin values, the adversary has no chance of knowing if they are correct at this point.
        For the same reasons the pre-transaction sent by $\cnstSimulator$ after the rewind will be indistinguishable from a real one.
            However, as this time the pre-transaction is constructed from the real $\varTx$ which $\cnstSimulator$ received from the TTP, the pre-transaction is in fact identical to the pre-transaction sent in the real execution.
        The calls to $\procZKfId{\cnstRelation_1}$ and $\procZKfId{\cnstRelation_2}$ also behave identically to the real execution in which the parties have access to a TTP computing those protocols.
        \item \textit{Phase 2:} This phase will be identical to the real execution due to the fact that the adversary is deterministic.
        \item \textit{Phase 3:} The transaction sent to $\cnstAdversary$ in this phase is the one received from the TTP and is therefore identical to what would have been sent in the real execution, given $\cnstAdversary$ sends correct values. (Otherwise the execution would have halted with $\cnstFalsum$).
        We like to emphasize that in the case that we wouldn't have done the rewind step, $\cnstAdversary$ would be able to distinguish the transcript from the real one because he can identify differences in the inputs, outputs, proofs and commitment, as well as the signature context of the final transaction $\varTx$ and the pre-transaction $\varPreTx$ sent in the first phase.
        For instance inputs which are spend in the final transaction are not present in the pre-transaction.
        However, due to the rewinding step $\cnstSimulator$ manages to construct the correct pre-transaction which will finalize into $\varTx$ such that $\cnstAdversary$ again has no chance of distinguishing the two transcripts.
    \end{itemize}

    We have manged to show that the transcripts produced by $\cnstSimulator$ in the case that Alice and in the case that Bob is corrupt are indistinguishable from the transcript of a real execution and can therefore conclude that the protocol is secure and theorem~\ref{theo:atom:sec-tx} holds.

\end{proof}

Before we can continue to proof the security of the three other protocols $\procDSharedInpMwTxId$, $\procDSharedOutputMwTxId$, $\procDScriptMwTxId$ we first have to proof that all the protocols which are run as part of those executions are secure too.
That is we have to show security for $\procDSendCoinsId$, $\procDRecvCoinsId$, $\procDFinTxId$, $\procDAptFinTxId$.

We start with the proof for $\procDSendCoinsId$ which is called inside $\procDSharedInpMwTxId$ as well as $\procDScriptMwTxId$.

\textbf{Hybrid functionalities}: For this proof we need to extend our hybrid model.
As previously the parties have access to a trusted third party computing the zero-knowledge proof of knowledge functionalities $\procZKfId{\cnstRelation_1}, \procZKfId{\cnstRelation_2}$ and $\procZKfId{\cnstRelation_2*}$.
Additionally we introduce $\procZKfId{\cnstRelation_3}$, whereas $\cnstRelation_3$ is the relation between a value $\varValue$, two secrets $\varBlindingFactorAlice, \varBlindingFactorCarol$ and the commitment $\varCoin \opEqNoQ \funGenH{\varValue} \opAddPoint \funGen{\varBlindingFactorAlice} \opAddPoint \funGen{\varBlindingFactorCarol}$.
This means that for $\cnstRelation_3$ we have two provers, one of them having to provide $\varBlindingFactorAlice$, the other $\varBlindingFactorCarol$.
Both will have to provide the commitment $\varCoin$ and the value $\varValue$.
Both parties can then call the protocol again as the verifier providing the commitment $\funStar{\varCoin}$ and receiving 1 if $\funStar{\varCoin} \opEqNoQ \varCoin_\varAlice \opEqNoQ \varCoin_\varCarol$ (whereas $\varCoin_\varAlice$ is the commitment received from Bob as the prover, resp. for Carol) $\varValue_\varAlice \opEqNoQ \varValue_\varCarol$ and $\funStar{\varCoin} \opEqNoQ \funGenH{\varValue_{\cdot}} \opAddPoint \funGen{\varBlindingFactorAlice} \opAddPoint \funGen{\varBlindingFactorCarol}$.
To simplify the call made by the prover we just write $\procZkf{\cnstRelation_3}{\varPtSpendableCoin}$ as $\varPtSpendableCoin$ is like $\varSpendableCoin$ a wrapper around $\varCoin$, $\varBlindingFactor$, $\varValue$.
As for $\cnstRelation_2$ we again allow to call the protocol with an array of inputs by calling $\procZKfId{\cnstRelation_{3*}}$

\textbf{Proof Idea}: We extend the protocol $\procDSendCoinsId$ instantiated in~\ref{sec:atom:inst} with the following calls to the zero-knowledge proof of knowledge functionalities:

\fbox{
\begin{varwidth}{\textwidth}
    \procedure[linenumbering,skipfirstln]{$\procDSendCoins{\funArray{\varPtSpendableCoinAlice}}{\funArray{\varPtSpendableCoinCarol}}{\varFundValue}{\varTime}$}{
    Alice \< \< Carol \\
    \procZkf{\cnstRelation_{3*}}{\funArray{\varPtSpendableCoinAlice}} \< \< \procZkf{\cnstRelation_{3*}}{\funArray{\varPtSpendableCoinCarol}} \\
    \cdots \\
    \procZkf{\cnstRelation_2}{\funStar{\varSpendableCoinAlice}} \\
    \procZkf{\cnstRelation_1}{(\varSecKeyAlice, \funGen{\varSecKeyAlice})} \\
    \procZkf{\cnstRelation_1}{(\varNonceAlice, \funGen{\varNonceAlice})} \\
    \< \sendmessageright*{\varPreTx} \< \\
    \< \< \pcif \procZkf{\cnstRelation_{3*}}{\varPreTx.\varInputs} \opEqNoQ 0 \\
    \< \< \t \pcreturn \cnstFalsum \\
    \< \< \procZkf{\cnstRelation_2}{\varPreTx.\varOutputs[0]} \opEqNoQ 0 \\
    \< \< \t \pcreturn \cnstFalsum \\
    \< \< \pcif \procZkf{\cnstRelation_1}{\varSigContext.\varPubKey} \opEqNoQ 0 \\
    \< \< \t \pcreturn \cnstFalsum \\
    \< \< \pcif \procZkf{\cnstRelation_1}{\varSigContext.\varRand} \opEqNoQ 0 \\
    \< \< \t \pcreturn \cnstFalsum \\
    \< \< \cdots \\
    \< \< \procZkf{\cnstRelation_2}{\funStar{\varSpendableCoinCarol}} \\
    \< \< \procZkf{\cnstRelation_1}{(\varSecKeyCarol, \funGen{\varSecKeyCarol})} \\
    \< \< \procZkf{\cnstRelation_1}{(\varNonceCarol, \funGen{\varNonceCarol})} \\
    \< \sendmessageleft*{\funStarAlt{\varPreTx}} \< \\
    \pcif \procZkf{\cnstRelation_{3*}}{\funStarAlt{\varPreTx}.\varInputs} \opEqNoQ 0 \\
    \t \pcreturn \cnstFalsum \\
    \pcif \procZkf{\cnstRelation_2}{\funStarAlt{\varPreTx}.\varOutputs[1]} \opEqNoQ 0 \\
    \t \pcreturn \cnstFalsum \\
    \{ \varPubKey, \varRand \} \opFunResult \funStarAlt{\varPreTx}.\varSigContext \\
    \pcif \procZkf{\cnstRelation_1}{\varPubKey \opAddPoint \varPubKeyAlice^{-1}} \opEqNoQ 0 \\
    \t \pcreturn \cnstFalsum \\
    \pcif \procZkf{\cnstRelation_1}{\varRand \opAddPoint \varRandAlice^{-1}} \opEqNoQ 0 \\
    \t \pcreturn \cnstFalsum \\
    \pcreturn (\funStarAlt{\varPreTx}, \funStar{\varSpendableCoinAlice}, (\varSecKeyAlice, \varNonceAlice)) \< \< \pcreturn (\funStarAlt{\varPreTx}, \funStar{\varSpendableCoinCarol}, (\varSecKeyCarol, \varNonceCarol))
    }
\end{varwidth}
}

\begin{theorem} \label{teo:atom:sec-dspend}
    Let $\varCommitScheme$ be a correct and secure pedersen commitment scheme, $\varProofSystem$ be a correct and secure range proof system and $\varSigSchemeMP$ be a secure and correct two-party signature scheme, then $\procDSendCoinsId$ securely computes a mimblewimble pre-transaction $\funStarAlt{\varPreTx}$ spending a coin $\varCoinShared$ owned by the two parties in the hybrid $\procZKfId{\cnstRelation_1}$,$\procZKfId{\cnstRelation_2}$,$\procZKfId{\cnstRelation_3}$-model.
\end{theorem}

\begin{proof}
    Again we proof security by constructing a simulator $\cnstSimulator$ with access to a trusted third party (TTP) computing $\procDSendCoinsId$ in the ideal setting upon receiving inputs from the two parties.
    The simulators task is to extract the inputs of the adversary $\cnstAdversary$, send the inputs to the TTP and construct a protocol transcript indistinguishable from a real one.
    We separately look at the case in which Alice is corrupted and the case the Carol is corrupted.

    \textbf{Alice is corrupt}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and saves $\funArray{\varPtSpendableCoinAlice}$, $\funStar{\varSpendableCoinAlice}$, $\varSecKeyAlice$, $\varNonceAlice$ when he calls $\procZKfId{\cnstRelation_{1,2,3}}$
        \item The simulator then receives $\varPreTx$ from $\cnstAdversary$ and compares the input coins, output coin and proof, signature context value with what he has stored in the first step.
        If any of those are not equal $\cnstSimulator$ sends $\cnstAbort$ to the TTP and outputs $\cnstFalsum$.
        Otherwise he extracts $\varFundValue \opAssign \sum \funArray{\varPtSpendableCoinAlice.\varValue} \opSub \funStar{\varSpendableCoinAlice}.\varValue$ as well as $\varTime \opAssign \varPreTx.\varTime$ and sends the inputs $(\funArray{\varPtSpendableCoinAlice}, \varFundValue, \varTime)$ to the TTP and receives the outputs $(\funStarAlt{\varPreTx}, \funStar{\varSpendableCoinAlice}, (\varSecKeyAlice, \varNonceAlice))$.
        \item $\cnstSimulator$ sends $\funStarAlt{\varPreTx}$ to $\cnstAdversary$ as if coming from Carol and sends $\cnstContinue$ to the TTP to make $\cnstAdversary$ receive the outputs in the ideal setting.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_{1,2,3}}$ as the verifier he compares the values to what he has sent in $\funStarAlt{\varPreTx}$ and returns either 0 or 1.
        \item Finally the simulator outputs whatever $\cnstAdversary$ outputs.
    \end{enumerate}
    We separate between the following three phases:
    \textbf{Phase 1}: Alice sends her partially owned inputs coins, newly created output coins, as well as her signing secrets to $\procZKfId{\cnstRelation_{1,2,3}}$ and sends $\varPreTx$.
    Carol sends her partiall owned input coins to $\procZKfId{\cnstRelation{3}}$
    \textbf{Phase 2}: Carol calls $\cnstRelation_{1,2,3}$ as the verifier constructs her output coin and signing secrets, now calls $\cnstRelation_{1,2}$ as the prover and sends the updated $\funStarAlt{\varPreTx}$ to Alice.
    \textbf{Phase 3}: Alice calls $\cnstRelation_{1,2,3}$ as the verifier

    We now argue why each phase is indistinguishable from a real execution in the case that Alice is corrupted.

    \begin{itemize}
        \item \textit{Phase 1}: No simulation is required in this phase, we therefore conclude that is indistinguishable from a real execution due to the deterministic nature of $\cnstAdversary$.
        \item \textit{Phase 2}: If $\cnstAdversary$ tried to cheat by providing invalid values in $\varPreTx$ the equalities that $\cnstSimulator$ checks will fail and will lead to a $\cnstFalsum$ output which is identically to what would happen in a real execution.
        $\cnstSimulator$ then sends $\funStarAlt{\varPreTx}$ to $\cnstAdversary$ which he received from the TTP and therefore has to be identical to the real execution, as Carol as the honest party must always provide exactly this message.
        \item \textit{Phase 3}: Again if $\cnstAdversary$ tries to cheat by sending an invalid value, he will receive a 0 bit, which would also happen in the real execution.
    \end{itemize}

    As the transcript is identical to a transcript of a real protocol execution we conclude that the simulation is perfect.

    \textbf{Carol is corrupt}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and saves $\funArray{\varPtSpendableCoinCarol}$ when the adversary calls $\procZKfId{\cnstRelation_{3*}}$
        \item The simulator then chooses $\varBlindingFactorAlice, \funStar{\varBlindingFactorAlice}, \varFundValue \sample \cnstIntegersPrimeWithoutZero{*}$ and computes $\varPtSpendableCoinAlice \opAssign {\varCoin \opAssign \varPtSpendableCoinCarol.\varCoin, \varBlindingFactor \opAssign \varBlindingFactorAlice, \varValue \opAssign \varPtSpendableCoinCarol.\varValue}$.
        He then proceeds by building $\varPreTx$ as given by the protocol definition with the choosen values and $\funArray{\varPtSpendableCoinAlice}$ and sends it to $\cnstAdversary$ as if coming from Alice.
        \item When Carol calls $\procZKfId{\cnstRelation_{1,2,3}}$ as the verifier $\cnstSimulator$ checks the passed values for equality and returns either 0 or 1.
        As soon as Carol calls $\procZkpProve{\cnstRelation_{2}}{\varSpendableCoinCarol}$ $\cnstSimulator$ will extract $\varFundValue \funStar{\varSpendableCoinCarol}.\varValue$ and finally calls the TTP with inputs $(\funArray{\varPtSpendableCoinCarol}, \varFundValue)$ to receive $\funStarAlt{\varPreTx}, \funStar{\varSpendableCoinCarol}, (\varSecKeyCarol, \varNonceCarol)$.
        \item Now the simulator rewinds to step 1 and constructs the actual $\varPreTx$ from $\funStarAlt{\varPreTx}$ as follows:
        \begin{gather*}
            \{ \varMsg, \varInputs, \varOutputs, \varProofs, \varSigContext, \varCommits, \cnstEmptySet, \varTime \} \opFunResult \funStarAlt{\varPreTx} \\
            \varPubKeyAlice \opAssign \funStarAlt{\varPreTx}.\varSigContext.\varPubKey \opAddPoint {\funGen{\varSecKeyCarol}}^{-1} \\
            \varRandAlice \opAssign \funStarAlt{\varPreTx}.\varSigContext.\varRand \opAddPoint {\funGen{\varNonceCarol}}^{-1} \\
            \funStar{\varSigContext} \opAssign \{ \varPubKey \opAssign \varPubKeyAlice, \varRand \opAssign \varRandAlice \}
            \varPreTx \opAssign \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs[0]}{\varProofs[0]}{\funStar{\varSigContext}}{\varCommits[0]}{\cnstEmptySet}{\varTime}
        \end{gather*}
        he then sends again $\varPreTx$ Carol and continues as before
        \item When $\cnstAdversary$ sends $\funStarAlt{\varPreTx}$ he compares its inputs, outputs, proofs and signature context to $\funStarAlt{\varPreTx}$ received from the trusted third party and outputs $\cnstFalsum$ and sends $\cnstAbort$ to the TTP if any do not match.
        Otherwise he sends $\cnstContinue$ to the TTP and outputs whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    We again show that in each phase the transcript produced by the simulator is computationally indistinguishable from a real transcript.

    \begin{itemize}
        \item \textit{Phase 1}: In the first iteration (before the rewind) the pre-transaction that is send to $\cnstAdversary$ will be constructed from randomly chosen values except for the transaction inputs which are given by the commitments in $\funArray{\varPtSpendableCoinCarol}$.
        Due to the hiding property of the pedersen commitment the adversary cannot determine if the correct value $\varFundValue$ has been used to construct the output coin, even though he in fact knows the correct value for $\varFundValue$, but does not know the blinding factor $\funStar{\varBlindingFactorAlice}$.
        $\cnstAdversary$ does know the correct values for the input coins from $\funArray{\varPtSpendableCoinCarol}$ thereby it is critical that $\cnstSimulator$ uses the commitments extracted from $\funArray{\varPtSpendableCoinCarol}$ to build the transaction.
        Otherwise the simulation could be detected.
        In the second iteration (after the rewind) $\cnstSimulator$ sends the same $\varPreTx$ which would be sent in a real execution which is therefore identical.
        \item \textit{Phase 2}: When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_{1,2,3}}$ he will receive 0 or 1 identically to the real execution.
        \item \textit{Phase 3}: If $\cnstAdversary$ sends invalid input, output, proof or context values is the final pre-transaction $\funStarAlt{\varPreTx}$ the simulator detects this and ouputs $\cnstFalsum$, otherwise the protocol concludes, which is the same that would happen in the real exeuction.
    \end{itemize}

    We have managed to show that the simulator $\cnstSimulator$ can produce an indistinguishable transcript both in the case that Alice and that Carol is corrupted and can thereby conclude that $\procDSendCoinsId$ is secure in the $\procZKfId{\cnstRelation_1}$,$\procZKfId{\cnstRelation_2}$,$\procZKfId{\cnstRelation_3}$-model and theorem~\ref{teo:atom:sec-dspend} holds.
\end{proof}

We continue by proofing security of the $\procDRecvCoinsId$ which is called inside the $\procDSharedOutputMwTxId$ protocol.

\textbf{Hybrid functionalities}: Again the parties have access to a trusted third party computing the zero-knowledge proof of knowledge functionalities $\procZKfId{\cnstRelation_1}$, $\procZKfId{\cnstRelation_2}$ and $\procZKfId{\cnstRelation_2*}$.
For this proof we do not need $\cnstRelation_3$ as defined in the previous proof, however we extend the model with two further protocols which have already been proven secure.
We extend our model by including the $\procDSignId$ protocol for which security has been proven in section~\ref{sec:sig:two-party-apt-security} and the $\procDRProofId$ for which a secure protocol can be found in~\cite{klinec2020privacy}

\textbf{Proof idea}: We extend the protocol $\procDRecvCoinsId$ instantiated in~\ref{sec:atom:inst} with the following calls to the zero-knowledge proof of knowledge functionalities:

\fbox{
\begin{varwidth}{\textwidth}
    \procedure[linenumbering,skipfirstln]{$\procDRecvCoins{\varPreTx}{\varFundValue}$} {
    Bob \< \< \< \< Carol \\
    \cdots \\
    \procZkf{\cnstRelation_2}{(\varCoinShared, (\varFundValue, \funStar{\varBlindingFactorBob}))} \\
    \< \sendmessageright*{\varPreTx, \varCoinShared} \< \\
    \< \< \< \< \pcif \procZkf{\cnstRelation_2}{\varCoinShared} \opEqNoQ 0 \\
    \< \< \< \< \t \pcreturn \cnstFalsum \\
    \< \< \< \< \cdots \\
    \< \< \< \< \procZkf{\cnstRelation_1}{(\varSecKeyCarol, \funGen{\varSecKeyCarol})} \\
    \< \sendmessageleft*{\funStarAlt{\varPreTx}, \funGen{\varSecKeyCarol}} \< \\
    \pcif \procZkf{\cnstRelation_1}{\funGen{\varSecKeyCarol}} \opEqNoQ 0 \\
    \t \pcreturn \cnstFalsum \\
    \cdots \< \< \< \< \cdots \\
    \varProofBobCarol \opFunResult \procDRProofL{\funStarAlt{\varCoinShared}}{\varFundValue}{\varSecKeyBob} \< \< \< \< \varProofBobCarol \opFunResult \procDRProofL{\funStarAlt{\varCoinShared}}{\varFundValue}{\varSecKeyCarol} \\
    (\varSigBobCarol, \varPubKeyBobCarol) \opFunResult \< \< \< \< (\varSigBobCarol, \varPubKeyBobCarol) \opFunResult \pcskipln \\
    \procDSignL{\varMsg}{\varSecKeyBob}{\varNonceBob} \< \< \< \< \procDSignR{\varMsg}{\varSecKeyCarol}{\varNonceCarol} \\
    \cdots \< \< \< \< \cdots \\
    \pcreturn (\funStar{\varPreTx}, \funStar{\varPtSpendableCoinBob}) \< \< \< \< \pcreturn (\funStar{\varPreTx}, \funStar{\varPtSpendableCoinCarol})
    }
\end{varwidth}
}

\begin{theorem} \label{teo:atom:sec-drecv}
    Let $\varCommitScheme$ be a correct and secure pedersen commitment scheme, $\varMPRProofSystem$ be a correct and secure multiparty range proof system and $\varSigSchemeMP$ be a secure and correct two-party signature scheme, then $\procDRecvCoinsId$ securely updates a mimbewimble pre-transaction by creating a new output coin $\funStarAlt{\varCoinShared}$ for which the key is shared between two parties Bob and Carol in the $\procZKfId{\cnstRelation_1}$,$\procZKfId{\cnstRelation_2}$,$\procDSignId$,$\procDRProofId$-model.
\end{theorem}

\begin{proof}
    As before we proof security by construction a simulator $\cnstSimulator$ with access to a trusted third party (TTP) computing $\procDRecvCoinsId$ in the ideal setting upon receiving inputs from the two parties.
    The simulators task is to extract the inputs of the adversary $\cnstAdversary$, send the inputs to the TTP and construct a protocol transcript indistinguishable from a real one.
    We first look at the case in which Bob is corrupted and then when Carol is corrupted.

    \textbf{Bob is corrupted}: Simulator $\cnstSimulator$ works as follows:
    \begin{enumerate}
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and saves ($\varCoinShared$, ($\varFundValue, \funStar{\varBlindingFactorBob}$)) when the adversary calls $\procZKfId{\cnstRelation_2}$.
        \item $\cnstAdversary$ sends $(\varPreTx,\varCoinShared)$.
        The simulator then compares $\varCoinShared$ with the values saved in its memory and sends $\cnstAbort$ to the TTP and outputs $\cnstFalsum$ if they don't match.
        Otherwise he sends $(\varPreTx, \varFundValue)$ to the TTP computing $\procRecvCoinsId$ and receives the outputs $(\funStar{\varPreTx}, \funStar{\varPtSpendableCoinBob})$.
        \item $\cnstSimulator$ proceeds by taking the last output $\funStarAlt{\varCoinShared}$ from $\funStar{\varPreTx}.\varOutputs$ and computes $\funGen{\varSecKeyCarol} \opAssign \funStarAlt{\varCoinShared} \opAddPoint {\varCoinShared}^{-1}$.
        The simulator computes $\funStarAlt{\varPreTx}$ by adding $\funStarAlt{\varCoinShared}$ to $\varPreTx$ and sends it together with $\funGen{\varSecKeyCarol}$ to $\cnstAdversary$ as if coming from Carol and sends $\cnstContinue$ to the TTP.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_1}$ as the verifier $\cnstSimulator$ check equality with the correct value and returns either 0 or 1.
        \item When the adversary calls $\procDRProofId$ the simulator saves $\varSecKeyBob$ to its memory and returns the last element of $\funStar{\varPreTx}.\varProofs$ as received from the TTP.
        \item For the call to $\procDSignId$ the simulator returns the $\varPreTx.\varSignature$ as the signature and $\funGen{\varSecKeyBob} \opAddPoint \funGen{\varSecKeyCarol}$ as the public key.
        \item $\cnstSimulator$ concludes by outputting whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    We find the following phases:
    \textbf{Phase 1}: Bob calls $\procZKfId{\cnstRelation_2}$ and sends $\varPreTx$ to Carol.
    \textbf{Phase 2}: Carol calls $\procZKfId{\cnstRelation_2}$ as the verifier adds her public key to the commitment and sends back an updated pre-transaction and her public key.
    \textbf{Phase 3}: Bob calls $\procZKfId{\cnstRelation_1}$ as the verifier and the parties call the trusted third parties computing $\procDRProofId$ and $\procDSignId$.

    We argue that in this case the simulation is perfect, that is the transcript produced by $\cnstSimulator$ is identical to the transcript of the real execution.
    \begin{itemize}
        \item \textit{Phase 1}: No simulation is done during this phase, and the transcript is therby indistinguishable by the deterministic nature of $\cnstAdversary$.
        \item \textit{Phase 2}: In case $\cnstAdversary$ sends an invalid value for $\varCoinShared$ the execution will stop with output $\cnstFalsum$ which is identical to what would happen in the real execution.
        The simulator can then send the updated pre-transaction as the honest Carol would do and the extracted real value for $\funGen{\varSecKeyCarol}$.
        \item \textit{Phase 3}: $\cnstAdversary$ will receiver 0 or 1 to the call to $\procZKfId{\cnstRelation_1}$ as in the real execution.
        The simulator further manages to reconstruct the real output values for $\procDRProofId$ and $\procDSignId$ again making the transcript identical in this phase.
    \end{itemize}

    \textbf{Carol is corrupted}: The simulator works as follows:
    \begin{enumerate}
        \item Since Carol does not have any inputs in this protocol $\cnstSimulator$ can simply send $\cnstEmptySet$ to the TTP and receives ($\funStar{\varPreTx}, \funStar{\varSpendableCoinCarol}$) from which he extracts Carols bliding factor (and secret key) as $\varSecKeyCarol \opAssign \funStar{\varSpendableCoinCarol}.\varBlindingFactor$.
        He can now create the initial shared coin $\varCoinShared$ by taking the last output of $\funStar{\varPreTx}.\varOutputs$ as $\funStarAlt{\varCoinShared}$ and calculating $\varCoinShared \opAssign \funStarAlt{\varCoinShared} \opAddPoint {\funGen{\varSecKeyCarol}}^{-1}$.
        he can further create the initial pre-transaction by removing the last entry of the output coin list, last entry of the proof list and signature from $\funStar{\varPreTx}$.
        \item $\cnstSimulator$ invokes $\cnstAdversary$ and send $\varPreTx, \varCoinShared$ (as calculated in step 1) as if coming from Bob.
        \item When $\cnstAdversary$ calls $\procZKfId{\cnstRelation_2}$ as the verifier the simulator checks for equality with what he send in the last step and returns either 0 or 1.
        \item The adversary then sends the updated $\funStarAlt{\varPreTx}$ which the simulator validates by checking if the last entry in $\funStarAlt{\varPreTx}.\varOutputs$ equals $\funStarAlt{\varCoinShared}$.
        If they don't $\cnstSimulator$ will output $\cnstFalsum$ and send $\cnstAbort$ to the TTP halting the execution, otherwise he will send $\cnstContinue$.
        \item Upon the adversary calling $\procDRProofId$ the simulator will return the proof at the last position in the proofs array of $\funStar{\varPreTx}.\varProofs$ received from the TTP.
        \item The simulator then extracts $\varFundValue \opAssign \funStar{\varPtSpendableCoinCarol}$ and computes $\varPubKeyBob \opAssign \varCoinShared \opAddPoint {\funGenH{\varValue}}^{-1}$ and returns $\funStar{\varPreTx}.\varSignature$ and $\funStar{\varSecKeyCarol} \opAddPoint \varPubKeyBob$ when $\cnstAdversary$ calls $\procDSignId$.
        \item The simulation completes with $\cnstSimulator$ outputting whatever $\cnstAdversary$ outputs.
    \end{enumerate}

    We now argue why in each of the three phases the transcript produced by $\cnstSimulator$ is indistinguishable from a real transcript.

    \begin{itemize}
        \item \textit{Phase 1}: Because $\cnstSimulator$ as able to call the TTP already in the first step he is able to receive the protocol outputs.
        The simulator can then extracts carols secret key $\varSecKeyCarol$ from Carols $\funStar{\varPtSpendableCoinCarol}$ output, which must also be her blinding factor in $\funStarAlt{\varCoinShared}$.
        He therefore can reconstruct $\varCoinShared$ which must be sent by Bob in this phase, simply by subtracting Carols part from the output which is present in $\funStar{\varPreTx}.\varOutputs$.
        $\cnstSimulator$ is further able to reconstruct the $\varPreTx$ which must be sent by Bob in this phase simply by removing the values from $\funStar{\varPreTx}$ which get added at a later point in the protocol.
        The transcript is therefore identical to a real one in this phase.
        \item \textit{Phase 2}: If $\cnstAdversary$ tries do cheat by sending an invalid value to $\procZKfId{\cnstRelation_2}$ as the verifier he will receive 0 as a response and 1 otherwise, which is identical to the real case.
        Similarity the execution will halt with $\cnstFalsum$ if $\cnstAdversary$ sends invalid values as $\funStarAlt{\varPreTx}$ and $\funGen{\varSecKeyCarol}$, again identical to a real execution.
        \item \textit{Phase 3}: $\cnstSimulator$ is able to read the output values for $\varProofBobCarol$ and $\varSigBobCarol$ from $\funStar{\varPreTx}$, he further is able to calculate $\varPubKeyBobCarol$ as he knows $\funGen{\varSecKeyCarol}$ and is further able to reconstruct $\varPubKeyBob$ from $\varCoinShared$.
        Therefore the simulation again is perfect in this phase.
    \end{itemize}

    Both in the case the Bob and Carol is corrupted $\cnstSimulator$ is able to produce a transcript indistinguishable from a transcript produced on a real execution we can therefore conclude that the protocol is secure in the $\procZKfId{\cnstRelation_1}$,$\procZKfId{\cnstRelation_2}$,$\procDSignId$,$\procDRProofId$-model and theorem~\ref{teo:atom:sec-drecv} holds.
\end{proof}

We claim that the security of the protocols $\procDFinTxId$ and $\procDAptFinTxId$ can be reduced to the security of $\procDSignId$ as all interaction between the two parties happens in the call to $\procDSignId$.
We have already proven the security of $\procDSignId$ in section~\ref{sec:sig:two-party-apt-security} and can reuse the simulator constructed there for the protcols $\procDFinTxId$ and $\procDAptFinTxId$.