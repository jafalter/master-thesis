In this section, we will define Mimblewimble transactions and required security properties, similiar to those found by Fuchsbauer et al. in~\cite{fuchsbauer2019aggregate}. We will only focus on the creation of new transfer transactions
(transferring value from one or many parties to one or many parties), the notions of transaction aggregation, coin minting and transaction publishing discussed in ~\cite{fuchsbauer2019aggregate} will not be topic of this formalization, as
they are not relevant building blocks for the proposed Atomic Swap protocol.

However, as an extension to the regular transaction protocol transferring value from one sender to a receiver we will define two further protocols. The first of them titled Extended Mimblewimble Transaction Scheme
will provide additional functions to create and spend coins owned by two parties instead of just one. The second extended definition is called Adapted Extended Mimblewimble Transaction Scheme and will allow the receiver
of a coin to hide a secret witness value $\varWit$ in his signature, in a way that the sender (or the senders) can redeem this secret after the protocol has completed.

We will proceed by providing an instantiation of the three transactions schemes which can be implemented and deployed on a Mimblewimble based Cryptocurrency such as Beam or Grin. Furthermore we provide proofs
that the schemes are correct and secure with regards to the defined security properties.

Finally, we define a Atomic Swap protocol from these building blocks, allowing two parties to securely and trustlessly swap funds from a Mimblewimble blockchain with those on another Blockchain, such as Bitcoin.


\section{Definitions}\label{sec:atomic-def}

As we have already discussed in section~\ref{sec:Mimblewimble} for the creation of a transaction, it is immanent that both the sender and receiver collaborate and exchange messages via a secure channel.
To construct the transaction protocol we assume that we have access to a two-party signature scheme $\varSigSchemeMP$ as defined in definition~\ref{def:twoPartySig}, a zero-knowledge Rangeproofs system $\varProofSystem$
such as Bulletproofs, as described in section~\ref{sec:rangeProof} and a homomorphic commitment scheme $\varCommitScheme$ as defined in definition~\ref{def:homomorphicCom} such as
Pedersen Commitments~\ref{def:pedersenCom}.

Fuchsbauer et al. have defined three procedures $\styleFunction{Send}$, $\styleFunction{Rcv}$ and $\styleFunction{Ldgr}$ with regards to the creation of a transaction. $\styleFunction{Send}$ called by the sender
will create a pre-transaction, $\styleFunction{Rcv}$ takes the pre-transaction and adds the receivers output and $\styleFunction{Ldgr}$ (again called by the sender) publishes the final transaction to the Blockchain ledger.
As we already pointed out in this thesis we won't discuss the transaction publishing phase therefore we will not cover the functionality of the $\styleFunction{Ldgr}$ procedure, instead we indroduce two
functions $\procFinSigId$ and $\procVerfTxId$. $\procFinSigId$ can be called by the transaction sender to finalize a pre-transaction into final valid transaction, which then could be broadcast with a node
connected to the Blockchain. The $\procVerfTxId$ function is called by nodes (acting as public verifiers) on the blockchain verifying the validity of the transaction, before including them to a block.

\begin{definition}[Mimblewimble Transaction Scheme]
    \label{def:mw-tx-scheme}
    A Mimblewimble transaction scheme $\varMWSchemeParams{\varCommitScheme}{\varSigSchemeMP}{\varProofSystem}$ consist of the following procedures:
    \[ \varMWSchemeParams{\varCommitScheme}{\varSigSchemeMP}{\varProofSystem} \opAssign ( \procSendCoinsId,\procRecvCoinsId,\procFinTxId,\procVerfTxId ) \]
    \begin{itemize}
        \item $(\varPreTx, \varSecKeyAlice) \opFunResult \procSendCoins{\funArray{\varCoinInp}}{\funArray{\varBlindingFactor}}{\varFundValue}{\varValue}$: The spendCoins algorithm is a DPT function called by the sending party to
        initiate the spending of some input coins. As input it takes a list of coins $\funArray{\varCoinInp}$ which should be spent, the respective keys $\funArray{\varBlindingFactor}$ to the input coins and a value $\varFundValue$ which should be
        transferred to the receiver as well as $\varValue$ which is the total value stored in the input coins. It outputs a pre-transaction $\varPreTx$ which can be sent to a receiver, as well as the senders signing key $\varSecKeyAlice$.
        \item $\varPreTx \opFunResult \procRecvCoins{\varPreTx}{\varFundValue}$: The receiveCoins algorithm is a DPT function called by the receiver and takes as input a pre-transaction $\varPreTx$ and a fund value
        $\varFundValue$ and will output a modified pre-transaction $\varPreTx$.
        \item $\varTx \opFunResult \procFinTx{\varPreTx}{\varSecKeyAlice}$: The finalize algorithm is a DPT function again called by the transaction sender that takes as input a pre-transaction $\varPreTx$ and the senders
        signing key $\varSecKeyAlice$. The function will output a finalized transaction $\varTx$, which can be published to the blockchain.
        \item $\{1,0\} \opFunResult \procVerfTx{\varTx}$: The transaction verification algorithm is a DPT function which can be called by a public verifier and takes as input a transaction $\varTx$. It
        outputs either 1 on verification success or 0 otherwise.
    \end{itemize}
\end{definition}

\begin{definition}[Extended Mimblewimble Transaction Scheme]
    \label{def:ext-mw-tx-scheme}
    TODO
\end{definition}

\begin{definition}[Adapted Extended Mimblewimble Transaction Scheme]
    \label{def:apt-ext-mw-tx-scheme}
    TODO
\end{definition}

An essential security property for a Mimblewimble Transaction Scheme $\varMWScheme$ is that a transaction can only transfer value from a sender to a receiver, but not create any new value, meaning the value
of a transactions output coins must always be equal (or less accounting for transaction fees) then the sum of the value of its input coins.

\begin{definition}[Inflation Resistence]
    TODO
\end{definition}

\begin{definition}[Theft-resistance]
    TODO
\end{definition}

\begin{definition}[Transaction indistinguishability]
    TODO
\end{definition}


\section{Mimblewimble instantiation}\label{sec:atomic-inst}

In this section we will provide an instantiation of the transaction scheme definitions found in~\ref{def:mw-tx-scheme},~\ref{def:ext-mw-tx-scheme} and~\ref{def:apt-ext-mw-tx-scheme}. The instantiations can be
implemented in a Cryptocurrency based on the Mimblewimble protocol such as Beam and Grin.

\subsection{$Miblewimble Transation Scheme$}

First we provide an instantiation of the simplest form of a transaction in which a sender wants to transfer some value $\varFundValue$ to a receiver. For the execution of the protocol we assume to have access to a homomorphic
commitment scheme such as Pedersen Commitment $\varCommitScheme$ as defined in definition~\ref{def:pedersenCom}. Furthermore we require a Rangeproof system $\varProofSystem$ as defined in
~\ref{sec:rangeProof} and a two-party signature scheme $\varSigSchemeMP$ as defined in~\ref{def:twoPartySig}.

The make the pseudocode for the transaction protocol easier we first introduce two auxiliary functions $\procCreateCoinId$
and $\procCreatePreTxId$. The coin creation function will take as input a value $\varValue$ and a blinding factor $\varBlindingFactor$, it will create and output a new coin $\varCoin$ together with a range proof
$\varProof$ attesting to the statement that the coins value $\varValue$ is within the valid range as defined for the blockchain.
The transaction creation algorithm $\procCreatePreTxId$ takes as input a message $\varMsg$, a list of input coins $\funArray{\varCoinInp}$, a list of output coins $\funArray{\varCoinOut}$, a list of rangeproofs
$\funArray{\varProof}$, a signature context $\varSigContext$, a list of nonce commitments $\varCommitment$ and a signature $\varSignature$ and will collect the input data into a transaction object.

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procCreateCoin{\varValue}{\varBlindingFactor}$} {
        \varCoin \opFunResult \procCommit{\varValue}{\varBlindingFactor} \\
        \varProof \opFunResult \procProof{\varCoin}{\varValue}{\varBlindingFactor} \\
        \pcreturn (\varCoin, \varProof)
        }
        \procedure[linenumbering]{$\procCreatePreTx{\varMsg}{\funArray{\varCoinInp}}{\funArray{\varCoinOut}}{\funArray{\varProof}}{\varSigContext}{\funArray{\varCommitment}}{\varSignature}$}{
        \pcreturn ( \\
        \varMsg \opAssign \varMsg, \\
        \varInputs \opAssign \funArray{\varCoinInp}, \\
        \varOutputs \opAssign \funArray{\varCoinOut}, \\
        \varProofs \opAssign \funArray{\varProof}, \\
        \varSigContext \opAssign \varSigContext, \\
        \varCommits \opAssign \funArray{\varCommitment}, \\
        \varSignature \opAssign \varSignature \\
        )
        }
    \end{varwidth}
    }
\end{center}

In figure~\ref{fig:inst-mw-tx} we provide an instantiation of the Mimblewimble Transction Scheme using the auxiliary functions provided before.

In the $\procSendCoinsId$ function the sender creates his change output coin, which is the difference between the value stored in his input coins and the value which should be transferred to a receiver.
He sets up the signature context with his parameters and gets a pretransaction $\varPreTx$, as well as a signing key $\varSecKeyAlice$ as output. The pretransaction can then be sent to a receiver.
Note that this instantiation differs from the one described by Fuchsbauer et al.~\cite{fuchsbauer2019aggregate} in that the sender does not yet sign the transaction during $\procSendCoinsId$. This has
the reason that in our definition of the Two-Party Signature Scheme~\ref{def:twoPartySig} the signature context $\varSigContext$ requires to be fully setup before a partial signature can be created, therfore
signing can only start at the recievers turn, after the signature context has been completed. In the paper by Fuchsbauer et al. signing already at the senders turn works, because instead of using the notion
of a two party signing protocol, they instead rely on a aggregateable signature scheme. The sender and receiver both will create their signatures which will then be aggregated into the final one. However,
we find that by relying upon a two-party signature scheme instead we are closer to what is implemented in practice~\footcite{https://medium.com/@brandonarvanaghi/grin-transactions-explained-step-by-step-fdceb905a853} .
Furthermore by starting the signing process at the receivers turn we avoid a potential problem: If an adversary learns the already signed pre-transaction $\varPreTx$ and the value $\varFundValue$ before the
intended receiver, the adversary would be able to steal the coins by creating his malicious output coin together with his signature, which he could then aggregate to the senders pre-transaction.

In $\procRecvCoinsId$ the receiver of a pre-transaction will verify the senders proof $\varProofBob$, create his outputcoin $\varCoinOutBob$, add his parameters to the signature context and then create his partial signature $\varSigBob$.
The function returns an updated version of the pre-transaction $\varPreTx$ which can be sent back to the sender.

Now in $\procFinTxId$ the original sender will validate the updated pre-transcation $\varPreTx$ sent to him by the receiver. If he finds it as valid, he will only now create his partial signature and finally
finalize the two partial signatures in the final composite one, with which he can then build the final transaction.

In $\procVerfTxId$ a public verifier will verify the rangeproofs for the transactions output coins. Then he will compute the so-called Excess value $\varExcess$ from the difference between output and input coins
and use it as the public key for validating the transation signature. If the signature is now also found to be correct the verfiier can deduce that the transaction is well-formed and valid.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSendCoins{\funArray{\varCoinInp}}{\funArray{\varBlindingFactorAlice}}{\varFundValue}$} {
            \varMsg \opAssign \cnstBinary{*} \\
            (\funStar{\varBlindingFactorAlice}, \varNonceAlice) \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \\
            (\varCoinOutAlice, \varProofAlice) \opFunResult \procCreateCoin{\varValue \opSub \varFundValue}{\funStar{\varBlindingFactorAlice}} \\
            \varSecKeyAlice \opAssign \funStar{\varBlindingFactorAlice} \opSub \sum \funArray{\varBlindingFactorAlice} \\
            \varSigContext \opAssign \{ \varPubKey \opAssign \cnstIdentityElement, \varRand \opAssign \cnstIdentityElement \} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyAlice}}{\funGen{\varNonceAlice}} \\
            \varPreTx \opFunResult \procCreatePreTx{\varMsg}{\funArray{\varCoinInp}}{\funArray{\varCoinOutAlice}}{\funArray{\varProofAlice}}{\varSigContext}{\funArray{\funGen{\varSecKeyAlice}}}{\cnstEmptySet} \\
            \pcreturn (\varPreTx, \varSecKeyAlice)
            } \\
            \procedure[linenumbering]{$\procRecvCoins{\varPreTx}{\varFundValue}$} {
            (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\cnstEmptySet) \opFunResult \varPreTx \\
            \pcif \procVerfProof{\varProofs[0]} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \\
            (\funStar{\varBlindingFactorBob},\varNonceBob) \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            (\varCoinOutBob,\varProofBob) \opFunResult \procCreateCoin{\varFundValue}{\funStar{\varBlindingFactorBob}} \\
            \varSecKeyBob \opAssign \funStar{\varBlindingFactorBob} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyBob}}{\funGen{\varNonceBob}} \\
            \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varSigContext.\varPubKey}{\varSigContext.\varRand} \\
            \varPreTx \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs \opConc \varCoinOutBob}{\varProofs \opConc \varProofBob}{\varSigContext}{\varCommits \opConc \funGen{\varNonceBob}}{\varSigBob} \\
            \pcreturn \varPreTx
            }
            \procedure[linenumbering]{$\procFinTx{\varPreTx}{\varSecKeyAlice}$} {
            (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\varSigBob) \opFunResult \varPreTx \\
            \pcif \procVerfProof{\varProofs[1]} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \\
            \pcif \procVerfPtSig{\varSigBob}{\varMsg}{\varCommits[1]} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \\
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varSigContext.\varPubKey}{\varSigContext.\varRand} \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
            \varTx \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs}{\varProofs}{\varSigContext}{\varCommits}{\varSigFin} \\
            \pcreturn \varTx
            }
            \procedure[linenumbering]{$\procVerfTx{\varTx}$} {
            (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\varSignature) \opFunResult \varTx \\
            \pcforeach \varProofs \textit{ as } \varProof \\
            \t \pcif \procVerfProof{\varProof} \opEqNoQ 0 \\
            \t \t \pcreturn 0 \\
            \varPubKey \opAssign \sum \varOutputs \opSub \sum \varInputs \\
            \pcreturn \procVerf{\varSignature}{\varMsg}{\varPubKey}\\
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Instantiation of Mimblewimble Transaction Scheme. \label{fig:inst-mw-tx}}
\end{figure}

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSpendOutput{\varFundValue}{\varCoinInp}{\varBlindingFactorAlice}{\cdot}$} {
            \varMsg \opAssign \cnstBinary{*} \< \< \\
            \funStar{\varBlindingFactorAlice} \opSeperate \varBlindingFactorFor{1} \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \\
            \varCoinOutAlice \opFunResult \procCommit{\varValue \opSub \varFundValue}{\funStar{\varBlindingFactorAlice}} \< \< \\
            \scriptstyle \varProofAlice \opFunResult \procProof{\varCoinOutAlice}{\varValue \opSub \varFundValue}{\funStar{\varBlindingFactorAlice}} \< \< \\
            \varBlindingFactorFor{s} \opAssign \funStar{\varBlindingFactorAlice} \opAddScalar \varBlindingFactorFor{1}  \opSub \varBlindingFactorAlice \< \< \\
            \< \sendmessageright*{ \scriptstyle \varTx \opAssign (\varMsg \opSeperate \varCoinInp \opSeperate \varCoinOutAlice \opSeperate \varProofAlice \opSeperate \funGen{\varBlindingFactorFor{s}} \opSeperate \funGen{\varBlindingFactorFor{1}})} \< \\
            \< \< \procVerfProof{\varProofAlice} \opEq 1 \\
            \< \< \varBlindingFactorFor{2} \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \< \< \varCoinShared \opFunResult \procCommit{\varFundValue}{\varBlindingFactorFor{2}} \opAddPoint \funGen{\varBlindingFactorFor{1}} \\
            \< \< \varBlindingFactorFor{r} \opAssign \varBlindingFactorFor{2}
            \< \sendmessageleft*{ \scriptstyle \varTx \opAssign \varTx \opUnion (\varCoinShared \opSeperate \funGen{\varBlindingFactorFor{r}})} \< \\
            \< \scriptstyle \varProof \opFunResult \procMuProof{\varCoinShared}{\varFundValue}{\varBlindingFactorFor{1}}{\varBlindingFactorFor{2}} \< \\
            \< \scriptstyle (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varBlindingFactorFor{s}}{\varBlindingFactorFor{r}} \< \\
            \procVerfPtSig{\varSigBob}{\varMsg}{\funGen{\varBlindingFactorFor{s}}}{\funGen{\varBlindingFactorFor{r}}} \opEq 1 \< \< \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \< \< \\
            \varExcess \opAssign \funGen{\varBlindingFactorFor{s}} \opAddPoint \funGen{\varBlindingFactorFor{r}} \< \< \\
            \scriptstyle \pcreturn \varTx \opAssign \varTx \opUnion (\varExcess \opSeperate \varSigFin \opSeperate \varProof)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Instantiation of $\cnstSoToMuTx$ transaction protocol. \label{fig:So2MuTx}}
\end{figure}

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSpendOutput{\varFundValue}{\varCoinInp}{\varBlindingFactorAlice}{\varBlindingFactorBob}$} {
            \varMsg \opAssign \cnstBinary{*} \< \< \\
            \funStar{\varBlindingFactorAlice} \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \\
            \varCoinOutAlice \opFunResult \procCommit{\varValue \opSub \varFundValue}{\funStar{\varBlindingFactorAlice}} \< \< \\
            \varProofAlice \opFunResult \procProof{\varCoinOutAlice}{\varValue \opSub \varFundValue}{\funStar{\varBlindingFactorAlice}} \< \< \\
            \varBlindingFactorFor{s} \opAssign \funStar{\varBlindingFactorAlice} \opSub \varBlindingFactorAlice \< \< \\
            \< \scriptstyle \sendmessageright*{\varTx \opAssign (\varMsg \opSeperate \varCoinInp \opSeperate \varCoinOutAlice \opSeperate \varProofAlice \opSeperate \funGen{\varBlindingFactorFor{s}})} \< \\
            \< \< \procVerfProof{\varProofAlice} \opEq 1 \\
            \< \< \funStar{\varBlindingFactorBob} \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \< \< \varCoinOutBob \opFunResult \procCommit{\varFundValue}{\funStar{\varBlindingFactorBob}} \\
            \< \< \varProofBob \opFunResult \procProof{\varCoinOutBob}{\varFundValue}{\varBlindingFactorFor{r}} \\
            \< \< \varBlindingFactorFor{r} \opAssign \funStar{\varBlindingFactorBob} \opSub \varBlindingFactorBob \\
            \< \scriptstyle \sendmessageleft*{\varTx \opAssign \varTx \opUnion (\varCoinOutBob \opSeperate \funGen{\varBlindingFactorFor{r}} \opSeperate \varSigBob \opSeperate \varProofBob)} \< \\
            \< \scriptstyle (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varBlindingFactorFor{s}}{\varBlindingFactorFor{r}} \< \\
            \procVerfPtSig{\varSigBob}{\varMsg}{\funGen{\varBlindingFactorFor{s}}}{\funGen{\varBlindingFactorFor{r}}} \opEq 1 \< \< \\
            \procVerfProof{\varProofBob} \opEq 1 \< \< \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \< \< \\
            \varExcess \opAssign \funGen{\varBlindingFactorFor{s}} \opAddPoint \funGen{\varBlindingFactorFor{r}} \< \< \\
            \pcreturn \varTx \opAssign \varTx \opUnion (\varExcess \opSeperate \varSigFin)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Instantiation of $\cnstMuToSoTx$ transaction protocol. \label{fig:Mu2SoTx}}
\end{figure}

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSpendOutput{\varFundValue}{\varCoinInp}{\varBlindingFactorAlice}{\varBlindingFactorBob}$} {
            \varMsg \opAssign \cnstBinary{*} \< \< \\
            \funStar{\varBlindingFactorAlice} \opSeperate \varBlindingFactorFor{1} \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \\
            \varCoinOutAlice \opFunResult \procCommit{\varValue \opSub \varFundValue}{\funStar{\varBlindingFactorAlice}} \< \< \\
            \scriptstyle \varProofAlice \opFunResult \procProof{\varCoinOutAlice}{\varValue \opSub \varFundValue}{\funStar{\varBlindingFactorAlice}} \< \< \\
            \varBlindingFactorFor{s} \opAssign \funStar{\varBlindingFactorAlice} \opAddScalar \varBlindingFactorFor{1}  \opSub \varBlindingFactorAlice \< \< \\
            \< \sendmessageright*{ \scriptstyle \varTx \opAssign (\varMsg \opSeperate \varCoinInp \opSeperate \varCoinOutAlice \opSeperate \varProofAlice \opSeperate \funGen{\varBlindingFactorFor{s}} \opSeperate \funGen{\varBlindingFactorFor{1}})} \< \\
            \< \< \procVerfProof{\varProofAlice} \opEq 1 \\
            \< \< \varBlindingFactorFor{2} \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \< \< \varCoinShared \opFunResult \procCommit{\varFundValue}{\varBlindingFactorFor{2}} \opAddPoint \funGen{\varBlindingFactorFor{1}} \\
            \< \< \varBlindingFactorFor{r} \opAssign \varBlindingFactorFor{2} \opSub \varBlindingFactorBob \\
            \< \sendmessageleft*{ \scriptstyle \varTx \opAssign \varTx \opUnion (\varCoinShared \opSeperate \funGen{\varBlindingFactorFor{r}})} \< \\
            \< \scriptstyle \varProof \opFunResult \procMuProof{\varCoinShared}{\varFundValue}{\varBlindingFactorFor{1}}{\varBlindingFactorFor{2}} \< \\
            \< \scriptstyle (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varBlindingFactorFor{s}}{\varBlindingFactorFor{r}} \< \\
            \procVerfPtSig{\varSigBob}{\varMsg}{\funGen{\varBlindingFactorFor{s}}}{\funGen{\varBlindingFactorFor{r}}} \opEq 1 \< \< \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \< \< \\
            \varExcess \opAssign \funGen{\varBlindingFactorFor{s}} \opAddPoint \funGen{\varBlindingFactorFor{r}} \< \< \\
            \scriptstyle \pcreturn \varTx \opAssign \varTx \opUnion (\varExcess \opSeperate \varSigFin \opSeperate \varProof)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Instantiation of $\cnstMuToMuTx$ transaction protocol. \label{fig:Mu2MuTx}}
\end{figure}


\section{Atomic Swap protocol}\label{sec:atomic-swap}