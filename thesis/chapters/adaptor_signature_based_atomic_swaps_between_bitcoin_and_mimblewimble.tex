In this section, we will define Mimblewimble transactions and security properties which must hold for such a transaction system. The formalizations will be similar to those found by Fuchsbauer et al. in~\cite{fuchsbauer2019aggregate}. However, we will only focus on the transaction protocol
(transferring value from one or many parties to one or many parties), the notions of transaction aggregation, coin minting and adding transaction to the main ledger also discussed in~\cite{fuchsbauer2019aggregate} will not be topic of this formalization, as
they are not relevant building blocks for the proposed Atomic Swap protocol.

However, as an extension to the regular transaction protocol transferring value from one sender to a receiver we will define two further protocols. The first of them titled \emph{Extended Mimblewimble Transaction Scheme}
will provide additional functions to create and spend coins owned by two parties instead of just one. The second extended definition is called \emph{Adapted Extended Mimblewimble Transaction Scheme} and will allow the receiver
of a coin to hide a secret witness value $\varWit$ in his signature, in a way that the sender (or the senders) can redeem this secret after the protocol has completed.

We will proceed by providing an instantiation of the three transactions schemes which can be implemented and deployed on a Mimblewimble based Cryptocurrency such as Beam or Grin. Furthermore we provide proofs
that the schemes are correct and secure with regards to the defined security properties.

Finally, we define a Atomic Swap protocol from these building blocks, allowing two parties to securely and trustlessly swap funds from a Mimblewimble blockchain with those on another blockchain, such as Bitcoin.

\section{Definitions}\label{sec:atomic-def}

As we have already discussed in section~\ref{sec:Mimblewimble} for the creation of a transaction in Mimblewimble, it is immanent that both the sender and receiver collaborate and exchange messages via a secure channel.
To construct the transaction protocol we assume that we have access to a two-party signature scheme $\varSigSchemeMP$ as defined in definition~\ref{def:twoPartySig}, a zero-knowledge Rangeproofs system $\varProofSystem$
such as Bulletproofs, as described in section~\ref{sec:rangeProof} and a homomorphic commitment scheme $\varCommitScheme$ as defined in definition~\ref{def:homomorphicCom} such as
Pedersen Commitments~\ref{def:pedersenCom}.

Fuchsbauer et al. have defined three procedures $\styleFunction{Send}$, $\styleFunction{Rcv}$ and $\styleFunction{Ldgr}$ with regards to the creation of a transaction. $\styleFunction{Send}$ called by the sender
will create a pre-transaction, $\styleFunction{Rcv}$ takes the pre-transaction and adds the receivers output and $\styleFunction{Ldgr}$ (again called by the sender) publishes the final transaction to the blockchain ledger.
As we have already pointed out in this thesis we won't discuss the transaction publishing phase therefore we will not cover the functionality of the $\styleFunction{Ldgr}$ procedure, instead we introduce two
functions $\procFinTxId$ and $\procVerfTxId$. $\procFinTxId$ can be called by the transaction sender to finalize a pre-transaction into final valid transaction, which then could be broadcast with a node
connected to the blockchain. The $\procVerfTxId$ function is called by nodes (acting as public verifiers) on the blockchain verifying the validity of the transaction, before including them in a block.

\begin{definition}[Mimblewimble Transaction Scheme]
    \label{def:mw-tx-scheme}
    A Mimblewimble Transaction Scheme $\varMWSchemeParams{\varCommitScheme}{\varSigSchemeMP}{\varProofSystem}$ with commitment scheme $\varCommitScheme$, two-party signature scheme $\varSigSchemeMP$, and rangeproof system $\varProofSystem$ consists of the following tupel of procedures:
    \[ \varMWSchemeParams{\varCommitScheme}{\varSigSchemeMP}{\varProofSystem} \opAssign ( \procSendCoinsId,\procRecvCoinsId,\procFinTxId,\procVerfTxId ) \]
    \begin{itemize}
        \item $(\varPreTx, (\varSecKeyAlice, \varNonceAlice)) \opFunResult \procSendCoins{\funArray{\varCoinInp}}{\funArray{\varBlindingFactor}}{\varFundValue}{\varValue}{\varTime}$: The spendCoins algorithm is a DPT function called by the sending party to initiate the spending of some input coins.
        As input it takes a list of coins $\funArray{\varCoinInp}$ which should be spent, the respective blinding factors $\funArray{\varBlindingFactor}$ to the input coins, and a value $\varFundValue$ which should be transferred to the receiver as well as a value $\varValue$ which is the total value stored in the input coins.
        Optionally a sender can pass a block height $\varTime$ when this transaction should become valid.
        It outputs a pre-transaction $\varPreTx$ which can be send to a receiver, as well as the senders signing key and secret nonce later used for signing $(\varSecKeyAlice, \varNonceAlice)$.
        \item $(\funStar{\varPreTx}, (\varCoinOutBob, \varBlindingFactorBob)) \opFunResult \procRecvCoins{\varPreTx}{\varFundValue}$: The receiveCoins algorithm is a DPT routine called by the receiver and takes as input a pre-transaction $\varPreTx$ and a fund value
        $\varFundValue$. It will construct the receivers output coin and output a modified pre-transaction $\funStar{\varPreTx}$ together with the new outputcoin $\varCoinOutBob$ and its blinding factor $\varBlindingFactorBob$.
        \item $\varTx \opFunResult \procFinTx{\varPreTx}{\varSecKeyAlice}{\varNonceAlice}$: The finalize algorithm is a DPT routine again called by the transaction sender that takes as input a pre-transaction $\varPreTx$ and the senders signing key $\varSecKeyAlice$ and nonce $\varNonceAlice$.
        The function will output a finalized transaction $\varTx$, which can be published to the blockchain.
        \item $\{1,0\} \opFunResult \procVerfTx{\varTx}$: The transaction verification algorithm is a DPT function which can be called by a public verifier and takes as input a transaction $\varTx$. It
        outputs either 1 on verification success or 0 otherwise.
    \end{itemize}
\end{definition}

We say a Mimblewimble Transaction Scheme is correct if the verification algorithm $\procVerfTxId$ returns 1 if and only if the the transaction is well
balanced and its signature is valid. More formally:
\begin{definition}[Transaction Scheme Correctness]
    \label{def:tx-scheme-correctness}
    For any list of input coins $\funArray{\varCoinInp}$ with total value $\varValue$ and blinding factors
    $\funArray{\varBlindingFactor}$ and a transaction fund value $\varFundValue$ with $\varFundValue \opSmEq \varValue$ the following must hold:
    \[
        \Pr\left[
        \begin{array}{c}
            \: \procVerfTx{\varTx} \opEqNoQ 1
        \end{array}
        \middle\vert
        \begin{array}{l}
            (\varPreTx, (\varSecKeyAlice, \varNonceAlice)) \opFunResult \procSendCoins{\funArray{\varCoinInp}}{\funArray{\varBlindingFactor}}{\varFundValue}{\varValue}{\cnstFalsum} \\
            (\funStar{\varPreTx}, \cdot) \opFunResult \procRecvCoins{\varPreTx}{\varFundValue}                                                          \\
            \varTx \opFunResult \procFinTx{\funStar{\varPreTx}}{\varSecKeyAlice}{\varNonceAlice}
        \end{array}
        \right]=1.
    \]
\end{definition}

\begin{definition}[Extended Mimblewimble Transaction Scheme]
    \label{def:ext-mw-tx-scheme}
    An extended Mimblewimble transaction scheme $\varextMWSchemeParams{\varCommitScheme}{\varSigSchemeMP}{\varProofSystem}$ is an extension to $\varMWScheme$ with the following two procedures:
    \[ \varextMWSchemeParams{\varCommitScheme}{\varSigSchemeMP}{\varProofSystem} \opAssign \varMWSchemeParams{\varCommitScheme}{\varSigSchemeMP}{\varProofSystem} \opConc (\procDSendCoinsId, \procDRecvCoinsId, \procDFinTxId) \]
    \begin{itemize}
        \item $\langle (\varPreTx,(\varSecKeyAlice,\varNonceAlice)), (\varPreTx,(\varSecKeyCarol,\varNonceCarol)) \rangle \\
        \opFunResult \procDSendCoins{\funArray{\varCoinInp}}{\funArray{\varBlindingFactorAlice}}{\varFundValue}{\varValue}{\funArray{\varBlindingFactorCarol}}{\varTime}$:
        The distributed coin spending algorithm takes as input a list of input coins, as well as a list of blinding factors from each Alice and Carol, and the to be transferred value $\varFundValue$ and total value of input coins $\varValue$.
        Note that for each provided input coin $\varCoinInp$ the blinding factor is composed by combining the shares from Alice and Carol like
        $\varBlindingFactor \opAssign \varBlindingFactorAlice \opAddScalar \varBlindingFactorCarol$.
        Again optionally a block height $\varTime$ can be given to time lock the transaction.
        \item $\langle (\funStar{\varPreTx}, (\varCoinShared, \funStar{\varBlindingFactorBob})), (\funStar{\varPreTx}, (\varCoinShared, \funStar{\varBlindingFactorCarol})) \rangle \opFunResult \procDRecvCoins{\varPreTx}{\varFundValue}$: The distributed coin receive procedure takes as input a pre-transaction $\varPreTx$ and a value $\varFundValue$ which should be transferred during the course of the transaction.
        The distributed algorithm will generate a output coin owned by both Alice and Carol. (each owning a share of the key).
        The output will be an updated pre-transaction $\funStar{\varPreTx}$, the shared output coin $\varCoinShared$ and the respective shares of the blinding factor.
        Note that $\varCoinShared$ will only be spendable if both owners cooperate running the $\procDSendCoinsId$ protocol.
        \item $\langle \varTx, \varTx \rangle \opFunResult \procDFinTx{\varPreTx}{\varSecKeyAlice}{\varNonceAlice}{\varSecKeyCarol}{\varNonceCarol}$: The distributed finalized transaction protocol has to be used if we are creating a transaction spending a shared coin (i.e. the transaction was created with the $\procDSendCoinsId$ algorithm).
        In this case we require signing information from both Alice and Carol.
        Again an optional locktime $\varTime$ can be provided.
    \end{itemize}
\end{definition}

Correctness is given very similar to the standard scheme:

\begin{definition}[Extended Transaction Scheme Correctness]
    \label{def:ext-tx-scheme-correctness}
    For any list of input coins $\funArray{\varCoinInp}$ with total value $\varValue$ and split blinding factors
    $(\funArray{\varBlindingFactorAlice}, \funArray{\varBlindingFactorCarol})$ and a transaction fund value $\varFundValue$ with $\varFundValue \opSmEq \varValue$ the following must hold:
    \[
        \Pr\left[
        \begin{array}{c}
            \: \procVerfTx{\varTx} \opEqNoQ 1
        \end{array}
        \middle\vert
        \begin{array}{l}
            \langle (\varPreTx, (\varSecKeyAlice, \varNonceAlice)), (\varPreTx, (\varSecKeyCarol, \varNonceCarol)) \rangle \opFunResult \\
            \procDSendCoins{\funArray{\varCoinInp}}{\funArray{\varBlindingFactorAlice}}{\varFundValue}{\varValue}{\funArray{\varBlindingFactorCarol}}{\cnstFalsum} \\
            \langle (\funStar{\varPreTx}, \cdot)(\funStar{\varPreTx}, \cdot) \rangle \opFunResult \procDRecvCoins{\varPreTx}{\varFundValue} \\
            \varTx \opFunResult \procDFinTx{\funStar{\varPreTx}}{\varSecKeyAlice}{\varNonceAlice}{\varSecKeyCarol}{\varNonceCarol}
        \end{array}
        \right]=1.
    \]
\end{definition}

\begin{definition}[Adapted Extended Mimblewimble Transaction Scheme]
    \label{def:apt-ext-mw-tx-scheme}
    The adapted version of the extended Mimblewimble Transaction Scheme updates the Extended Mimblewimble Transaction Schme by providing a modified version of the single party receive routine and the distributed finalize transaction protocol.
    \[ \varaptMWSchemeParams{\varCommitScheme}{\varSigSchemeMP}{\varProofSystem} \opAssign \varextMWSchemeParams{\varCommitScheme}{\varSigSchemeMP}{\varProofSystem} \opConc \procAptRecvCoinsId, \procDAptFinTxId \]
    \begin{itemize}
        \item $(\funStar{\varPreTx}, (\varCoinOutBob,\varBlindingFactorBob), \varSigBob) \opFunResult \procAptRecvCoins{\varPreTx}{\varFundValue}{\varWit}$: The adapted variant of the receive function takes an additional input a secret witness value
        $\varWit$ which will be hidden in the transactions signature and extractable by the other party after the protocols' completion.
        Note that the routine also returns Bob's unadapted partial signature.
        The reason for this is that we later still need the unadapted version to complete the signature und thereby finalize the transaction.
        By not sharing this unadapted signature with Alice, Bob is the one who gets to finalize the transaction which is different from the simpler protocol and is an important feature for our atomic swap protocol.
        \item $\langle \varSigAliceBob, \varTx \rangle \opFunResult \procDAptFinTx{\funStar{\varPreTx}}{\varSecKeyAlice}{\varNonceAlice}{\varStatement}{\varSecKeyBob}{\varNonceBob}{\varSigBob}$: The adapted variant of the finalize transaction algorithm is a distributed protocol between the sender(s) and receiver.
        Additionally to the pre-transaction $\funStar{\varPreTx}$ the senders need to input their signing information, Bob needs to input the unadapted version of his partial signature as it is needed for transaction completion.
        This protocol could also be implemented as a three party protocol, two senders controlling a shared coin and a third receiver.
        However, as in the case we will describe later in~\ref{sec:atomic-swap} one of the two senders is also the receiver, we allowed ourselves to model this protocol as being between only two parties to simplify the formalization.
        In this version of the protocol only Bob will be able to finalize the transaction, which is different to $\procFinTxId$ and $\procDFinTxId$.
        This has the practical reason that for the atomic swap execution Bob needs to be the one in control of the final transaction.
        If Alice were to build the final transaction before Bob, she might be able to extract the Witness value before the transaction has been published, which in the atomic swap scenario would mean she could steal the funds stored on the other chain.
        This is why the protocol does not return the final transaction $\varTx$ to Alice, instead the protocol will output the senders partial signature, which Alice can later use to extract a witness value.
    \end{itemize}
\end{definition}

Similar as before we define correctness for the adapted scheme:

\begin{definition}[Adapted Transaction Scheme Correctness]
    \label{def:apt-tx-scheme-correctness}
    For any list of input coins $\funArray{\varCoinInp}$ with total value $\varValue$ and blinding factors
    $\funArray{\varBlindingFactor}$ and a transaction fund value $\varFundValue$ with $\varFundValue \opSmEq \varValue$ and any witness value $\varX$ the following must hold:
    \[
        \Pr\left[
        \begin{array}{c}
            \: \procVerfTx{\varTx} \opEqNoQ 1
        \end{array}
        \middle\vert
        \begin{array}{l}
            (\varPreTx, (\varSecKeyAlice, \varNonceAlice)) \opFunResult \procSendCoins{\funArray{\varCoinInp}}{\funArray{\varBlindingFactor}}{\varFundValue}{\varValue}{\cnstFalsum} \\
            (\funStar{\varPreTx}, (\varCoinOutBob,\varBlindingFactorBob), \varSigBob) \opFunResult \procAptRecvCoins{\varPreTx}{\varFundValue}{\varWit} \\
            \langle \varSigAliceCarol, \varTx \rangle \opFunResult \procDAptFinTx{\varPreTx}{\varSecKeyAlice}{\varNonceAlice}{\varStatement}{\varSecKeyCarol}{\varNonceCarol}{\varSigBob}
        \end{array}
        \right]=1.
    \]
\end{definition}

\emph{Resistance against inflation}: We first define a security property which informally states that a transactions output value can only be less or equal to the value of its input coins (if less then the miner of the transaction can extract fees).
In other words a transaction in our definition shall only transfer existing but never generate any new value. We call this security property \emph{Inflation Resistance}.
In order to define this property we first have to define a cryptographic game $\procInflateId$ which takes as input a security parameter $\varN$ and a value $\varValue$ which the Adversary
$\cnstAdversary$ tries to inflate.

We define the game $\procInflateId$ as follows, whereas a challenger creates a input coin with value $\varValue$ given as a parameter to the game. The adversary then chooses a value $\funStar{\varValue}$ with
$\funStar{\varValue} \opGreaterThen \varValue$ and creates a new output coin $\varCoinOut$. The adversary wins if he can construct a valid transaction spending the challengers input coin $\varCoinInp$ to $\varCoinOut$ and thereby
creating new value in the total of $\funStar{\varValue} \opSub \varValue$.

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procInflate{\varN}{\varValue}$} {
        \varBlindingFactor \sample \cnstIntegersPrimeWithoutZero{\varN} \\
        (\varCoinInp, \varProof) \opFunResult \procCreateCoin{\varValue}{\varBlindingFactor} \\
        (\funStar{\varBlindingFactor}, \funStar{\varValue}) \opFunResult \cnstAdversary (\varCoinInp, \varValue) \\
        (\varCoinOut, \varProof) \opFunResult \procCreateCoin{\funStar{\varValue}}{\funStar{\varBlindingFactor}} \\
        \varTx \opFunResult\cnstAdversary (\varCoinInp, \varValue, \varCoinOut) \\
        \pcreturn \funStar{\varValue} \opGreaterThen \varValue \opAnd \procVerfTx{\varTx} \opEqNoQ 1 \opAnd \varTx.out \opEqNoQ \funArray{\varCoinOut} \opAnd \varTx.inp \opEqNoQ \funArray{\varCoinInp}
        }
    \end{varwidth}
    }
\end{center}

\begin{definition}[Inflation Resistence]
    A Mimblewimbe Transaction Scheme is called inflation resistent if for any value $\varValue$ in a valid range (as defined by the public parameters of the ledger), security
    paramter $\varN$ and a PPT adversary $\cnstAdversary$ the following holds:
    \[ \prob{\procInflate{\varN}{\varValue} \opEqNoQ 1} \opSmEq \funNegl{\varN} \]
\end{definition}

\emph{Resistance against Coin theft}: In a Mimblewimble transaction scheme a coins ownership is given by the knowledge of its blinding factor $\varBlindingFactor$. To spend the coin the sender would also have to know the coins value $\varValue$ in addition
to the blinding factor, however as the possible values for $\varValue$ in practice is restriced by the blockchains public parameters, it is trivial to guess.
Therefore we assume that knowledge of the blinding factor $\varBlindingFactor$ alone implies ownership of the coin.

We define a game $\procStealCoinId$ which takes as input a security parameter $\varN$ and a coin $\varCoinInp$. A PPT adversary $\cnstAdversary$ is given the challenge to spend the input coin given in the parameter.
He wins if he can construct a valid transaction $\varTx$ together with the help of a challenger spending the input coin $\varCoinInp$ and thereby transferring its value.

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procStealCoin{\varN}{\varCoinInp}$} {
        (\varPreTx, \varSecKey, \varFundValue) \opFunResult \cnstAdversary (\varCoinInp) \\
        \funStar{\varPreTx} \opFunResult \procRecvCoins{\varPreTx}{\varFundValue} \\
        \varTx \opFunResult \cnstAdversary (\funStar{\varPreTx}) \\
        \pcreturn \procVerfTx{\varTx} \opEqNoQ 1 \opAnd \varCoinInp \opIn \varTx.inp
        }
    \end{varwidth}
    }
\end{center}

\begin{definition}[Theft-resistance]
    A Mimblewimble Transaction Scheme is called theft-resistent if for any input coin $\varCoinInp$, security parameter $\varN$ and PPT adversary $\cnstAdversary$ the following holds:
    \[ \prob{\procStealCoin{\varN}{\varCoinInp} \opEqNoQ 1 } \opSmEq \funNegl{\varN} \]
\end{definition}

\emph{Transaction indistinguishability}: The third security property for a Mimblewimble Transaction System is related to transaction amounts. Due to the use of homomorphic commitments instead of plaintext values,
an adversary should be unable to extract plaintext amounts from the final transaction. To formalize the property we define the game $\procTxIndId$:
A PPT adversary $\cnstAdversary$ gets access to a transaction oracle $\procOracleTxId$ to which he can send two sets of values, one being the input value, the other the output value. We require all values to be in
a valid range as defined by the game parameter $\varValueMax$, furthermore we require the transaction to be balanced, so the output values can not be higher then input values. The oracle will select one of the two
sets depending on the bit $\varB$ chosen by the challenger and construct a transaction spending a coin with value $\varValue_b$ to a output coin of value $\varFundValue_b$ (as well as a change coin with the remainder).
From the returned transaction the adversary has to guess the value of $\varB$.
If the adversary manages to choose the correct value of $\varB$ he or she has won the game.

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procTxInd{\varN}{\varValueMax}$} {
        \varB \sample \{0,1\} \\
        \funStar{\varB} \opFunResult \cnstAdversary^{\procOracleTx{\cdot}{\cdot}{\cdot}{\cdot}} \\
        \pcreturn \varB \opEq \funStar{\varB}
        }
        \procedure[linenumbering]{$\procOracleTx{\varValue_1}{\varFundValue_1}{\varValue_2}{\varFundValue_2}$} {
        \pcif (\varValue_1, \varFundValue_1, \varValue_2, \varFundValue_2) \opNotIn [0, \varValueMax]*) \\
        \t \pcreturn \cnstFalsum \\
        \pcif \varFundValue_1 \opGreaterThen \varValue_1 \opOr \varFundValue_2 \opGreaterThen \varValue_2 \\
        \t \pcreturn \cnstFalsum \\
        \varBlindingFactor \sample \cnstIntegersPrimeWithoutZero{\varSecParam} \\
        \varCoinInp \opFunResult \procCreateCoin{\varValue_b}{\varBlindingFactor} \\
        (\varPreTx, \varSecKey, \varNonce) \opFunResult \procSendCoins{\funArray{\varCoinInp}}{\funArray{\varBlindingFactor}}{\varFundValue_b}{\varValue_b}{\cnstFalsum} \\
        \funStar{\varPreTx} \opFunResult \procRecvCoins{\varPreTx}{\varFundValue_b} \\
        \pcreturn \procFinTx{\funStar{\varPreTx}}{\varSecKey}{\varNonce}
        }
    \end{varwidth}
    }
\end{center}

\begin{definition}[Transaction indistinguishability]
    We say Transaction Indistinguishability holds for a Mimblewimble Transaction System $\varMWScheme$ if for a PPT adversary $\cnstAdversary$ with access to the transaction oracle $\procOracleTxId$ a
    security parameter $\varN$ and any max value $\varValueMax$ the following must hold:
    \[ \prob{\procTxInd{\varN}{\varValueMax} \opEq 1} \opSmEq 0.5 \opAddScalar \funNegl{\varN} \]
\end{definition}


\section{Mimblewimble instantiation}\label{sec:atomic-inst}

In this section we will provide an instantiation of the transaction scheme definitions found in~\ref{def:mw-tx-scheme},~\ref{def:ext-mw-tx-scheme} and~\ref{def:apt-ext-mw-tx-scheme}. The instantiations can be implemented in a Cryptocurrency based on the Mimblewimble protocol such as Beam and Grin.

\subsection{Mimblewimble Transaction Scheme}

First we provide an instantiation of the simplest form of a transaction in which a sender wants to transfer some value $\varFundValue$ to a receiver.
For the execution of the protocol we assume to have access to a homomorphic commitment scheme such as Pedersen Commitment $\varCommitScheme$ as defined in definition~\ref{def:pedersenCom}.
Furthermore we require a Rangeproof system $\varProofSystem$ as defined in~\ref{sec:rangeProof} and a two-party signature scheme $\varSigSchemeMP$ as defined in~\ref{def:twoPartySig}.

The make the pseudocode for the transaction protocol easier we first introduce two auxiliary functions $\procCreateCoinId$
and $\procCreatePreTxId$. The coin creation function will take as input a value $\varValue$ and a blinding factor $\varBlindingFactor$, it will create and output a new coin $\varCoin$ together with a range proof
$\varProof$ attesting to the statement that the coins value $\varValue$ is within the valid range as defined for the blockchain.
The transaction creation algorithm $\procCreatePreTxId$ takes as input a message $\varMsg$, a list of input coins $\funArray{\varCoinInp}$, a list of output coins $\funArray{\varCoinOut}$, a list of rangeproofs
$\funArray{\varProof}$, a signature context $\varSigContext$, a list of commitments $\varCommitment$, a signature $\varSignature$, and a lock time $\varTime$ and will collect the input data into a transaction object.

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procCreateCoin{\varValue}{\varBlindingFactor}$} {
        \varCoin \opFunResult \procCommit{\varValue}{\varBlindingFactor} \\
        \varProof \opFunResult \procProof{\varCoin}{\varValue}{\varBlindingFactor} \\
        \pcreturn (\varCoin, \varProof)
        }
        \procedure[linenumbering]{$\procCreatePreTx{\varMsg}{\funArray{\varCoinInp}}{\funArray{\varCoinOut}}{\funArray{\varProof}}{\varSigContext}{\funArray{\varCommitment}}{\varSignature}{\varTime}$}{
        \pcreturn ( \\
        \varMsg \opAssign \varMsg, \\
        \varInputs \opAssign \funArray{\varCoinInp}, \\
        \varOutputs \opAssign \funArray{\varCoinOut}, \\
        \varProofs \opAssign \funArray{\varProof}, \\
        \varSigContext \opAssign \varSigContext, \\
        \varCommits \opAssign \funArray{\varCommitment}, \\
        \varSignature \opAssign \varSignature, \\
        \varTime \opAssign \varTime
        )
        }
    \end{varwidth}
    }
\end{center}

In figure~\ref{fig:inst-mw-tx} we provide an instantiation of the Mimblewimble Transction Scheme using the auxiliary functions provided before.

In the $\procSendCoinsId$ function the sender creates his change output coin, which is the difference between the value stored in his input coins and the value which should be transferred to a receiver.
He sets up the signature context with his parameters and gets a pre-transaction $\varPreTx$, as well as a signing key $\varSecKeyAlice$ and secret nonce $\varNonceAlice$ as output. The pre-transaction can then be sent to a receiver.
Note that this instantiation differs from the one described by Fuchsbauer et al.~\cite{fuchsbauer2019aggregate} in that the sender does not yet sign the transaction during $\procSendCoinsId$. This has
the reason that in our definition of the Two-Party Signature Scheme~\ref{def:twoPartySig} the signature context $\varSigContext$ requires to be fully setup before a partial signature can be created, therefore
signing can only start at the recievers turn, after the signature context has been completed. In Fuchsbauer et al. paper it is possible to start the signing earlier, because instead of using the notion
of a two-party signing protocol, they instead rely on a aggregateable signature scheme. The sender and receiver both will create their signatures which will then be aggregated into the final one. However,
we find that by relying upon a two-party signature scheme instead we are closer to what is implemented in practice~\footcite{https://medium.com/@brandonarvanaghi/grin-transactions-explained-step-by-step-fdceb905a853} .
Furthermore by starting the signing process at the receivers turn we avoid a potential problem: If an adversary learns the already signed pre-transaction, before the
intended receiver, the adversary would be able to steal the coins by creating his malicious output coin together with his signature, which he could then aggregate to the senders pre-transaction.

In $\procRecvCoinsId$ the receiver of a pre-transaction will verify the senders proof $\varProofBob$, create his outputcoin $\varCoinOutBob$, add his parameters to the signature context and then create his partial signature $\varSigBob$.
The function returns an updated version of the pre-transaction $\varPreTx$ which can be sent back to the sender.

Now in $\procFinTxId$ the original sender will validate the updated pre-transcation $\varPreTx$ sent to him by the receiver. If he finds it as valid, he will only now create his partial signature and finally
finalize the two partial signatures in the final composite one, with which he can then build the final transaction.

In $\procVerfTxId$ a public verifier will verify the rangeproofs for the transactions output coins. If they are found valid she will compute the so-called Excess value $\varExcess$ from the difference between output and input coins
and use it as the public key for validating the transaction signature. If the signature is now also found to be correct the verifier can deduce that the transaction is well-formed and valid.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSendCoins{\funArray{\varCoinInp}}{\funArray{\varBlindingFactorAlice}}{\varFundValue}{\varValue}{\varTime}$} {
            \pcif \varFundValue \opGreaterThen \varValue \\
            \t \pcreturn \cnstFalsum \\
            \varMsg \opAssign \cnstBinary{*} \\
            (\funStar{\varBlindingFactorAlice}, \varNonceAlice) \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \\
            (\varCoinOutAlice, \varProofAlice) \opFunResult \procCreateCoin{\varValue \opSub \varFundValue}{\funStar{\varBlindingFactorAlice}} \\
            \varSecKeyAlice \opAssign \funStar{\varBlindingFactorAlice} \opSub \sum \funArray{\varBlindingFactorAlice} \\
            \varSigContext \opAssign \{ \varPubKey \opAssign \cnstIdentityElement, \varRand \opAssign \cnstIdentityElement \} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyAlice}}{\funGen{\varNonceAlice}} \\
            \varPreTx \opFunResult \procCreatePreTx{\varMsg}{\funArray{\varCoinInp}}{\funArray{\varCoinOutAlice}}{\funArray{\varProofAlice}}{\varSigContext}{\funArray{\funGen{\varSecKeyAlice}}}{\cnstEmptySet}{\varTime} \\
            \pcreturn (\varPreTx, (\varSecKeyAlice, \varNonceAlice))
            } \\
            \procedure[linenumbering]{$\procRecvCoins{\varPreTx}{\varFundValue}$} {
            (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\cnstEmptySet,\varTime) \opFunResult \varPreTx \\
            \pcif \procVerfProof{\varProofs[0]}{\varOutputs[0]} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \\
            (\funStar{\varBlindingFactorBob},\varNonceBob) \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            (\varCoinOutBob,\varProofBob) \opFunResult \procCreateCoin{\varFundValue}{\funStar{\varBlindingFactorBob}} \\
            \varSecKeyBob \opAssign \funStar{\varBlindingFactorBob} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyBob}}{\funGen{\varNonceBob}} \\
            \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varSigContext.\varPubKey}{\varSigContext.\varRand} \\
            \varPreTx \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs \opConc \varCoinOutBob}{\varProofs \opConc \varProofBob}{\varSigContext}{\varCommits \opConc \funGen{\varSecKeyBob}}{\varSigBob}{\varTime} \\
            \pcreturn (\varPreTx, \funStar{\varBlindingFactorBob})
            }
            \procedure[linenumbering]{$\procFinTx{\varPreTx}{\varSecKeyAlice}{\varNonceAlice}$} {
            (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\varSigBob,\varTime) \opFunResult \varPreTx \\
            \pcif \procVerfProof{\varProofs[1]}{\varOutputs[1]} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \\
            \pcif \procVerfPtSig{\varSigBob}{\varMsg}{\varCommits[1]} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \\
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext} \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
            \varTx \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs}{\varProofs}{\varSigContext}{\varCommits}{\varSigFin}{\varTime} \\
            \pcreturn \varTx
            }
            \procedure[linenumbering]{$\procVerfTx{\varTx}$} {
            (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\varSignature,\varTime) \opFunResult \varTx \\
            \pcforeach \varOutputs \textit{ as } (\varIterator => \varCoinOut) \\
            \t \pcif \procVerfProof{\varProofs[\varIterator]}{\varCoinOut[\varIterator]} \opEqNoQ 0 \\
            \t \t \pcreturn 0 \\
            \varPubKey \opAssign \sum \varOutputs \opSub \sum \varInputs \\
            \pcreturn \procVerf{\varSignature}{\varMsg}{\varPubKey}\\
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Instantiation of Mimblewimble Transaction Scheme. \label{fig:inst-mw-tx}}
\end{figure}

\subsection{Extended Mimblewimble Transaction Scheme}

So make the formalization of algorithms easier we define a protocol $\procDSignId$ which is a protocol between two-parties running the partial signature creation outlined in section~\ref{sec:schnorrInst}.
Note that we assume that the secret keys as well as nonces are already given as a paramter (which is the case during the transaction protocol) therefore we don't need an additional call to $\procKeyGenPtId$.

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procDSign{\varMsg}{\varSecKeyAlice}{\varSecKeyBob}{\varNonceAlice}{\varNonceBob}$} {
        Alice \< \< Bob \\
        \varSigContext \opAssign \{ \varPubKey \opAssign \cnstIdentityElement, \varRand \opAssign \cnstIdentityElement \} \< \< \\
        \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyAlice}}{\funGen{\varNonceAlice}} \< \< \\
        \< \sendmessageright*{\varSigContext, \varPubKeyAlice \opAssign \funGen{\varSecKeyAlice}} \< \\
        \< \< \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyBob}}{\funGen{\varNonceBob}} \< \< \\
        \< \< \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varSigContext} \\
        \< \sendmessageleft*{\varSigBob, \varSigContext, \varPubKeyBob \opAssign \funGen{\varSecKeyBob}} \< \\
        \pcif \procVerfPtSig{\varSigBob}{\varMsg}{\varPubKeyBob} \opEqNoQ 0 \< \< \\
        \t \pcreturn \cnstFalsum \< \< \\
        \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext} \< \< \\
        \< \sendmessageright*{\varSigAlice} \< \\
        \< \< \pcif \procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice} \opEqNoQ 0 \\
        \< \< \t \pcreturn \cnstFalsum \\
        \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
        \pcreturn \varSigFin \< \< \pcreturn \varSigFin
        }
    \end{varwidth}
    }
\end{center}

Figure~\ref{fig:ext-mim-tx-spend} shows an instantiation of the $\procDSendCoinsId$ function of the Extended Mimblewimble Transaction Scheme. We have one array of input coins which keys are shared between two parties
Alice and Carol, which should be spent. We use Carol here to not confuse this party with the receiver, which we previously called Bob. Although Carol and $\varBob$ could be the same person, they not necessarily have to be.

The protocol starts with both Alice and Carol creating her spend outputs with values $\varValueAlice$ and $\varValueCarol$. Alice then creates the initial pre-transaction $\varPreTx$ and sends it to Carol who verifies
Alice's output, adds her outputs and parameters and sends back $\varPreTx$, which Alice verifies. The protocol returns $\varPreTx$ to both parties, which can then be transmitted to the receiver by any of the two parties, as
well as the secret signing information $(\varSecKeyAlice, \varNonceAlice)$, $(\varSecKeyCarol, \varNonceCarol)$. Note that when using this protocol to spend coins that $\procFinTxId$ also turns into a protocol, using
$\procDSignId$ instead of $\procSignPrtId$ for signature generation. (Apart from that $\procFinTxId$ remains unchanged)

\newgeometry{margin=2cm}
\begin{landscape}
    \thispagestyle{plain}
    \begin{figure}
        \fbox{
        \procedure[linenumbering]{$\procDSendCoins{\funArray{\varCoinInp}}{\funArray{\varBlindingFactorAlice}}{\varFundValue}{\varValueAlice}{\funArray{\varBlindingFactorCarol}}{\varTime}$}{
        Alice \< \< Carol \\
        \pcif \varFundValue \opGreaterThen \varValue \< \< \pcif \varFundValue \opGreaterThen \varValue \\
        \t \pcreturn \cnstFalsum \< \< \t \pcreturn \cnstFalsum \\
        \varMsg \opAssign \cnstBinary{*} \\
        (\funStar{\varBlindingFactorAlice}, \varNonceAlice) \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< (\funStar{\varBlindingFactorCarol}, \varNonceCarol) \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
        (\varCoinOutAlice, \varProofAlice) \opFunResult \procCreateCoin{\varValueAlice}{\funStar{\varBlindingFactorAlice}} \< \< (\varCoinOutCarol, \varProofCarol) \opFunResult \procCreateCoin{\varValueCarol}{\funStar{\varBlindingFactorCarol}} \\
        \varSecKeyAlice \opAssign \funStar{\varBlindingFactorAlice} \opSub \sum \funArray{\varBlindingFactorAlice} \< \< \varSecKeyCarol \opAssign \funStar{\varBlindingFactorCarol} \opSub \sum \funArray{\varBlindingFactorCarol} \\
        \varSigContext \opAssign \{ \varPubKey \opAssign \cnstIdentityElement, \varRand \opAssign \cnstIdentityElement \} \< \< \\
        \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyAlice}}{\funGen{\varNonceAlice}} \< \< \\
        \varPreTx \opFunResult \\
        \procCreatePreTx{\varMsg}{\funArray{\varCoinInp}}{\funArray{\varCoinOutAlice}}{\funArray{\varProofAlice}}{\varSigContext}{\funArray{\funGen{\varNonceAlice}}}{\cnstEmptySet}{\varTime} \< \< \\
        \< \sendmessageright*{\varPreTx} \< \\
        \< \< (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\funStar{\varTime}) \opFunResult \varPreTx \\
        \< \< \pcif \procVerfProof{\varProofs[0]}{\varOutputs[0]} \opEqNoQ 0 \opOr \varTime \opNotEq \funStar{\varTime} \\
        \< \< \t \pcreturn \cnstFalsum \\
        \< \< \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyCarol}}{\funGen{\varNonceCarol}} \\
        \< \< \varPreTx \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs \opConc \varCoinOutCarol}{\varProof \opConc \varProofCarol}{\varSigContext}{\varCommits \opConc \funGen{\varNonceCarol}}{\cnstEmptySet}{\varTime} \\
        \< \sendmessageleft*{\varPreTx} \< \\
        \pcif \procVerfProof{\varPreTx.\varProofs[1]}{\varPreTx.\varOutputs[1]} \opEqNoQ 0 \< \< \\
        \t \pcreturn \cnstFalsum \< \< \\
        \pcreturn (\varPreTx, (\varSecKeyAlice, \varNonceAlice)) \< \< \pcreturn (\varPreTx, (\varSecKeyCarol, \varNonceCarol)) \\
        }
        }
        \caption{Extended Mimblewimble Transaction Scheme - $\procDSendCoinsId$ \label{fig:ext-mim-tx-spend}}
    \end{figure}
\end{landscape}
\restoregeometry

Figure~\ref{fig:ext-mim-tx-recv} shows an instantiation of the $\procRecvCoinsId$ function of the Extended Mimblewimble Transaction Scheme. Calling this protocol two receivers Bob and Carol want to create a
receiving shared coin $\varCoinShared$ with value $\varFundValue$ and key shares $(\varBlindingFactorAlice, \varBlindingFactorCarol)$. The protocol starts by both receivers verifing the senders output(s). Bob starts by creating a coin with
fund value $\varFundValue$ and his share of the newly create blinding factor and sends it over to Carol. Carol finalizes the shared coin by adding a commitment to her blinding factor to the coin and sends it back, together
with the commitment. Bob verifies validity of the updated shared coin after which the two parties engange in two two-party protocols to create their partial signature and coin rangeproof. Finally they create the updated
pre-transaction $\varPreTx$ which can be sent back to the sender.

\newgeometry{margin=2cm}
\begin{landscape}
    \thispagestyle{plain}
    \begin{figure}
            \fbox{
            \procedure[linenumbering]{$\procDRecvCoins{\varPreTx}{\varFundValue}$} {
            Bob \< \< \< \< Carol \\
            (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\varSigBob,\varTime) \opFunResult \varPreTx \< \< \< \< (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\varSigBob,\varTime) \opFunResult \varPreTx \\
            \pcforeach \varOutputs \textit{ as } (\varIterator => \varCoinOut) \< \< \< \< \pcforeach \varOutputs \textit{ as } (\varIterator => \varCoinOut) \\
            \t \pcif \procVerfProof{\varProofs[\varIterator]}{\varCoinOut[\varIterator]} \opEqNoQ 0 \< \< \< \< \t \pcif \procVerfProof{\varProofs[\varIterator]}{\varCoinOut[\varIterator]} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \< \< \< \< \t \pcreturn \cnstFalsum \\
            (\funStar{\varBlindingFactorBob}, \varNonceBob) \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \< \< \\
            (\varCoinShared,\cdot) \opFunResult \procCreateCoin{\varFundValue}{\funStar{\varBlindingFactorBob}} \< \< \< \< \\
            \varSecKeyBob \opAssign \funStar{\varBlindingFactorBob} \< \< \< \< \\
            \< \sendmessagerightx{4}{\varCoinShared} \< \\
            \< \< \< \< (\funStar{\varBlindingFactorCarol}, \varNonceCarol) \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \< \< \< \< \varSecKeyCarol \opAssign \funStar{\varBlindingFactorCarol} \\
            \< \< \< \< \funStarAlt{\varCoinShared} \opAssign \varCoinShared \opAddPoint \funGen{\varSecKeyCarol} \\
            \< \sendmessageleftx{4}{\funStarAlt{\varCoinShared}, \funGen{\varSecKeyCarol}} \< \\
            \pcif \funStarAlt{\varCoinShared} \opNotEq \varCoinShared \opAddPoint \funGen{\varSecKeyCarol} \< \< \< \< \\
            \t \pcreturn \cnstFalsum \< \< \< \< \\
            \< (\varSigBobCarol, \varPubKeyBobCarol, \funStar{\varSigContext}) \opFunResult \procDSign{\varMsg}{\varSecKeyBob}{\varSecKeyBob}{\varNonceAlice}{\varNonceBob}
            \< \\
            \< \funStarAlt{\varSigContext} \opFunResult \procSetupCtx{\varSigContext}{\funStar{\varSigContext}.\varPubKey}{\funStar{\varSigContext}.\varNonce} \< \\
            \< \varProofBobCarol \opFunResult \procDRProof{\funStarAlt{\varCoinShared}}{\varFundValue}{\varSecKeyAlice}{\varSecKeyBob} \< \\
            \< \varPreTx \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs \opConc \funStarAlt{\varCoinShared}}{\varProofs \opConc \varProofBobCarol}{\funStarAlt{\varSigContext}}{\varCommits \opConc \varPubKeyBobCarol}{\varSigBobCarol}{\varTime} \< \\
            \pcreturn \varPreTx \< \< \pcreturn \varPreTx
            }
            }
        \caption{Extended Mimblewimble Transaction Scheme - $\procDRecvCoinsId$ \label{fig:ext-mim-tx-recv}}
    \end{figure}
\end{landscape}
\restoregeometry

\newgeometry{margin=2cm}
\begin{landscape}
    \thispagestyle{plain}
    \begin{figure}
        \fbox{
        \procedure[linenumbering]{$\procDFinTx{\varPreTx}{\varSecKeyAlice}{\varNonceAlice}{\varSecKeyCarol}{\varNonceCarol}$} {
        Alice \< \< Carol \\
        (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\varSigBob,\varTime) \opFunResult \varPreTx \< \< (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\varSigBob,\varTime) \opFunResult \varPreTx \\
        \pcif \procVerfProof{\varProofs[1]}{\varOutputs[1]} \opEqNoQ 0 \< \< \pcif \procVerfProof{\varProofs[1]}{\varOutputs[1]} \opEqNoQ 0 \\
        \t \pcreturn \cnstFalsum \< \< \t \pcreturn \cnstFalsum \\
        \pcif \procVerfPtSig{\varSigBob}{\varMsg}{\varCommits[1]} \opEqNoQ 0 \< \< \pcif \procVerfPtSig{\varSigBob}{\varMsg}{\varCommits[1]} \opEqNoQ 0 \\
        \t \pcreturn \cnstFalsum \< \< \t \pcreturn \cnstFalsum \\
        \< \varSigAliceCarol \opFunResult \procDSign{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSecKeyCarol}{\varNonceCarol} \\
        \varSigFin \opFunResult \procFinSig{\varSigBob}{\varSigAliceCarol} \< \< \varSigFin \opFunResult \procFinSig{\varSigBob}{\varSigAliceCarol} \\
        \varTx \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs}{\varProofs}{\varSigContext}{\varCommits}{\varSigFin}{\varTime} \< \< \varTx \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs}{\varProofs}{\varSigContext}{\varCommits}{\varSigFin}{\varTime} \\
        \pcreturn \varTx \< \< \pcreturn \varTx
        }
        }
        \caption{Extended Mimblewimble Transaction Scheme - $\procDFinTxId$ \label{fig:ext-mim-tx-fin}}
    \end{figure}
\end{landscape}
\restoregeometry

\subsection{Adapted Extended Mimblewimble Transaction Scheme}

Figure~\ref{fig:inst-apt-mw-tx-recv} shows an instantiation of the $\procAptRecvCoinsId$ algorithm. Before updating the pre-transaction $\varPreTx$ Bob adapts his partial signature with the witness value $\varWit$. The procedure
then returns the pre-transaction $\varPreTx$ containing Bobs adapted partial signature, and the statement $\varStatement$ which is a commitment to the witness value $\varWit$.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procAptRecvCoins{\varPreTx}{\varFundValue}{\varWit}$} {
            (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\cnstEmptySet, \varTime) \opFunResult \varPreTx \\
            \pcif \procVerfProof{\varProofs[0]}{\varOutputs[0]} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \\
            (\funStar{\varBlindingFactorBob},\varNonceBob) \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            (\varCoinOutBob,\varProofBob) \opFunResult \procCreateCoin{\varFundValue}{\funStar{\varBlindingFactorBob}} \\
            \varSecKeyBob \opAssign \funStar{\varBlindingFactorBob} \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\funGen{\varSecKeyBob}}{\funGen{\varNonceBob}} \\
            \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varSigContext.\varPubKey}{\varSigContext.\varRand} \\
            \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
            \varPreTx \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs \opConc \varCoinOutBob}{\varProofs \opConc \varProofBob}{\varSigContext}{\varCommits \opConc \funGen{\varNonceBob}}{\varSigAptBob}{\varTime} \\
            \pcreturn (\varPreTx, (\varCoinOutBob, \funStar{\varBlindingFactorBob}),\varSigBob)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Adapted Extended Mimblewimble Transaction Scheme - $\procAptRecvCoinsId$. \label{fig:inst-apt-mw-tx-recv}}
\end{figure}

In figure~\ref{fig:inst-apt-mw-tx-fin} we show the updated distributed version of the transaction finalization protocol. Again Alice verifies the pre-transaction $\varPreTx$ received by Bob and then proceeds by building
her own partial signature. Note that at this point Alice is not able to finalize the signature (and consequently the transaction) as she only knows Bobs adapted partial signature, but not the original one, which is needed
for the $\procFinSigId$ function. Therefore in another round of interaction Alice sends her partial signature to Bob, who will verify Alice partial signature and finally calculate the final signature, needed for the transaction.
He will send over $\varSigFin$ which lets both parties construct the valid transaction as well as Alice call $\procExtWitId$ to extract the secret witness $\varWit$.

\begin{landscape}
    \thispagestyle{plain}
    \begin{figure}
            \fbox{
            \procedure[linenumbering]{$\procDAptFinTx{\varPreTx}{\varSecKeyAlice}{\varNonceAlice}{\varStatement}{\varSecKeyCarol}{\varNonceCarol}{\varSigBob}$} {
            Alice \< \< Bob \\
            (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\varSigAptBob,\varTime) \opFunResult \varPreTx \< \< (\varMsg,\varInputs,\varOutputs,\varProofs,\varSigContext,\varCommits,\varSigAptBob,\varTime) \opFunResult \varPreTx \\
            \pcif \procVerfProof{\varProofs[1]}{\varOutputs[1]} \opEqNoQ 0 \< \< \pcif \procVerfProof{\varProofs[1]}{\varOutputs[1]} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \< \< \t \pcreturn \cnstFalsum \\
            \pcif \procVerifyAptSig{\varSigBob}{\varMsg}{\varCommits[1]}{\varStatement} \opEqNoQ 0 \< \< \pcif \procVerifyAptSig{\varSigBob}{\varMsg}{\varCommits[1]}{\varStatement} \opEqNoQ 0 \\
            \t \pcreturn \cnstFalsum \< \< \t \pcreturn \cnstFalsum \\
            \varSigAliceCarol \opFunResult \procDSign{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSecKeyCarol}{\varNonceCarol} \< \< \\
            \< \sendmessageright*{\varSigAliceCarol} \< \\
            \< \< \procVerfPtSig{\varSigAliceCarol}{\varMsg}{\varCommits[0]} \\
            \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
            \< \< \varTx \opFunResult \procCreatePreTx{\varMsg}{\varInputs}{\varOutputs}{\varProofs}{\varSigContext}{\varCommits}{\varSigFin}{\varTime} \\
            \< \< \pcreturn \varTx
            }
            }
        \caption{Adapted Extended Mimblewimble Transaction Scheme - $\procDAptFinTxId$. \label{fig:inst-apt-mw-tx-fin}}
    \end{figure}
\end{landscape}

\section{Atomic Swap protocol}\label{sec:atomic-swap}

With the outlined Adapted Mimblewimble Transaction Scheme from definition~\ref{def:apt-ext-mw-tx-scheme} we can now construct an Atomic Swap protocol with another Cryptocurrency.
In this thesis we will explain a swap with Bitcoin, as at present Bitcoin and Bitcoin-like cryptocurrencies are the most widely adopted.
We will generally refer to the ``Bitcoin side`` and the ``Mimblewimble side`` of the swap to be most generic.
Upon implementation one has to decide for a specific implementation, for example BTC on the Bitcoin side and Grin on
the Mimblewimble side.
On the Bitcoin side we construct two DPT functions ($\procLockAddrId, \procVerifyLockId$).
\begin{itemize}
    \item $(\varScriptPubKey) \opFunResult \procLockAddr{\varPubKeyAlice}{\varPubKeyBob}{\varStatement}{\varTime}$:
    The locking script function lets Bob construct a Bitcoin script only spendable by Alice if she receives the discrete logarithm
    $\varWit$ of $\varStatement$ with $\varStatement \opEqNoQ \funGen{\varWit}$.
    Additionally the function requires Bobs public key $\varPubKeyBob$ and a timelock $\varTime$ (given as a block
    number) as input which allows Bob to reclaim his funds after some time if the atomic swap was not
    completed successfully. The function will create and return a Bitcon script $\varScriptPubKey$ to which Bob can send funds using a P2SH transaction.
    If Alice (knowing her secret key $\varSecKeyAlice$) acquires $\varWit$, she can construct the complete secret key simply
    by calculating $\varSecKey \opAssign \varSecKeyAlice \opAddScalar \varWit$.
    This construction is similiar although simpler to the locking mechanism described by Malavolta et al. For a in-depth security analysis of this concept we refer the interested reader to their paper ~\cite{malavolta2019anonymous}.
    For a concrete Bitcoin Script realizing this functionality see section~\ref{chp:implementation}.
    \item $\{ 1,0 \} \opFunResult \procVerifyLock{\varPubKeyAlice}{\varPubKeyBob}{\varStatement}{\varValue}{\varTime}$:
    The lock verification algorithm takes as input Alices,
    Bobs public keys and the statement $\varStatement$. The function will compute the Bitcoin lock script
    $\varScriptPubKey$ as created by $\procLockAddrId$ and then check the Bitcoin blockchain if the value locked
    under the script equals $\varValue$.
    Upon successful verification the function returns 1, otherwise 0.
\end{itemize}

\subsection{Setup phase}

We assume Alice owns Mimblewimble coins $\varCoinInp$ with a value of $\varValueMw$ and blinding factor $\varBlindingFactorAlice$ and Bob
Bitcoin locked in some UTXO $\varUTXO$ with a value of $\varValueBtc$ belonging to him.
Before the protocol can start the two parties must agree on the value they want to swap, the exchange rate of the currencies and a time after which the swap should be canceled.
After coming to an agreement the following variables are defined and known by both Alice and Bob:
\begin{itemize}
    \item $\varSecParam$ A security parameter.
    \item $\varAmountBtc$ The amount of Bitcoin Bob will swap to Alice.
    \item $\varAmountMW$ The amount of the Mimblewimble coin Alice will swap to Bob.
    \item $\varTimeBTC$ The locktime as a blockheight for the Bitcoin side.
    \item $\varTimeMW$ The locktime as a blockheight for the Mimblewimble side.
\end{itemize}
We collect this shared variables in an initial swap state $\varSwpState$:
\[ \varSwpState \opAssign \{ \varSecParam, \varAmountBtc, \varAmountMW, \varTimeBTC, \varTimeMW \} \]

In practice, we need to consider that exchange rates might fluctuate, furthermore timeouts have to be calculated separately for each chain.
The problems with cross chain payments are discussed by Tairi et al. in~\cite{tairi2019a2l}, they propose to use a fixed exchange rate for each day and to use a real world timeout like one day and then calculate the specific block numbers by taking the average block time of the blockchain into account.
In our setup we can also fix the exchange rate at the beginning of the protocol, which stays unchanged during protocol execution.
If the exchange rate fluctuates and one party is negatively impacted he or she could still decide to stop being cooperative which means the coins would be returned to the original owners after the timeout.

We formalize the protocol $\procSetupSwapId$ in figure~\ref{fig:setup-swap}.
The protocol takes as input the shared swap state $\varSwpState$ from both parties.
From Alice her Mimblewimble input coin $\varCoinInp$ together with the required spending information $\varBlindingFactorAlice$ and the coins value $\varValueMw$.
From Bob we require the UTXO $\varUTXO$ he wants to spend, similar to Alice he needs to provide spending secret $\varScriptSig$ and total value stored in the UTXO $\varValueBtc$, although this could also be read from the blockchain.

The protocol starts by both parties creating and exchanging keys.
Bob now creates two new Bitcoin outputs $\varUTXO_{lock}$ and $\varUTXO_{B}$, of which one is the locked Bitcoins which Alice might retrieve later (or Bob after time $\varTimeBTC$ has passed), and the other Bobs change output. (Difference between what is stored in the input UTXO and what should be sent to Alice).
After Bob has published the transaction sending value to the new outputs he will provide Alice with the statement $\varStatement$ under which the Bitcoins' are locked together with Alice's public key.
Alice can now verify that the funds on Bitcoin side are indeed correctly locked.
After that she will collaborate with Bob to spend her Mimblewimble coins into an output shared by both parties.
Immediately after, both parties collaborate again to spend this shared coin back to Alice with a timelock of $\varTimeMW$.
It is immanent that Alice does not publish the first transaction (A -> AB) before the timelocked refund transaction (AB -> A) was signed, otherwise her funds are locked in the shared output without the possibility of refund.
The setup protocol concludes with the funds locked up in both chains and ready to be swapped.

\footnotetext[1]{$\procSendCoins{\funArray{\varCoinInp}}{\funArray{\varBlindingFactorAlice}}{\varAmountMW}{\varValueMw}{\cnstFalsum}$}
\footnotetext[2]{$\procDRecvCoins{\varPreTx}{\varPreTx}$}
\footnotetext[3]{$\procDSendCoins{\funArray{\varCoinShared}}{\funArray{\funStar{\varBlindingFactorAlice}}}{\varAmountMW}{\varAmountMW}{\funArray{\funStar{\varBlindingFactorBob}}}{\varTimeMW}$}
\footnotetext[4]{$\procDFinTx{\funStar{\varPreTx_2}}{\varSecKeyAlice}{\varNonceAlice}{\varSecKeyBob}{\varNonceBob}$}

\newgeometry{margin=2cm}
\begin{landscape}
    \thispagestyle{plain}
    \begin{figure}
        \fbox{
        \procedure[linenumbering]{$\procSetupSwap{\varSwpState}{\varCoinInp}{\varBlindingFactorAlice}{\varValueMw}{\varUTXO}{\varScriptSig}{\varValueBtc}$} {
        Alice \< \< \< \< Bob \\
        \varKeyPairAlice \opFunResult \procSetup{\varSecParam} \< \< \< \< \varKeyPairBob \opFunResult \procSetup{\varSecParam} \\
        \< \< \< \< (\varWit, \varStatement) \opFunResult \procSetup{\varSecParam} \\
        \< \sendmessagerightx{4}{\varPubKeyAlice} \< \\
        \< \sendmessageleftx{4}{\varPubKeyBob} \< \\
        \< \< \< \< \varScriptPubKey \opFunResult \procLockAddr{\varPubKeyAlice}{\varStatement}{\varPubKeyBob}{\varTimeBTC} \\
        \< \< \< \< \varUTXO_{lock} \opFunResult \procCreateUTXO{\varAmountBtc}{\varScriptPubKey} \\
        \< \< \< \< \varSwpState \opAssign \varSwpState \opUnion \varUTXO_{lock} \opUnion \varStatement \\
        \< \< \< \< \varUTXO_{B} \opFunResult \procCreateUTXO{\varValueBtc - \varAmountBtc}{\varPubKeyBob} \\
        \< \< \< \< \varBtcTx \opFunResult \procBuildTransaction{\funArray{\varUTXO_{inp}}}{\funArray{\varUTXO_{lock}, \varUTXO_{B}}}{1}{\cnstEmptySet} \\
        \< \< \< \< \funStar{\varBtcTx} \opFunResult \procSignTransaction{\varBtcTx}{\funArray{\varScriptSig}} \\
        \< \< \< \< \procPublishBtc{\funArray{\funStar{\varBtcTx}}} \\
        \< \sendmessageleftx{4}{\varStatement} \< \\
        \pcif \procVerifyLock{\varPubKeyAlice}{\varPubKeyBob}{\varStatement}{\varAmountBtc}{\cnstEmptySet} \opEqNoQ 0 \\
        \t \pcreturn 0 \< \< \< \< \\
        (\varPreTx, (\varSecKeyAlice, \varNonceAlice)) \opFunResult \procSendCoinsId^1 \< \< \< \< \\
        \< \sendmessagerightx{4}{\varPreTx} \< \\
        \< \langle (\funStar{\varPreTx}, (\varCoinShared,\funStar{\varBlindingFactorAlice})), (\funStar{\varPreTx}, (\varCoinShared,\funStar{\varBlindingFactorBob})) \rangle \opFunResult \procDRecvCoinsId^2 \< \\
        \< \varSwpState \opAssign \varSwpState \opUnion \varCoinShared \< \\
        \varTx \opFunResult \procFinTx{\funStar{\varPreTx}}{\varSecKeyAlice}{\varNonceAlice} \< \< \< \< \\
        \< \langle (\varPreTx_2, (\varSecKeyAlice, \varNonceAlice)), (\varPreTx_2, (\varSecKeyBob, \varNonceBob))  \rangle \opFunResult \procDSendCoinsId^3 \< \\
        \funStar{\varPreTx_2} \opFunResult \procRecvCoins{\varPreTx_2}{\varAmountMW} \< \< \< \< \\
        \< \langle \varTx_2, \varTx_2 \rangle \opFunResult \procDFinTxId^4 \< \\
        \procPublishMW{\funArray{\varTx, \varTx_2}} \< \< \< \< \\
        \pcreturn \varSwpState \< \< \< \< \pcreturn \varSwpState \\
        }
        }
        \caption{Atomic Swap - $\procSetupSwapId$. \label{fig:setup-swap}}
    \end{figure}
\end{landscape}
\restoregeometry

\subsection{Execution Phase}

First we need to define an additional auxiliary function $\procVerifyTimeId$ with the following signature:
\[ \{0,1\} \opFunResult \procVerifyTime{\varChain}{\varTime} \]
This function will verify that there is sufficient time to execute the atomic swap protcol.
As input it takes a chain paramter $\varChain$ (in our case this could be either BTC or MW) and a block height $\varTime$.
The routine will verify that the current height of the blockchain is marginally below $\varTime$.
If this is the case it will return 1, or 0 otherwise.
How much time exactly should be left for the function to return 1 is implementation specific, and could be set to for instance one day.
We now define a protocol $\procExcSwapId$ to execute the Atomic Swap between some amount $\varAmountBtc$ on the Bitcoin side and some amount on the Mimblewimble side $\varAmountMW$.
We assume the participants have successfully run the $\procSetupSwapId$ protocol and both know the updated swap state $\varSwpState$ as returned by the setup protocol.
Alice (Mimblewimble side) needs to provide her part of the blinding factor $\funStar{\varBlindingFactorAlice}$ of the shared Mimblewimble coin $\varCoinShared$ as well as the swap state $\varSwpState$ as protocol inputs.
Bob (Bitcoin side) needs to provide his part of the blinding factor $\funStar{\varBlindingFactorBob}$ of the shared Mimblewimble coin $\varCoinShared$, the secret witness value $\varWit$ and the swap state $\varSwpState$ as protocol inputs.
The protocol starts with the two parties creating a Mimblewimble transaction with the goal of spending the shared input coin to Bob.
Bob will call the $\procAptRecvCoinsId$ routine to hide the secret $\varWit$ in his adapted signature $\varSigAptBob$, which Alice can retrieve from the final transaction.
Note that at this point only Bob knows his original partial signature $\varSigBob$.
Therefore they have to cooperate again in the $\procDAptFinTxId$ to compute the final Mimblewimble transaction transferring value from the shared coin $\varCoinShared$ to Bob.
After Bob has published the transaction and is now in possession of the swapped funds on the Mimblewimble side, he will send the transaction to Alice (or Alice could retrieve it directly from the blockchain, if Bob would refuse to cooperate).
Now Alice knows all the pieces needed to extract the secret witness $\varWit$:
\begin{itemize}
    \item The final signature $\varSigFin$.
    \item Bobs adapted signature $\varSigAptBob$ previously verified to contain $\varWit$.
    \item Her and Bobs partial signature spending the shared coin $\varSigAliceBob$.
\end{itemize}
She can now call $\procExtWitId$ to retrieve $\varWit$ and compute the secret key $\varSecKey_{BTC}$ needed to unlock the Bitcoin funds.
She will now create her own output $\varUTXO_{\varAlice}$, and will transfer the funds from the lock.
After publishing this transaction to the Bitcoin network, Alice is in full possession of the swapped funds on the Bitcoin side.
The procedure returns 1 if the swap was successfully executed or 0 otherwise (when not enough time was left to safely execute the swap).

\footnotetext[5]{$\procDSendCoins{\funArray{\varCoinShared}}{\funArray{\funStar{\varBlindingFactorAlice}}}{\varAmountMW}{\varAmountMW}{\funArray{\funStar{\varBlindingFactorBob}}}{\cnstFalsum}$}
\footnotetext[6]{$\procDAptFinTx{\funStar{\varPreTx}}{\varSecKeyAlice}{\varNonceAlice}{\varStatement}{\varSecKeyBob}{\varNonceBob}{\varSigBob}$}

\newgeometry{margin=2cm}
\begin{landscape}
    \thispagestyle{plain}
    \begin{figure}
        \fbox{
        \procedure[linenumbering]{$\procExcSwap{\varSwpState}{\varWit}{\funStar{\varBlindingFactorAlice}}{\funStar{\varBlindingFactorBob}}$} {
        Alice \< \< \< \< Bob \\
        (\varAmountMW, \varAmountBtc, \varTimeMW, \varTimeBTC, \varCoinShared, \varUTXO_{lock}, \varStatement) \opFunResult \varSwpState \< \< \< \< (\varAmountMW, \varTimeMW, \varTimeBTC, \varCoinShared) \opFunResult \varSwpState \\
        \< \langle (\varPreTx, (\varSecKeyAlice, \varNonceAlice), (\varPreTx, (\varSecKeyBob, \varNonceBob))) \rangle \opFunResult \procDSendCoinsId^5 \< \\
        \< \< \< \<  (\funStar{\varPreTx}, (\varCoinOutBob, \funStarAlt{\varBlindingFactorBob}), \varSigBob) \opFunResult \procAptRecvCoins{\varPreTx}{\varAmountMW}{\varWit} \\
        \<  \sendmessageleftx{4}{\funStar{\varPreTx}} \<  \\
        (...,\varSigAptBob) \opFunResult \funStar{\varPreTx} \< \< \< \< \\
        \< \pcif \procVerifyTime{BTC}{\varTimeBTC} \opEqNoQ 0 \opOr \procVerifyTime{MW}{\varTimeMW} \opEqNoQ 0 \< \\
        \< \t \pcreturn 0 \< \\
        \< \langle \varSigAliceBob, \varMwTx \rangle \opFunResult \procDAptFinTxId^6 \\
        \< \< \< \< \procPublishMW{\varMwTx} \\
        \< \sendmessageleftx{4}{\varMwTx} \< \\
        (...,\varSigFin) \opFunResult \varMwTx \< \< \< \< \\
        \varWit \opFunResult \procExtWit{\varSigFin}{\varSigAliceBob}{\varSigAptBob} \< \< \< \< \\
        \varSecKey_{BTC} \opFunResult \varSecKeyAlice \opAddScalar \varWit \< \< \< \< \\
        (\funStarAlt{\varSecKeyAlice}, \funStarAlt{\varPubKeyAlice}) \opFunResult \procSetup{\varSecParam} \< \< \< \< \\
        \varUTXO_{A} \opFunResult \procCreateUTXO{\varAmountBtc}{\funStarAlt{\varPubKeyAlice}} \< \< \< \< \\
        \varBtcTx \opFunResult \procBuildTransaction{\funArray{\funStar{\varUTXO_{lock}}}}{\funArray{\varUTXO_{A}}}{1}{\cnstEmptySet} \< \< \< \< \\
        \funStar{\varBtcTx} \opFunResult \procSignTransaction{\varBtcTx}{\varSecKey_{BTC}} \< \< \< \< \\
        \procPublishBtc{\funStar{\varBtcTx}} \< \< \< \< \\
        \pcreturn 1 \< \< \< \< \pcreturn 1
        }
        }
        \caption{Atomic Swap - $\procSetupSwapId$. \label{fig:exec-swap}}
    \end{figure}
\end{landscape}
\restoregeometry

\subsection{Refunding}

If one party refused to cooperate or goes offline the coins will be returned to the original owner.
On the Bitcoin side this is the case as Bob can simply spend the locked output with his private key $\varSecKeyBob$ after the timeout $\varTimeBTC$ has passed.
He then can simply construct and sign a transaction spending the output to a new UTXO which is in his possession.
He even could prepare this transaction upfront and broadcast it, once the the blocknumber hits $\varTimeBTC$ the transaction will become valid and get mined.
Again we stress the importance of using appropriate timeouts, if a timeout is too short the swap might get cancelled if there are some delays, if the timeout is too long the funds might be locked for an unnessary amount of time.

On the Mimblewimble side the second transaction spending the shared output back to Alice guarantees that her funds are returned to her after the timeout $\varTimeMW$ hits.
Because of this line number 24 in the setup phase is very important.
Alice here published both the locking of the funds and the refund at the same time.
If she would publish the locking transaction first, Bob could refuse to cooperate, in which case the funds would stay in the locking output only retrievable if both parties cooperate.
If the swap executes successful the refund transaction would get discarded by miners, as it then is no longer valid even after the timeout $\varTimeMW$.