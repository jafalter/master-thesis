\paragraph{Notation}
We first define the general notation used in the following chapters to formalize procedures and protocols.
Let $\cnstGroup$ denote a cyclic group of prime order $\varPrime$ and $\cnstIntegersPrime{\varPrime}$ the ring of integers modulo $\varPrime$ with identity element $\cnstIdentityElement$.
$\cnstIntegersPrimeWithoutZero{\varPrime}$ is $\cnstIntegersPrime{\varPrime} \opExcluding \funList{0}$.
$\varG \opSeperate \varH$ are adjacent generators in $\cnstGroup$, where adjacent means the discrete logarithm of $\varH$ in regards to $\varG$ is not known.
Exponentiation stands for repeated application of the group operation.
We define the group operation between two curve points as $\funGen{\varScA} \opAddPoint \funGen{\funGen{\varScB}} \opEq \funGen{\varScA \opAddScalar \varScB}$.

\begin{definition}[Hard Relation]\label{def:pre:hard-relation}
    Given a language $\varLanguage \opAssign \funList{\varBigA \opForWhich \exists\varSmallA \text{ s.t. } (\varBigA, \varSmallA) \opIn \cnstRelation}$ then the relation $\cnstRelation$ is
    considered hard if the following three properties hold:~\cite{aumayr2020bitcoinchannels}
    \begin{enumerate}
        \item $\procGenR{(\varSecParam)}$ is a $\cnstPolyTime$ sampling algorithm which outputs a statement/witness of the form $(\varBigA, \varSmallA) \opIn \cnstRelation$.
        \item Relation $\cnstRelation$ is poly-time decidable.
        \item For all $\cnstPolyTime$ adversaries $\cnstAdversary$ the probability of finding $\varSmallA$ given $\varBigA$ is negligible.
    \end{enumerate}
\end{definition}

\begin{definition}[Discrete Logarithm]\label{def:pre:discretelog}
    We define the discrete logarithm in a group $\cnstGroup$ of a number $\varN$ as the number $\varM$ such that for the groups generator $\varG$ the following holds:
    \[ \funGen{\varM} \opEqNoQ \varN \]
    The discrete logarithm is a hard relation as defined in~\ref{def:pre:hard-relation}.
\end{definition}

\begin{definition}[Signature Scheme]\label{def:pre:signature-scheme}
    A Signature Scheme $\varSigScheme$ is a tuple of algorithms $(\procSetupId \opSeperate \procSignId \opSeperate \procVerfId)$ defined as follows:~\cite{goldwasser1988digital}
    \[ \varSigScheme = (\procSetupId \opSeperate \procSignId \opSeperate \procVerfId) \]

    \begin{itemize}
        \item $\varKeyPair \opFunResult \procSetup{\varSecParam}$: The keygen function creates a keypair $\varKeyPair$, the public key can be distributed to the verifier(s) and the secret key has to be kept private. \\
        \item $\varSignature \opFunResult \procSign{\varMsg}{\varSecKey}$: The signing function creates a signature consisting of a variable $\varS$ and $\varRand$ which is a commitment to the secret nonce $\varNonce$ used during the signing process.
        As an input it takes a message $\varMsg$ and the secret key $\varSecKey$ of the signer.
        \item $\cnstTrueorFalse \opFunResult \procVerf{\varMsg}{\varSignature}{\varPubKey}$: The verification function allows a verifier knowing the signature $\varSignature$, message $\varMsg$ and the provers public key $\varPubKey$ to verify the signatures
        validity. \\
    \end{itemize}

    A valid Signature Scheme has to fulfill two security properties:
    \begin{itemize}
        \item Correctness: For all messages $\varMsg$ and valid keypairs $\varKeyPair$ the following must hold with overwhelming probability: $\procVerf{\varPubKey}{\procSign{\varSecKey}{\varMsg}}{\varMsg} \opEq 1$
        \item Unforgeability (\cnstEUFCMA): Informally the existential unforgeability under chosen message attacks holds if an attacker $\cnstAdversary$ is unable to forge a valid signature for a chosen message.
        A formalization of the property can be found in section~\ref{subsec:sig:secureaptscheme}
    \end{itemize}
\end{definition}

\begin{definition}[Cryptographic Hash Function]\label{def:pre:hash-function}
    A cryptographic hash function $\cnstHash$ is defined as $\funHash{\varInput} \rightarrow \cnstBinary{\varN}$ for some fixed number $\varN$ and some input $\varInput$ ~\cite{al2011cryptographic}.
    A secure hashing function has to fulfill the following security properties:
    \begin{itemize}
        \item Collision-Resistance (CR): Collision-Resistance means that it is computationally infeasible to find two inputs $\varInput_1$ and $\varInput_2$ such that
        $\funHash{\varInput_1} \opAssign \funHash{\varInput_2}$ with $\varInput_1 \opNotEq \varInput_2$.
        \item Pre-image Resistance (Pre): In a hash function $\cnstHash$ that fulfills Pre-image Resistance it is infeasible to recover the original input $\varInput$ from its hash output $\funHash{\varInput}$.
        If this security property is achieved, the hash function is said to be non-invertible.
        \item 2nd Pre-image Resistance (Sec):  This property is similar to Collision-Resistance and is sometimes referred to as \textit{Weak Collision-Resistance}.
        Given such a hash function $\cnstHash$ and an input $\varInput$, it should be infeasible to find a different input $\funStar{\varInput}$ such that $\varInput \opNotEq \funStar{\varInput}$
        and $\funHash{\varInput} \opEq \funHash{\funStar{\varInput}}$.
    \end{itemize}
    The relation between the input $\varInput$ and the output $\funHash{\varInput}$ is a hard relation as defined in~\ref{def:pre:hard-relation}.
\end{definition}

\begin{definition}[Commitment Scheme]\label{def:pre:commitment}
    A cryptographic Commitment Scheme $\varCommitScheme$ is defined by a pair of functions $(\procSetupId, \procCommitId)$~\cite{bunz2018bulletproofs}.
    \begin{itemize}
        \item $\varCommitParams \opFunResult \procSetupCom{\varSecParam}$: The setup procedure is a DPT function, it takes as input a security parameter $\varSecParam$ and outputs public parameters $\varPublicParam$.
        Depending on $\varPublicParam$ we define a input space $\varInputSpace_{\varPublicParam}$, a randomness space $\varRandSpace_{\varPublicParam}$ and a commitment space $\varCommitSpace_{\varPublicParam}$.
        \item $\varCommitment \opFunResult \procCommit{\varInput}{\varNonce}$ The commit routine is DPT function that takes an arbitrary input $\varInput \opIn \varInputSpace_{\varPublicParam}$, a random value $\varNonce \opIn \varRandSpace_{\varPublicParam}$ and
        generates an output $\varCommitment \opIn \varCommitSpace_{\varPublicParam}$.
    \end{itemize}

    Secure commitments must fulfill the \emph{Binding} and \emph{Hiding} security properties:
    \begin{itemize}
        \item \textit{Binding:} If a Commitment Scheme is binding it must hold that for all $\cnstPolyTime$ adversaries $\cnstAdversary$ given a valid input $\varInput \opIn \varInputSpace_{\varPublicParam}$
        and randomness $\varNonce \opIn \varRandSpace_{\varPublicParam}$ the probabilty of finding a $\funStar{\varInput} \opNotEq \varInput$ and a $\funStar{\varNonce}$ with
        $\procCommit{\varInput}{\varNonce} \opEqNoQ \procCommit{\funStar{\varInput}}{\funStar{\varNonce}}$ is negligible.
        \item \textit{Hiding:} For a $\cnstPolyTime$ adversary $\cnstAdversary$, commitment inputs $\varInput_0, \varInput_1 \opIn \varInputSpace_{\varPublicParam}$ randomness $\varNonce \opIn
       \varRandSpace_{\varPublicParam}$ and a commitment output $\varCommitment \opAssign \procCommit{\varInput_{\varB}, \varNonce}$ the probabilty of the adversary choosing the correct $\varB$ out of $\{0,1\}$
        must not be higher then $\frac{1}{2} + \funNegl{\varProbability}$.
    \end{itemize}
\end{definition}

\begin{definition}[Additive Homomorphic Commitment]\label{def:pre:homo-com}
    A Commitment Scheme as defined in~\ref{def:pre:commitment} is said to be addtive homomorphic if the following holds~\cite{bunz2018bulletproofs}
    \[ \procCommit{\varInput_1}{\varNonce_1} \opAddPoint \procCommit{\varInput_2}{\varNonce_2} \opEqNoQ \procCommit{\varInput_1 \opAddScalar \varInput_2}{\varNonce_1 \opAddScalar \varNonce_2} \]
\end{definition}

\begin{definition}[Pedersen Commitment Scheme]\label{def:pre:pedersen}
    A \emph{Pedersen Commitment Scheme} is an instance of a Commitment Scheme as defined in definition~\ref{def:pre:commitment} that has the additive homomorphic property as defined in~\ref{def:pre:homo-com}.

This can be achieved as follows:
    $\varCommitSpace_{\varPublicParam} \opAssign \cnstGroup$ of order $\varPrime \opSeperate \varInputSpace_{\varPublicParam} \opSeperate \varRandSpace_{\varPublicParam} \opAssign \cnstIntegersPrime{\varPrime}$.
    the procedures $(\procSetupComId, \procCommitId)$ are then instantiated as:
    \begin{gather*}
        \varCommitParams \opFunResult \procSetupComPed{\varG}{\varH} \opAssign \varG, \varH \opFunResult (\varG, \varH)\\
        \varCommitment \opFunResult \procCommit{\varInput}{\varNonce} \opAssign \funGen{\varNonce} \funGenH{\varInput}\\
    \end{gather*}
    An instantiation of the pedersen commitment scheme must pick two adjacent generators $\varG$, $\varH$ for the setup to be secure in terms of hiding and binding.
    Formally adjacent means that there exists a hard relation between $\varG$ and $\varH$ in terms of the discrete logarithm~\ref{def:pre:discretelog}.
That means no $\varX$ is known such that $\varH \opEqNoQ \funGen{x}$.
    In practice this is often achieved by hashing $\varG$ and using the hash output as $\varH$.

\end{definition}

To prove the security of our protocols we define the notion of security in the presence of malicious adversaries, which may deviate from the protocol arbitrarily.
To construct the definition we must first define two terms, $\cnstIdeal$ the execution in the ideal model and $\cnstReal$, the execution in the real model.
The following definitions are based on a tutorial paper on simulation proofs by Yehuda Lindell.~\cite{lindell2017simulate}

\paragraph{Execution in the Ideal Model} We have two parties $\varParty{1}$ with input $\varX$ and $\varParty{2}$ with input $\varY$ that cooperate to compute a two-party functionality $\cnstFunction : \cnstBinary{*} \opX \cnstBinary{*} \rightarrowtail \cnstBinary{*} \opX \cnstBinary{*}$.
The adversary $\cnstAdversary$ either controls $\varParty{1}$ or $\varParty{2}$.
The ideal execution $\cnstIdeal$ relies on the assumption that we have access to a trusted third party and proceeds in the following steps:

\begin{enumerate}
    \item \textbf{Inputs:} The input of $\varParty{1}$ is $\varX$ and the input of $\varParty{2}$ is $\varY$.
    Both parties get an additional auxiliary input $\varZ$.
    We note that we can generalize the concept to functions which require multiple inputs or even functions which do not require any input.
    In the case of multiple inputs the inputs of $\varParty{1}$ would then b a list $\funArray{\varX_i}$ and the inputs of $\varParty{2}$ a list $\funArray{\varY_i}$.
    For the case of simplicity we here describe the case with one single parameter provided by each party.
    \item \textbf{Send Inputs:} The honest party (the one which is not controlled by $\cnstAdversary$) sends its input $\varX$ (resp. $\varY$) to the trusted third party.
    The malicious party can either abort the execution by sending the symbol $\cnstAbort$ to the trusted third party, send its input $\varX$ (resp. $\varY$), or send an arbitrarily chosen string $\varK$ with the same length to $\varX$ to proceed with the protocol execution.
    The decision is made by $\cnstAdversary$ and may depend on the input or auxilary input $\varZ$.
    We denote $(\funStar{\varX}, \funStar{\varY})$ as the inputs received by the trusted third party.
    If $\varParty{1}$ is malicious then $(\funStar{x}, \funStar{y}) \opEqNoQ (\varK, \varY)$, if $\varParty{2}$ is malicious then $(\funStar{x}, \funStar{y}) \opEqNoQ (\varX, \varK)$.
    \item \textbf{Abort:} If the trusted third party has received $\cnstAbort$ from one of the parties, then it sends $\cnstAbort$ to both parties.
    \item \textbf{Answer to Adversary:} After having received both inputs the trusted third party computes $\cnstFunction(\funStar{\varX}, \funStar{\varY}) \opEqNoQ (\cnstFunction_1(\funStar{\varX}, \funStar{\varY}), \cnstFunction_2(\funStar{\varX}, \funStar{\varY}))$ and proceeds by sending $\cnstFunction_1(\funStar{\varX}, \funStar{\varY})$ (respective $\cnstFunction_2(\funStar{\varX}, \funStar{\varY})$) to the adversary.
    \item \textbf{Adversary Instructs Trusted Party:} $\cnstAdversary$ now again has the option of sending $\cnstAbort$ to the trusted third party to stop the execution.
    Otherwise it may send $\cnstContinue$ which means the output $\cnstFunction_1(\funStar{\varX}, \funStar{\varY})$ (respective $\cnstFunction_2(\funStar{\varX}, \funStar{\varY})$) will be delivered to the honest party.
    \item \textbf{Outputs:} The honest party outputs the answer of the trusted third party. The malicious party may output an arbitrary function of its input, the auxiliary string $\varZ$, or the answer for the trusted party.
\end{enumerate}

Let $\cnstAdversary$ be a non-uniform PPT algorithm and $\varI \opIn \{1,2\}$ be the index of the corrupted party.
We then denote $\cnstIdeal_{\cnstFunction, \styleFunction{P}(\varZ), \varI}(\varX, \varZ)$ as the ideal execution of $\cnstFunction$ on inputs $(\varX, \varY)$ with auxiliary input $\varZ$ to $\cnstAdversary$ and security param $\varSecParam$ defined as the output pair of the honest party and $\cnstAdversary$ from the ideal execution.

\paragraph{Execution in the Real Model} Again let $\cnstAdversary$ be a non-uniform PPT adversary and $\varI \opIn \{1,2\}$ be the index of the corrupted party.
In this model a real two-party protocol $\varProtocol$ is executed but the adversary $\cnstAdversary$ sens alls messages in place of the corrupted party, and may follow an arbitrary polynomial-time strategy.
Then the real execution of the two-party protocol $\varProtocol$ between $\varParty{1}$ and $\varParty{2}$ on inputs $(\varX, \varY)$ and auxiliary input $\varZ$ to $\cnstAdversary$ and security parameter $\varSecParam$ is denoted by $\cnstReal_{\cnstFunction, \styleFunction{P}(\varZ), \varI}(\varX, \varZ)$ and is defined as the output pair of the honest party and the adversary $\cnstAdversary$ from the real execution of $\varProtocol$.

\begin{definition}[Security in the Malicious Setting]\label{subsec:pre:security}
    We say a two-party protocol $\varProtocol$ securely computes a function $\cnstFunction$ with aborts and inputs $(\varX, \varY)$ in the malicious setting if for every non-uniform PPT adversary $\cnstAdversary$ in the real model, there exists a non-uniform PPT algorithm $\cnstSimulator$, refered to as simulator, such that
    \[
        \{ \cnstIdeal_{\cnstFunction, \cnstSimulator(\varZ), \varI}(\varX, \varZ) \opCompInd \cnstReal_{\cnstFunction, \cnstAdversary(\varZ), \varI}(\varX, \varZ) \}
    \]
    where $\funAbs{\varX} \opEqNoQ \funAbs{\varY}$ and $\varZ \opEqNoQ \styleFunction{poly(\funAbs{x})}$.~\cite{lindell2017simulate}
\end{definition}