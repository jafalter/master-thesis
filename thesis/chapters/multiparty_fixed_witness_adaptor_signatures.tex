In this chapter, we will define a variant of the adaptor signature scheme as explained in section ~\ref{sec:pre:aptsignatures}.
The main difference in the protocol outlined in this thesis is that one of the two parties does know the fixed secret witness before the start of the protocol.
The aim of the protocol will then be that the other person is able to extract the witness from the final signature. This feature can then be leveraged to build an Atomic Swap protocol as we
will show in ~\ref{chp:atomicSwap}.


First we will define the general two-party signature creation protocol as it is currently implemented in Mimblewimble-based Cryptocurrencies.
We reduce the generated signatures to the general case~\cite{schnorr1989efficient} and prove its correctness.
From this two-party protocol, we then derive the adapted variant, which allows hiding a fixed witness
value in the signature, which can be revealed only by the other party after attaining the final signature.


We start by defining our extended signature scheme in section~\ref{sec:sig:definitions},
proceed by providing a schnorr-based instantiation of the protocol in section~\ref{sec:sig:schnorr-inst} and finally prove its security in section~\ref{sec:sig:two-party-apt-security}.


\section{Definitions} \label{sec:sig:definitions}

A two-party signature scheme is an extension of a signature scheme as defined in definition~\ref{def:pre:signature-scheme}, which allows us to distribute signature generation for a composite public key shared between two parties Alice and Bob.
Alice and Bob want to collaborate to generate a signature valid under the composite public key $\varPubKey \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ without having to reveal their secret keys to each other.

\begin{definition}[Two Party Signature Scheme]
    \label{def:sig:two-party-sig}

    A \emph{two party signature scheme $\varSigSchemeMP$} extends a signature scheme $\varSigScheme$ with a tuple of protocols and algorithms\\
    ($\procKeyGenPtId, \procSignPrtId , \procVerfPtSigId, \procFinSigId)$ defined as follows:

    \begin{itemize}
        \item $((\varSecKeyAlice, \varPubKeyAlice, \varNonceAlice, \varSigContext), (\varSecKeyBob, \varPubKeyBob, \varNonceBob, \varSigContext)) \opFunResult \procKeyGenPt{\varSecParam}{\varSecParam}$: The distributed key generation protocol takes as input the security parameter from both Alice and Bob and returns
        the tuple $(\varSecKeyAlice, \varPubKeyAlice, \varNonceAlice, \varSigContext)$ to Alice (similar to Bob) where $(\varSecKeyAlice, \varPubKeyAlice)$ is a pair of private and corresponding public keys, $\varNonceAlice$ a secret nonce and $\varSigContext$ is the signature context containing parameters shared between Alice and Bob.
        We introduce $\varSigContext$ for the participants to share as well as update parameters with each other during the protocol execution.

        \item $(\varSigAlice) \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}$: The partial signing algorithm is a DPT function that takes as input the message $\varMsg$ and the share of the secret key $\varSecKeyAlice$ and nonce $\varNonceAlice$ (similiar for Bob) as well
        as the shared signature context $\varSigContext$. The procedure outputs $(\varSigAlice)$, that is, a share of the signature to a participant.

        \item $\cnstTrueorFalse \opFunResult \procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice}$: The share verification algorithm is a DPT function that takes as input a signature share $\varSigAlice$, a message $m$, and the other participants public key $\varPubKeyAlice$ (similiar $\varPubKeyBob$ for Bobs partial signature). The algorithm returns 1 if the verification was successfull or 0 otherwise.

        \item $\varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob}$: The finalize signature algorithm is a DPT function that takes as input two shares of the signatures and combines them into a final signature valid ander the shared public key $\varPubKey$.

    \end{itemize}

\end{definition}

We require the two party signature scheme to be correct as well as unforgeable against chosen message attacks (EUF-CMA). EUF-CMA for a two-party signature scheme was defined for instance in~\cite{lindell2017fast}.
For the correctness of the distributed key-generation protcol $\procKeyGenPtId$, special care needs to be taken to gurantee a uniformly random distribution of generated keys as
pointed out by Lindell and Yehuda in~\cite{lindell2017fast}.

\begin{definition}[Two Party Fixed Witness Adaptor Schnorr Signature Scheme]
    \label{def:sig:two-party-fixed-wit-apt-sig}
    From the definition~\ref{def:sig:two-party-sig}, we now derive an adapted signature scheme $\varSigSchemeApt$, which allows one of the participants to hide the discrete logarithm $\varWit$ of a statement $\varStatement \opAssign \funGen{\varWit}$ chosen
    at the beginning of the protocol. Again we extend our previously defined signature scheme with new functions:
    \[ \varSigSchemeApt \opAssign (\varSigSchemeMP \opConc \procAptSigId \opConc \procVerifyAptSigId \opConc \procExtWitId) \]

    \begin{itemize}
        \item $\varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit}$: The adapt signature algorithm is a DPT function that takes as input a partial signature $\varSigPt$ and a secret witness value $\varWit$.
        The procedure will output a adapted partial signature $\varSigApt$ which can be verified to contain $\varWit$ using the $\procVerifyAptSigId$ function, without having to reveal $\varWit$.
        \item $\cnstTrueorFalse \opFunResult \procVerifyAptSig{\varSigAptAlice}{\varMsg}{\varPubKeyAlice}{\varStatement}$: The verification algorithm is a DPT function that takes as input an adapted partial signature $\varSigApt$,
        the other participants public keys and a statement $\varStatement$. The function will verify the partial signature's validity as well that it contains the secret witness $\varWit$.
        \item $\varWit \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}$: The witness extraction algorithm is a DPT function that lets Alice extract the secret witness $\varWit$ from the final composite
        signature. Note that to extract the witness $\varWit$ the partial signatures shared between the participants beforehand and the statement $\varStatement$ needs to be provided as inputs. This means that for
        executing this function one needs to first learn the partial signatures exchanged between the parties.
    \end{itemize}
\end{definition}

Note that our definition of the adaptor signature scheme is different then the definition seen in~\ref{sec:pre:aptsignatures}. This has the reason that we require our scheme to be able to hide a secret chosen before
the signing protocol has been started. One of the participants will be able to hide this secret during the distributed signing protocol which the other party can extract after completion of the protocol. This feature
is a requirement for our signature scheme such that we can build the atomic swap protocol which will be layed out in~\ref{sec:atom:atomic-swap}.

\begin{definition}[\cnstSecureAptScheme]
    \label{def:sig:apt-sig-security}
    As defined by Aumayr et al. in~\cite{aumayr2020bitcoinchannels}, a secure adaptor signature scheme needs two security properties to be fulfilled:
    \begin{enumerate}
        \item \cnstaEUFCMA
        \item \cnstWitnessExtractability
    \end{enumerate}
\end{definition}

We proceed by redefining these properties as well as adapted correctness for our adapted two-party fixed witness signature scheme defined in definition~\ref{def:sig:two-party-fixed-wit-apt-sig}:

Similar to how it is defined in~\cite{aumayr2020bitcoinchannels} additionally to Correctness as defined in~\ref{def:pre:signature-scheme} we require our signature scheme to satisfy Adaptor Signature Correctness.
This property is given when every adapted partial signature generated by $\procAptSigId$ can be completed into a final signature for all pairs $(\varWit \opSeperate \varStatement) \opIn \cnstRelation$, from which it will
be possible to extract the witness computing $\procExtWitId$ with the required parameters.

\begin{definition}[Adaptor Signature Correctness]
    \label{def:sig:apt-sig-correctness}
    More formally \emph{Adaptor Signature Correctness} is given if for every security parameter $\varN \in \cnstNatural$, message $\varMsg \in \cnstBinary{*}$, \\ keypairs
    $((\varSecKeyAlice, \varPubKeyAlice, \varNonceAlice, \varSigContext), (\varSecKeyBob, \varPubKeyBob, \varNonceBob, \varSigContext)) \opFunResult \procKeyGenPt{\varSecParam}{\varSecParam}$
    with their composite public key $\varSigContext.\varPubKey$
    and every statement/witness pair $(\varStatement \opSeperate \varWit) \procGenR{\varSecParam}$ in a relation $\cnstRelation$ it must hold that:
    \[
        \Pr\left[
        \begin{array}{c}
            \:\procVerf{\varMsg}{\varSigFin}{\varSigContext.\varPubKey} \opEqNoQ 1                                         \\
            \opAnd                                                                                              \\
            \: \procVerifyAptSig{\varSigAptBob}{\varMsg}{}{\varPubKeyBob}{\varStatement} \opEqNoQ 1             \\
            \opAnd                                                                                              \\
            \:(\varStatement \opSeperate \funStar{\varWit}) \opIn \cnstRelation
        \end{array}
        \middle\vert
        \begin{array}{l}
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}        \\
            \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varSigContext}              \\
            \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit}                                             \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob}                                           \\
            \funStar{\varWit} \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}
        \end{array}
        \right]=1.
    \]
\end{definition}

Additionally to the regular definition of \emph{existential unforgeability under chosen message attacks} as defined for example in~\cite{lindell2017fast} or~\cite{vaudenay2006classical} we require that it is hard to produce a forged partial signature $\varSigPt$ if the
adversary $\cnstAdversary$ gets to know a valid adapted signature $\varSigApt$ w.r.t. some message $\varMsg$ and a statement $\varStatement$.
\begin{definition}[$\cnstaEUFCMA$] \label{def:sig:aeuf-cma}

    For the definition of $\cnstaEUFCMA$-security we define the experiment $\procExpForgId$ for a $\cnstPolyTime$ adversary $\cnstAdversary$ with a keypair $(\varSecKeyAlice \opSeperate \varPubKeyAlice)$,
    meaning the attacker plays the role of Alice in the protocol as
    follows:

    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procExpForg{\varN}$} {
            \varSet \opAssign \cnstEmptySet \\
            ((\varSecKeyAlice, \varPubKeyAlice, \varNonceAlice, \varSigContext), (\varSecKeyBob, \varPubKeyBob, \varNonceBob, \varSigContext)) \opFunResult \procKeyGenPt{\varSecParam}{\varSecParam} \\
            \varMsg \opFunResult \cnstAdversary^{\procSignOraclePt{\cdot}{\cdot}{\cdot}{\cdot}}(\varPubKeyBob) \\
            (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}\\
            \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varSigContext} \\
            \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
            \funStar{\varSigAlice} \opFunResult \cnstAdversary^{\procSignOraclePt{\cdot}{\cdot}{\cdot}{\cdot}}(\varSigAlice,\varSigAptBob) \\
            \varSigFin \opFunResult \procFinSig{\funStar{\varSigAlice}}{\varSigBob} \\
            \pcreturn ((\varMsg) \opNotIn \varSet \opAnd \funStar{\varSigAlice} \opNotEq \varSigAlice \opAnd \procVerf{\varMsg}{\varSigFin}{\varSigContext.\varPubKey})
            }\\[2\baselineskip]
            \procedure[linenumbering]{$\procSignOraclePt{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varSigContext}$} {
            (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext} \\
            \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varSigContext} \\
            \varSigAptBob \opFunResult \procAptSig{\varSigPt}{\varWit} \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigAptBob} \\
            \varSet \opAssign \varSet \opUnion \{\varMsg\} \\
            \pcreturn (\varSigFin \opSeperate \varStatement)
            }\\[2\baselineskip]
        \end{varwidth}
        }
    \end{center}
    The adapted signature scheme $\varSigSchemeApt$ is called $\cnstaEUFCMA$-secure if
    \[ \prob{\procExpForg{\varN} \opEqNoQ 1} \opSmEq \funNegl{\varN} \]
\end{definition}

\begin{definition}[\cnstWitnessExtractability]
    Informally the \cnstWitnessExtractability property holds for an adapted signature scheme $\varSigSchemeApt$ computed for the statement $\varStatement$ when we can always extract the witness
    $(\varWit \opSeperate \varStatement)$ from the final signature $\varSigFin$, given the partial signatures of the participants.
    To formalize this statement we describe an experiment $\procExpExtId$ for a $\cnstPolyTime$ adversary $\cnstAdversary$ with a keypair $\varKeyPairBob$,
    meaning the attacker plays the role of Bob in the protocol.

    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procExpExt{\varN}$} {
            \varSet \opAssign \cnstEmptySet \\
            ((\varSecKeyAlice, \varPubKeyAlice, \varNonceAlice, \varSigContext), (\varSecKeyBob, \varPubKeyBob, \varNonceBob, \varSigContext)) \opFunResult \procKeyGenPt{\varSecParam}{\varSecParam} \\
            (\varMsg \opSeperate (\varWit,\varStatement) \opIn \cnstRelation) \opFunResult \cnstAdversary^{\procSignOraclePt{\cdot}{\cdot}{\cdot}{\cdot}}(\varPubKeyAlice) \\
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}\\
            \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varSigContext} \\
            (\varSigAptBob \opSeperate \varSigFin) \opFunResult \cnstAdversary^{\procSignOraclePt{\cdot}{\cdot}{\cdot}{\cdot}}(\varPubKeyBob) \\
            \funStar{\varWit} \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob} \\
            \pcreturn (\varMsg \opNotIn \varSet \opAnd (\varStatement \opSeperate \funStar{\varWit}) \opNotIn \cnstRelation \opAnd \procVerf{\varMsg}{\varSigFin}{\varSigContext.\varPubKey})
            }\\

            \procedure[linenumbering]{$\procSignOraclePt{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varSigContext}$} {
            \varSet \opAssign \varSet \opUnion \varMsg \\
            \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}\\
            \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varSigContext} \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
            \pcreturn \varSigFin
            }
        \end{varwidth}
        }
    \end{center}
    In order to satisfy witness extractability the following must hold:
    \[ \prob{\procExpExt{\varN} \opEqNoQ 1} \opSmEq \funNegl{\varN} \]
\end{definition}


\section{Schnorr-based instantiation} \label{sec:sig:schnorr-inst}

We start by providing a general instantiation of a signature scheme (see definition~\ref{def:pre:signature-scheme}):
We assume we have a group $\cnstGroup$ with prime $\varPrime$, $\cnstHash$ is a secure hash function as defined in definition~\ref{def:pre:hash-function} and $\varMsg \opIn \cnstBinary{*}$ is a message.


A concrete implementation can be seen in figure~\ref{fig:schnorr}. The signature scheme is called schnorr signature scheme, first defined in~\cite{schnorr1989efficient} and is widely employed in many cryptography systems.
\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSetup{\varSecParam}$} {
            \varKey \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \pcreturn (\varSecKey \opAssign \varKey \opSeperate \varPubKey \opAssign \funGen{\varKey})
            }
            \procedure[linenumbering]{$\procSign{\varMsg}{\varSecKey}$}{
            \varNonce \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varRand \opAssign \funGen{\varNonce} \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \varS \opAssign \varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey \\
            \pcreturn \varSignature \opAssign (\varS, \varRand)
            }
            \procedure[linenumbering]{$\procVerf{\varMsg}{\varSignature}{\varPubKey}$} {
            (\varS \opSeperate \varRand) \opFunResult \varSignature \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varS} \opEq \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Schnorr Signature Scheme as first defined in~\cite{schnorr1989efficient}}
    \label{fig:schnorr}
\end{figure}
Correctness of the scheme is easy to derive. As $\varS$ is calculated as $\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey$, when generator $\varG$ is raised to $\varS$, we get
$\funGen{\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey}$ which we can transform into $\funGen{\varNonce} \opAddPoint \funGen{\varSecKey \opTimesScalar \varSchnorrChallenge}$, and finally
into $\varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}$ which is the same as the right side of the equation.

From the regular schnorr signature we now provide an instantiation for the two-party case defined in definition~\ref{def:sig:two-party-sig}. Note that this two-party variant of the scheme is what is
currently implemented in the mimblewimble-based cryptocurrencies and will provide a basis from which we will build our adapted scheme.

First we define a auxiliary function $\procSetupCtxId$ to use for the instantion:

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procSetupCtx{\varSigContext}{\varPubKeyAlice}{\varRandAlice}$} {
        \opAccess{\varSigContext}{\varPubKey} \opAssign \opAccess{\varSigContext}{\varPubKey} \opAddPoint \varPubKeyAlice \\
        \opAccess{\varSigContext}{\varRand} \opAssign \opAccess{\varSigContext}{\varRand} \opAddPoint \varRandAlice \\
        \pcreturn \varSigContext
        } \\
    \end{varwidth}
    }
\end{center}

This function helps the particpents to setup and update the signature context shared between them. In figure~\ref{fig:twoparty-schnorr} we show a concrete instantiation of the protocol and functions. In $\procKeyGenPtId$ Alice
and Bob will each randomly chose their secret key and nonce. They further require to create a zero-knowledge proof attesting to the fact that they have generated their key before any message was exchanged. This
is essential for the scheme to achieve EUF-CMA as described by Lindell et al. ~\cite{lindell2017fast}.

In $\procKeyGenPtId$ Alice will initially setup the signature context and send it to Bob, together with her public and zk-proof.
Bob verifies the proof (and exits if it is invalid). He will proceed by adding his parameters to the signature context and send it back to Alice, together with his public key and zk-proof, which Alice will verify.

$\procSignPrtId$ and $\procVerfPtSigId$ are generally similiar to the instantiation of the normal schnorr signature scheme. Note however that for computing the schnorr challenge $\varSchnorrChallenge$ the input into
the hash function will be the combined public key $\varPubKey$ and combined nonce commitment $\varRand$, which the participants can read from the context object $\varSigContext$. This has the effect that the partial
signature itself are not yet a valid signature (neither under $\varPubKey$ nor under $\varPubKeyAlice$ or $\varPubKeyBob$). This is because to be valid under $\varPubKey$ the partial signatures are missing the $\varS$ values
from the other participants. They are also not valid under the partial public keys $\varPubKeyAlice$ or $\varPubKeyBob$ because the schnorr challenge is computed already with the combined values. There we have
to introduce the slightly adjusted $\procVerfPtSigId$ to be able to verify specifically the partial signatures.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procKeyGenPt{\varSecParam}{\varSecParam}$} {
            \textbf{Alice} \< \< \textbf{Bob} \\
            \varSecKeyAlice \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \varSecKeyBob \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varNonceAlice \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \varNonceBob \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varPubKeyAlice \opAssign \funGen{\varSecKeyAlice} \< \< \varPubKeyBob \opAssign \funGen{\varSecKeyBob} \\
            \varRandAlice \opAssign \funGen{\varNonceAlice} \< \< \varRandBob \opAssign \funGen{\varNonceBob} \\
            \varZkpStatementAlice \opAssign \exists \varSecKeyAlice \textit{ s.t. } \funGen{\varSecKeyAlice} \opEqNoQ \varPubKeyAlice \< \< \varZkpStatementBob \opAssign \exists \varSecKeyBob \textit{ s.t. } \funGen{\varSecKeyBob} \opEqNoQ \varPubKeyBob \\
            \varProofAlice \opFunResult \procZkpProve{\varSecKeyAlice}{\varZkpStatementAlice} \< \< \varProofBob \opFunResult \procZkpProve{\varSecKeyBob}{\varZkpStatementBob} \\
            \varSigContext \opAssign \langle \varPubKey \opAssign \cnstIdentityElement \opSeperate \varRand \opAssign \cnstIdentityElement \rangle \< \< \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyAlice}{\varRandAlice} \< \< \\
            \< \sendmessageright*{\varSigContext, \varPubKeyAlice, \varProofAlice} \< \\
            \< \< \pcif \procZkpVerify{\varProofAlice} \opEqNoQ 0 \\
            \< \< \t \pcreturn \cnstFalsum \\
            \< \< \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyBob}{\varRandBob} \\
            \< \sendmessageleft*{\varSigContext, \varPubKeyBob, \varProofBob} \< \\
            \pcif \procZkpVerify{\varProofBob} \opEqNoQ 0 \< \< \\
            \t \pcreturn \cnstFalsum \< \< \\
            \pcreturn (\varSecKeyAlice,\varPubKeyAlice,\varNonceAlice,\varSigContext) \< \< \pcreturn (\varSecKeyBob,\varPubKeyBob,\varNonceBob,\varSigContext)
            } \\
            \procedure[linenumbering]{$\procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}$} {
            (\varRand \opSeperate \varPubKey) \opFunResult \varSigContext \\
            \varRandAlice \opAssign \funGen{\varNonceAlice} \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \varSAlice \opAssign \varNonceAlice \opAddScalar \varSecKeyAlice \opTimesScalar \varSchnorrChallenge \\
            \pcreturn \varSigAlice \opAssign (\varSAlice, \varRandAlice, \varSigContext)
            }
            \procedure[linenumbering]{$\procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice}$} {
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAlice \\
            (\varPubKey \opSeperate \varRand) \opFunResult \varSigContext \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varSAlice} \opEq \varRandAlice \opAddPoint \opPointScalar{\varPubKeyAlice}{\varSchnorrChallenge}
            }
            \procedure[linenumbering]{$\procFinSig{\varSigAlice}{\varSigBob}$} {
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAlice \\
            (\varSBob \opSeperate \varRandBob \opSeperate \varSigContext) \opFunResult \varSigBob \\
            (\varPubKey \opSeperate \varRand) \opFunResult \varSigContext \\
            \varS \opAssign \varSAlice \opAddScalar \varSBob \\
            \varSigFin \opAssign (\varS, \varRand) \\
            \pcreturn \varSigFin
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Two Party Schnorr Signature Scheme}
    \label{fig:twoparty-schnorr}
\end{figure}

We further show in figure~\ref{fig:twoparty-schnorr-prot} how Alice and Bob can cooperate to produce a final signature which can be verified by the regular verification algorithm in~\ref{def:pre:signature-scheme}.

\begin{figure}
    \centering
    \pseudocode[codesize=\scriptsize]{
    \textbf{Alice}  \< \< \textbf{Bob} \\ [][\hline]
    \< \<  \\
    \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
    \< ((\varSecKeyAlice, \varPubKeyAlice, \varNonceAlice, \varSigContext), (\varSecKeyBob, \varPubKeyBob, \varNonceBob, \varSigContext)) \opFunResult \procKeyGenPt{\varSecParam}{\varSecParam} \\ \< \\
    \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext} \< \< \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varSigContext} \\
    \< \sendmessageleft*{\varSigBob} \< \\
    \< \sendmessageright*{\varSigAlice} \< \\
    \procVerfPtSig{\varSigBob}{\varMsg}{\varPubKeyBob} \opEq 1 \< \< \procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice} \\
    \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob}
    }
    \caption{Two Party Schnorr Signature Scheme Interaction}
    \label{fig:twoparty-schnorr-prot}
\end{figure}

The final signature is a valid signature to the message $\varMsg$ with the composite public key $\varPubKey \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$.
A verifier knowing the signed message $\varMsg$, the final signature $\varSigFin$ and the composite public key $\varPubKey$ can now verify the signature using the regular $\procVerfId$ procedure.

Note that this way of computing schnorr signatures is not new.
For a proof of its correctness and a more extensive explanation we refer the reader to a paper by Maxwell et al.~\cite{maxwell2019simple}.

In figure~\ref{fig:aptSchnorr} we further provide a schnorr-based instantiation for the fixed witness adapted signature scheme as defined in definition~\ref{def:sig:two-party-fixed-wit-apt-sig}.

$\procAptSigId$ will add the secret witness $\varWit$ to the $\varS$ value of the signature, this means we will not be able to verify the adapted signature using $\procVerfPtSigId$ anymore. Therefore we
introduce $\procVerifyAptSigId$ which takes as additional parameter the statement $\varStatement$ which will be included in the verifiers equation. Now the function verifies not only validity of the portial
signature, but also that it indeed has been adapted with the witness value $\varWit$, being the discrete logarithm of $\varStatement$. After obtaining $\varSigFin$, we can then cleverly unpack the secret $\varWit$,
which is shown in the $\procExpExtId$ function.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procAptSig{\varSigPt}{\varWit}$}{
            (\varS \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigPt \\
            \varSStar \opAssign \varS \opAddScalar \varWit \\
            \pcreturn \varSigApt \opAssign (\varSStar \opSeperate \varRandAlice \opSeperate \varSigContext)
            } \\
            \procedure[linenumbering]{$\procVerifyAptSig{\varSigAptAlice}{\varMsg}{\varPubKeyAlice}{\varStatement}$} {
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAptAlice \\
            (\varPubKey \opSeperate \varRand) \opFunResult \varSigContext \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varSAlice} \opEq \varRandAlice \opAddPoint \opPointScalar{\varPubKeyAlice}{\varSchnorrChallenge} \opAddPoint \varStatement
            }
            \procedure[linenumbering]{$\procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}$}{
            (\varS \opSeperate \varRand) \opFunResult \varSigFin \\
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAlice \\
            (\varSAptBob \opSeperate \varRandBob \opSeperate \varSigContext) \opFunResult \varSigAptBob \\
            \varSBob \opAssign \varS \opSub \varSAlice \\
            \varWit \opAssign \varSAptBob \opSub \varSBob \\
            \pcreturn (\varWit)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Fixed Witness Adaptor Schnorr Signature Scheme}
    \label{fig:aptSchnorr}
\end{figure}

Again in figure~\ref{fig:apt-schnorr-interaction} we show another example interaction between Alice and Bob creating a signature $\varSigFin$ for the composite public key $\varPubKey \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$
while Bob will hide his secret $\varWit$ which Alice can extract after the signing process has completed. One thing to note is that in this protocol only Bob is able to call $\procFinSigId$ to create the final signature. This
is because the function requires Bobs unadapted partial signature $\varSigBob$ as input, which Alice does not know. (She only knows Bobs adapted variant). Therefore one further interaction is needed to send the final
signature to Alice.

\begin{figure}
    \pseudocode[codesize=\scriptsize]{
    \textbf{Alice} \< \< \textbf{Bob}  \\ [][\hline]
    \< \<  \\
    \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
    \< ((\varSecKeyAlice, \varPubKeyAlice, \varNonceAlice, \varSigContext), (\varSecKeyBob, \varPubKeyBob, \varNonceBob, \varSigContext)) \opFunResult \procKeyGenPt{\varSecParam}{\varSecParam} \\ \< \\
    \varSigAlice \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext} \< \< (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
    \< \< \varSigBob \opFunResult \procSignPrt{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varSigContext} \\
    \< \< \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
    \< \sendmessageleft*{\varSigAptBob, \varStatement} \< \\
    \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEq 1 \< \< \procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice}{} \opEq 1 \\
    \< \sendmessageright*{\varSigAlice} \< \\
    \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
    \< \sendmessageleft*{\varSigFin} \< \\
    \varWit \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigBob}
    }
    \caption{Fixed Witness Adaptor Schnorr Signature Interaction}
    \label{fig:apt-schnorr-interaction}
\end{figure}

\subsection{Correctness \& Security}\label{sec:sig:two-party-apt-security}

We now prove that the outlined schnorr-based instantiation is correct, i.e. Adaptor Signature Correctness holds, as well as secure with regards to the definition~\ref{def:sig:apt-sig-security}.

\subsection{Adaptor Signature Correctness}\label{subsec:sig:aptsig-correctness}

To prove that Adaptor Signature Correctness holds we have 3 statements to prove, first we prove that $\procVerf{\varMsg}{\varSigFin}{\varSigContext.\varPubKey} \opEq 1$ holds in our
schnorr-based instantiation of the signature scheme, whereas $\varSigContext$ is setup such that $\varPubKey \opEqNoQ \varPubKeyAlice \opAddPoint \varPubKeyBob$.

\begin{proof}
    \label{prf:apt-schnorr-pre-sig-corr}
    For this prove we assume the setup already specified in definition~\ref{def:sig:apt-sig-correctness}.
    The proof is by showing equality of the equation checked by the verifier of the final signature by continuous substitutions in the left side of equation:
    \begin{align}
        \funGen{\varS} &\opEqNoQ \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge} \\
        \funGen{\varSAlice} \opAddPoint \funGen{\varSBob} & \\
        \funGen{\varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob} & \\
        \funGen{\varNonceAlice} \opAddPoint \opPointScalar{\varPubKeyAlice}{\varSchnorrChallenge} \opAddPoint \funGen{\varNonceBob} \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} & \\
        \varRandAlice \opAddPoint \opPointScalar{\varPubKeyAlice}{\varSchnorrChallenge} \opAddPoint \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} & \\
        \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge} & \opEqNoQ \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge} \\
        1 & \opEqNoQ 1
    \end{align}

    It remains to prove that with the same setup $\procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEq 1$ and
    $(\varStatement \opSeperate \funStar{\varWit}) \opIn \cnstRelation$ hold.

    \[
        \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEq 1
    \]
    The proof is by continuous substitutions in the equation checked by the verifier:
    \begin{align}
        \funGen{\varSigAptBob} &\opEqNoQ \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement \\
        \funGen{\varSigBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opAddScalar \varSecKeyBob \opTimesScalar \varSchnorrChallenge \opAddScalar \varWit} & \\
        \funGen{\varNonceBob} \opAddPoint \funGen{\varSecKeyBob \opTimesScalar \varSchnorrChallenge} \opAddScalar \funGen{\varWit} & \\
        \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement &\opEqNoQ \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement \\
        1 &\opEqNoQ 1
    \end{align}
    We now continue to prove the last equation required:
    \[
        ((\varStatement \opSeperate \funStar{\varWit}) \opIn \cnstRelation)
    \]
    We do this by showing that $\varWit$ is calculated correctly in $\procExtWitId$:
    \begin{align}
        \varWit \opAssign & \varSApt \opSub (\varS \opSub \varSAlice) \\
        & \varSApt \opSub ((\varSAlice \opAddScalar \varSBob ) \opSub \varSAlice ) \\
        & \varSBob \opAddScalar \varWit \opSub (\varSBob) \\
        \varWit \opAssign & \varWit \\
    \end{align}
\end{proof}

\subsection{Secure Adaptor Signature Scheme}\label{subsec:sig:secureaptscheme}

In order to prove the security of the scheme we need to provide a proof that both \cnstaEUFCMA and Witness Extractability hold in our instantiation.
To perform the proof we must first recall the regular definition of \cnstEUFCMA given for regular schnorr signatures.~\cite{schnorr1989efficient} For that we define the game $\procExpForgeSimpleId$:

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procExpForgeSimple{\varN}$} {
        \varSet \opFunResult \cnstEmptySet \\
        \varKeyPair \opFunResult \procSetup{\varSecParam} \\
        (\varMsg \opSeperate \varSignature) \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\cdot}} \\
        \pcreturn ((\varMsg) \opNotIn \varSet \opAnd \procVerf{\varMsg}{\varSignature}{\varPubKey})
        }
        \procedure[linenumbering]{$\procSignOracle{\varMsg}{\varPubKey}$} {
        \varSignature \opFunResult \procSign{\varMsg}{\varSecKey} \\
        \varSet \opAssign \varSet \opUnion \{ \varMsg \} \\
        \pcreturn \varSignature
        }
    \end{varwidth}
    }
\end{center}

$\cnstEUFCMA$ holds if $\prob{\procExpForgeSimple{\varN} \opEqNoQ 1} \opSmEq \funNegl{\varN}$.

\begin{proof}
    We proof $\cnstaEUFCMA$ holds by providing a black box reduction from $\cnstaEUFCMA$ to $\cnstEUFCMA$ of schnorr signatures.
    Intuitively if we suppose there exists a $\cnstPolyTime$ adversary $\cnstAdversary$ that wins the $\procExpForgId$ game with probability $1$,
    then $\cnstAdversary$ will also be able to win the $\procExpForgeSimpleId$ game with the same probability, which leads us to a contradiction.
    This can be achieved by splitting up the public key chosen by the challenger in the $\procExpForgeSimpleId$ game into $\varPubKey_1$ and $\varPubKey_2$ and then running the
    $\procExpForgId$ game using the two split keys.
    Since the signing oracle in $\cnstaEUFCMA$ and Witness Extractability both provide a signature valid unter the composite of the two public keys, we can simulate the oracle
    queried by the adversary $\cnstAdversary$ simply by forwarding the query to the $\cnstEUFCMA$ oracle with the original unsplit version of the public key.
    The output of the $\procExpForgId$ game will be a forged final signature valid under the combined public key of $\varPubKey_1$ and $\varPubKey_2$
    which we can then use to win the $\procExpForgeSimpleId$ game. See figure~\ref{prf:bbreuf} for the black-box reduction.

    \begin{figure}
        \begin{center}
            \begin{bbrenv}{A}
                \begin{bbrbox}[name=\cnstEUFCMA]
                    \pseudocode{
                    \varKeyPair \opFunResult \procSetup{\varSecParam} \\
                    \varPubKey_1 \opAddPoint \varPubKey_2 \opEqNoQ \varPubKey \\
                    \varNonce \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
                    \varNonce_1 \opAddScalar \varNonce_2 \opEqNoQ \varNonce \\
                    \begin{bbrenv}{B}
                        \begin{bbrbox}[name=\cnstaEUFCMA, xshift=4cm]
                            \pseudocode{
                            \varMsg \opAssign \varMsg \\
                            \varPubKeyAlice \opAssign \varPubKey_1 \\
                            \varPubKeyBob \opAssign \varPubKey_2 \\
                            \varNonceAlice \opAssign \varNonce_1 \\
                            \varNonceBob \opAssign \varNonce_2 \\
                            }
                        \end{bbrbox}
                        \bbrmsgto{top={$\varN,\varPubKey_1,\varPubKey_2,\varNonce_1,\varNonce_2$}, length=3cm}
                        \bbrmsgfrom{top={$\varMsg,\varSigFin$}, length=3cm}
                        \bbrqryto{top={$\procSignOraclePt{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varSigContext}$}, length=4cm}
                        \bbrqryfrom{top={$\varSigFin \opAssign \funStar{\varSignature}$}, length=4cm}
                    \end{bbrenv} \\
                    \varSignature \opAssign \varSigFin
                    }
                \end{bbrbox}
                \begin{bbroracle}{OraA}
                    \begin{bbrbox}[name=$\procSignOracleId$, minheight=1cm, xshift=1cm]
                    \end{bbrbox}
                \end{bbroracle}
                \bbroracleqryto{top=$\procSignOracle{\varMsg}{\varSigContext.\varPubKey}$, length=3cm}
                \bbroracleqryfrom{top=$\funStar{\varSignature}$, length=3cm}
                \bbrinput{n}
                \bbroutput{$\varSignature$}
            \end{bbrenv}
        \end{center}
        \caption{Reduction from \cnstaEUFCMA to \cnstEUFCMA \label{prf:bbreuf}}
    \end{figure}

    In a very similiar way we can provide a reduction from \cnstWitnessExtractability to $\cnstEUFCMA$.
    Again if we suppose there exists a $\cnstPolyTime$ adversary $\cnstAdversary$ able to win the $\procExpExtId$ game with probability $1$,
    then $\cnstAdversary$ will always be able to win the $\procExpForgeSimpleId$, leading to a contradiction. Similiar to the previous proof the adversary $\cnstAdversary$
    splits up the secret key $\varPubKey$ computed during the $\procExpForgeSimpleId$ game into $\varPubKey_1$ and $\varPubKey_2$ to use them in the $\procExpExtId$.
    The forged final signature $\varSigFin$ can then be used to win the $\procExpForgeSimpleId$ game. As the black-box reduction is the same as before we again refer
    to figure~\ref{prf:bbreuf} to see the details.

\end{proof}