In this chapter, we will define a variant of the Adaptor Signature scheme as seen in~\ref{sec:aptSignatures},
which is specifically tailored for the use in an Atomic Swap scenario in which (at least one side of the swap) uses a two-party protocol to generate transaction signatures.
We will start by explaining the general two-party signature creation protocol as it currently implemented in the Grin Cryptocurrency.
We reduce the generated signatures to the general case~\cite{schnorr1991efficient} and thereby prove its security. From this protocol, we then derive the adapted variant, which allows hiding a fixed witness
value in the signature, which can only be revealed by the other party after attaining the final signature.
We then proof it's security by showing that all security definitions defined in~\cite{sanches2020bitcoinchannels} hold.
In chapter~\ref{chp:atomicSwap} we will then utilize this scheme to build the Atomic Swap protocol.

\begin{definition}{Two Party Signature Generation}\label{def:twoPartySig}
    We first define a multiparty Signature Scheme wrt. to a hard relation $\cnstRelation$
    \[ \varSigSchemeMP = (\procSetupPartSigId, \procGenPartSigId, \procVerfPartSigId, \procFinSigId) \]
    which allows us to distribute signature generation for a single public key between multiple parties owning parts of the key:
    \begin{itemize}
        \item $\procSetupPartSigId$ takes as input $\varSecParam$ with $\varN$ as the security parameter and randomly generates a key $\varKey$ together with additional randomness $\varRand$ as well
        as commitments to those. Participents are calling this algorithm once at the start of the protocol. Afterwards they collaborate to distribute commitments of their keys $\varGk$ and $\varGr$
        with each other.
        \item $\procGenPartSigId$ takes as input a to be signed message $\varMsg$, together with the key $\varKeyProv$ and randomness $\varRandProv$. Additionally commitments to the verifiers
        key and randomness $\funGen{\varKeyVerf}$ and $\funGen{\varRandVerf}$ has to be provided. The procedure outputs a partial signature, which can be verified by participating parties.
        \item $\procVerfPartSigId$ takes as input the same message $\varMsg$, the verifiers key $\varKeyVerf$ and randomness $\varRandVerf$ as well as the commitments provided by the prover
        $\funGen{\varKeyProv}$ and $\funGen{\varRandProv}$ of the prover. The algorithm outputs $1$ iff $\varSigPart$ is a valid signature on $\varMsg$ with regards to
        $\varKeyVerf \opSeperate \varRandVerf \opSeperate \funGen{\varKeyProv} \opSeperate \funGen{\varRandProv}$.
        \item $\procFinSigId$ will take the partial signatures and commitments to keys and randomness of the participants and create a final composite signature.
    \end{itemize}
\end{definition}

\fbox{
    \parbox{\textwidth}{
        \procedure[linenumbering, syntaxhighlight=auto]{$\procGenDefault$} {
            \varKey \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varRand \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \pcreturn (\varKey \opSeperate \varRand \opSeperate \funGen{\varKey} \opSeperate \funGen{\varRand})
        }
        \procedure[linenumbering, syntaxhighlight=auto]{$\procGenPartSigDefault$} {
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \funGen{\varKeyProv} \opAdd \funGen{\varKeyVerf} \opConc \funGen{\varRandProv} \opAdd \funGen{\varRandVerf}} \\
            \varSigPart \opAssign \varKeyProv \opAdd \varSchnorrChallenge \opAdd \varRandProv \\
            \pcreturn (\varSigPart)
        } \\[2\baselineskip]
        \procedure[linenumbering, syntaxhighlight=auto]{$\procVerfPartSigDefault$} {
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \funGen{\varKeyProv} \opAdd \funGen{\varKeyVerf} \opConc \funGen{\varRandProv} \opAdd \funGen{\varRandVerf}} \\
            \pcreturn \varGSigPart \opEq \funGen{\varKeyProv} \opAdd \funGen{\varSchnorrChallenge \opMult \varRandVerf}
        } \\[2\baselineskip]
        \procedure[linenumbering, syntaxhighlight=auto]{$\procFinSigDefault$} {
            \pcreturn (\varSigPart \opAdd \varSigPartSt \opSeperate \varGk \opAdd \varGkSt \opSeperate \varGr \opAdd \varGrSt)
        }
    }
}

\fbox{
    \parbox{\textwidth} {
        \procedure[linenumbering, syntaxhighlight=auto]{$\procAptSigDefault$} {
            \varSigPartApt \opAssign \varSigPart \opAdd \varWit \\
            \pcreturn (\varSigPartApt \opSeperate \varGWit)
        }
        \procedure[linenumbering, syntaxhighlight=auto]{$\procExtWitDefault$}{
            \varSigPartSt \opAssign \varSigFin \opSub \varSigPart \\
            \varWit \opAssign \varSigPartAptSt \opSub \varSigPartSt \\
            \pcreturn (\varWit)
        }\\
        \procedure[linenumbering, syntaxhighlight=auto]{$\procVrfAptDefault$} {
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varGk \opAdd \varGkSt \opConc \varGr \opAdd \varGrSt} \\
            \pcreturn \varGSigPartAptSt \opEq \varGkSt \opAdd \funGen{\varSchnorrChallenge \opMult \varRand} \opAdd \varGWit
        }
    }
}