In this chapter, we will define a variant of the adaptor signature scheme as explained in~\ref{sec:aptSignatures},
which is specifically tailored for the use in an Atomic Swap scenario in which (at least one side of the swap) uses a two-party protocol to generate transaction signatures and keypairs are fixed beforehand. \todo{This sentence is hard to parse}
We will start by defining the general two-party signature creation protocol as it is currently implemented in the Grin Cryptocurrency.
We reduce the generated signatures to the general case~\cite{schnorr1989efficient} and thereby prove its security. \todo[inline]{Do you really prove security of 2-party signatures?}
From this protocol, we then derive the adapted variant, which allows hiding a fixed witness
value in the signature, which can be revealed only by the other party after attaining the final signature.
We start by defining our extended signature scheme in section~\ref{sec:definitions}, proceed by providing a schnorr-based instantiation of the protocol in section~\ref{sec:schnorrInst} and finally prove its security in section~\ref{sec:twopartyAptSecurity}.

\section{Definitions}\label{sec:definitions}

\begin{definition}[Two Party Signature Scheme]
    \label{def:twoPartySig}
    A two-party signature scheme wrt. a hard relation $\cnstRelation$ is an extension of a signature scheme as defined in definition~\ref{def:signatureScheme}, which allows us to distribute signature generation for a composite public key shared between two parties Alice and Bob.
    Alice and Bob want to collaborate to generate a signature valid under the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice + \varPubKeyBob$ without having to reveal their secret keys to each other. For this we add three procedures to our signature scheme:

    \[ \varSigSchemeMP = (\varSigScheme \opConc \procSetupPartSigId \opSeperate \procGenPartSigId \opSeperate \procVerfPartSigId \opSeperate \procFinSigId) \]
    \begin{itemize}
        \item $\procSetupPartSigId$ takes as an input $\varSecParam$ with $\varN$ as the security parameter and randomly generates a nonce $\varNonce$ as well as a commitment $\varRand$ to the nonce which has to be distributed between Alice and Bob.
        Note that in this protocol, we assume Alice keypair $\varKeyPairAlice$, as well as Bob's keypair $\varKeyPairBob$ to be fixed so they can't be chosen arbitrarily. This circumstance is important because otherwise, the protocol would be vulnerable to a
        Rogue-Key Attack~\cite{horster1995meta}. As we have seen in section~\ref{sec:Mimblewimble}, the public keys in the Mimblewimble protocol to which the parties are signing are the so-called Kernel elements $\varKernel$ which are calculated from transaction elements
        rather then chosen.
        \item $\procGenPartSigId$ takes as input a to be signed message $\varMsg$ and generates a partial signature with Alice's key $\varSecKeyAlice$ and her nonce $\varNonceAlice$. This partial signature should only be verifiable by the second party and not necessarily
        has to be a fully valid signature already on its own.
        \item $\procVerfPartSigId$ lets Alice verify Bob's partial signature and vice versa.
        \item $\procFinSigId$ will take the two partial signatures as well as the randomness exchanged between the parties and create a valid signature which can be verified with the regular $\procVerfId$ function under the composite public key
        $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$. Note that the procedure will also create a new composite nonce commitment $\varRand \opAssign \varRandAlice \opAddPoint \varRandBob$ from the partial ones.
    \end{itemize}
\end{definition}

\todo[inline]{Here, you define a scheme which is independent on the realization later (i.e., Schnorr)}

\begin{definition}[Two Party Fixed Witness Adaptor Schnorr Signature Scheme]
    \label{def:twoPartyFixedWitAptSig}
    From the definition~\ref{def:twoPartySig}, we now derive an adapted signature scheme $\varSigSchemeApt$, which allows one of the participants to hide the discrete logarithm $\varWit$ of a statement $\varStatement$ chosen
    at the beginning of the protocol. Again we extend our previously defined signature scheme with new functions:
    \[ \varSigSchemeApt \opAssign (\varSigSchemeMP \opConc \procSetupAptId \opSeperate \procGenPtAptSigId \opSeperate \procVrfAptId \opSeperate \procExtWitId) \]
    \begin{itemize}
        \item $\procSetupAptId$ generates randomly a secret witness $\varWit$, which has to be kept private and is revealed to the other party by receiving the final composite signature. $\varStatement$ is distributed
        to the other party. In an Atomic Swap scenario between Alice and Bob (which we will describe in chapter~\ref{chp:atomicSwap}) Bob receiving $\varStatement$ should convince himself of its validity. (For example by verifying that
        there are indeed funds available to him if he gets the secret $\varWit$).
        \item $\procGenPtAptSigId$ allows Alice (knowing $\varWit$) to create a partial pre signature (similar to as defined in definition~\ref{def:twoPartySig}) which additionally hides the secret $\varWit$ without immediately revealing it.
        It outputs the partial pre signature, which can be verified to contain $\varWit$ by Bob (knowing $\varStatement$).
        \item $\procVrfAptId$ makes it possible to verify the validity of a partial pre signature plus that it indeed contains the secret witness of $\varStatement$.
        \item $\procFinAptSigId$ creates a final valid signature under the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ by adapting Bobs partial pre signature
        into Bobs final partial Signature with which we can then construct the final composite one.
        \item $\procExtWitId$ lets Alice extract the secret witness $\varWit$ from the final composite signature, her own partial signature $\varSigAlice$ and Bob's partial pre signature $\varSigAptBob$. She does
        so by first calculating Bob's adapted partial signature in which the witness is already removed. Knowing Bobs adapted partial signature as well as the presignature one, she
        can subtract those two to receive the secret $\varX$.
    \end{itemize}
\end{definition}

\begin{definition}[Secure Adaptor Signature Scheme]
    As defined by Aumayr et al. in~\cite{aumayr2020bitcoinchannels}, a secure adaptor signature scheme needs four security properties to be fulfilled:
    \begin{enumerate}
        \item \textit{pre-signature correctness}
        \item \textit{adapted existential unforgeability under choosen message attack}
        \item \textit{pre-signature adaptability}
        \item \textit{witness extractability}
    \end{enumerate}
\end{definition}

We proceed by redefining these properties for our adapted two-party fixed witness signature scheme defined in definition~\ref{def:twoPartyFixedWitAptSig}:

\begin{definition}[Pre-signature correctness]\label{def:preSigCorrectness}
Similar to how it is defined in~\cite{aumayr2020bitcoinchannels} additionally to \textit{correctness} we require our signature scheme to satisfy \textit{pre-signature correctness}.
This property is given when every presignature generated by $\procGenPtAptSigId$ can be completed into a final (partial) signature for all pairs $(\varWit \opSeperate \varStatement) \opIn \cnstRelation$, from which it will
be possible to extract the witness computing $\procExtWitId$ with the required parameters.
More formally \textit{pre-signature correctness} is given if for every security parameter $\varN \in \cnstNatural$, message $\varMsg \in \cnstBinary{*}$, fixed public keys $\varKeyPairAlice \opSeperate \varKeyPairBob$
with their composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ and every statement/witness pair $(\varStatement \opSeperate \varWit)$ in a relation $\cnstRelation$ it must hold that:
\begin{scriptsize}
    \[
        \Pr\left[
        \begin{array}{c}
            1.\:\procVerf{\varMsg}{\varSigFin}{\varPubKeyComp} \opEq 1 \\
            \opAnd \\
            2.\:\procVrfApt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varSigBob}{\varStatement} \opEq 1 \\
            \opAnd \\
            3.\:(\varStatement \opSeperate \funStar{\varWit} \opIn \cnstRelation)
        \end{array}
        \middle\vert
        \begin{array}{l}
            (\varNonceAlice \opSeperate \varRandAlice) \opFunResult \procSetupPartSig{\varSecParam} \\
            ((\varNonceBob \opSeperate \varRandBob) \opSeperate (\varWit \opSeperate \varStatement)) \opFunResult \procSetupApt{\varSecParam} \\
            \varSigAptBob \opFunResult \procGenPtAptSig{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varPubKeyAlice}{\varRandAlice}{\varWit} \\
            \varSigAlice \opFunResult \procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob} \\
            \varSigFin \opFunResult \procFinAptSig{\varSigAlice}{\varSigAptBob}{\varRandAlice}{\varRandBob}{\varWit} \\
            \funStar{\varWit} \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}
        \end{array}
        \right]=1.
    \]
\end{scriptsize}
\end{definition}

\begin{definition}[$\cnstaEUFCMA$]\label{def:aeufcma}
Additionally to the regular definition of \textit{existential unforgeability under chosen message attacks} as defined for example in~\cite{vaudenay2006classical} we additionally require that it is hard to produce a forged partial signature $\varSigPart$ if the
adversary $\cnstAdversary$ gets to know a valid pre signature $\varSigPartApt$ w.r.t. some message $\varMsg$ and a statement $\varStatement$.

For the definition of $\cnstaEUFCMA$-security we define the experiment $\procExpForgId$ for a $\cnstPolyTime$ adversary $\cnstAdversary$ with a fixed keypair $(\varSecKeyAdv \opSeperate \varPubKeyAdv)$ and an adapted signature scheme $\varSigSchemeApt$ as
follows:

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procExpForg{\varN}$} {
        \varSet \opAssign \cnstEmptySet \\
        (\varNonceAdv \opSeperate \varRandAdv) \opFunResult \procSetupPartSig{\varSecParam} \\
        \varMsg \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\varSecKey}{\varPubKey}}(\varPubKeyAdv \opSeperate \varRandAdv) \\
        \varSigPartApt \opFunResult \procGenPtAptSig{\varMsg}{\varSecKey}{\varNonce}{\varPubKeyAdv}{\varRandAdv}{\varWit} \\
        \varSigPart \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\varSecKey}{\varPubKey}}(\varSigPartApt) \\
        \varSigFin \opFunResult \procFinAptSig{\varSigPart}{\varSigPartApt}{\varWit}{\varRand}{\varRandAdv} \\
        \pcreturn (\varMsg \opNotIn \varSet \opAnd \procVerf{\varMsg}{\varSigFin}{\varPubKeyAdv \opAddPoint \varPubKey})
        }\\[2\baselineskip]
        \procedure[linenumbering]{$\procSignOracle{\varMsg}{\varPubKeyAdv}{\varRandAdv}$} {
        \varSet \opAssign \varSet \opUnion {\varMsg} \\
        ((\varNonce \opSeperate \varRand) \opSeperate (\varWit \opSeperate \varStatement)) \opFunResult \procSetupApt{\varSecParam} \\
        \pcreturn \procGenPtAptSig{\varMsg}{\varSecKey}{\varNonce}{\varPubKeyAdv}{\varRandAdv}{\varWit}
        }\\[2\baselineskip]
    \end{varwidth}
    }
\end{center}
The adapted signature scheme $\varSigSchemeApt$ is called $\cnstaEUFCMA$-secure if
\[ \prob{\procExpForg{\varN} \opEq 1} \opSmEq \funNegl{n} \]
\end{definition}

\begin{definition}[Pre-signature adaptability]
    Informally \textit{pre-signature adaptability} means that any valid partial pre-signature together with a valid corresponding partial signature from the other party can
    always be completed into a valid final composite signature by using the $\procFinAptSigId$ procedure.

    Formally for any security parameter $\varN$, message $\varMsg \opIn \cnstBinary{*}$, valid fixed keypairs $\varKeyPairAlice \opSeperate \varKeyPairBob$ and the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$,
    valid partial pre-signature $\varSigAptBob$ and valid partial signature $\varSigAlice$ the following must hold:
    \begin{scriptsize}
        \[
            \Pr\left[
            \begin{array}{c}
                \procVerf{\varMsg}{\procFinAptSig{\varSigAlice}{\varSigAptBob}{\varWit}{\varRandAlice}{\varRandBob}}{\varPubKeyComp} \opEq 1
            \end{array}
            \middle\vert
            \begin{array}{l}
                (\varNonceAlice \opSeperate \varRandAlice) \opFunResult \procSetupPartSig{\varSecParam} \\
                (\varNonceBob \opSeperate \varRandBob) \opSeperate (\varWit \opSeperate \varStatement) \opFunResult \procSetupApt{\varSecParam} \\
                \procVerfPartSig{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varPubKeyAlice}{\varRandAlice}{\varSigAlice} \opEq 1 \\
                \procVrfApt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varStatement}{\varSigAptBob} \opEq 1
            \end{array}
            \right]=1.
        \]
    \end{scriptsize}
    This definition might seem very similar to \textit{pre-signature correctness} defined in definition~\ref{def:preSigCorrectness}; however it is slightly stronger as it requires that all partial signatures and partial pre-signatures can be completed
    into a valid signature, as long as they are valid themselves. This would also include a partial signature that were created maliciously.
\end{definition}

\begin{definition}[Witness extractability]
    Informally the \textit{witness extractability} property holds for an adapted signature scheme $\varSigSchemeApt$ computed for the statement $\varStatement$ when we can always extract the witness
    $(\varWit \opSeperate \varStatement)$ from the final signature $\varSigFin$, partial presignature $\varSigPartAdv$ and corresponding partial signature $\varSigBob$.
    To formalize this statement we describe an experiment $\procExpExtId$ for a $\cnstPolyTime$ adversary $\cnstAdversary$ with a fixed keypair $(\varSecKeyAdv \opSeperate \varPubKeyAdv)$
    and the fixed keypair $\varKeyPairBob$ of the second party.

    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procExpExt{\varN}$} {
            \varSet \opAssign \cnstEmptySet \\
            (\varNonceAdv \opSeperate \varRandAdv) \opFunResult \procSetupPartSig{\varSecParam} \\
            (\varMsg \opSeperate \varStatement) \opFunResult \cnstAdversary^{\procNonceOracle{\cdot},\procSignPtOracle{\cdot}{\varPubKeyAdv}{\varRandAdv}}(\varPubKeyAdv \opSeperate \varRandAdv) \\
            \varSigPartAdv \opFunResult \procGenPtAptSig{\varMsg}{\varSecKeyAdv}{\varNonceAdv}{\varPubKeyBob}{\varRandBob}{\varWit} \\
            (\varSigBob) \opFunResult \cnstAdversary^{\procNonceOracle{\cdot},\procSignPtOracle{\cdot}{\varPubKeyAdv}{\varRandAdv}}(\varPubKeyAdv \opSeperate \varRandAdv \opSeperate \varSigPartAdv) \\
            \varSigFin \opFunResult \procFinAptSig{\varSigPartAdv}{\varSigBob}{\varRandAdv}{\varRandBob}{\varWit} \\
            \funStar{\varWit} \opFunResult \procExtWit{\varSigFin}{\varSigBob}{\varSigPartAdv} \\
            \pcreturn (\varMsg \opNotIn \varSet \opAnd (\varStatement \opSeperate \funStar{\varWit}) \opNotIn \cnstRelation \opAnd \procVerf{\varMsg}{\varSigFin}{\varPubKeyAdv \opAddPoint \varPubKeyBob})
            }\\

            \procedure[linenumbering]{$\procNonceOracle{\varSecParam}$} {
            (\varNonceBob \opSeperate \varRandBob) \opFunResult \procSetupPartSig{\varSecParam} \\
            \pcreturn \varRandBob
            }
            \procedure[linenumbering]{$\procSignPtOracle{\varMsg}{\varPubKeyAdv}{\varRandAdv}$} {
            \varSet \opAssign \varSet \opUnion \varMsg \\
            \pcreturn \procGenPartSig{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varPubKeyAdv}{\varRandAdv}
            }
        \end{varwidth}
        }
    \end{center}
    In order to satisfy witness extractability the following must hold:
    \[ \prob{\procExpExt{\varN} \opEq 1} \opSmEq \funNegl{\varN} \]
\end{definition}

\section{Schnorr-based instantiation}\label{sec:schnorrInst}

We start by providing a general instantiation of a signature scheme (see definition~\ref{def:signatureScheme}):
We assume we have a group $\cnstGroup$ with prime $\varPrime$, $\cnstHash$ is a secure hash function as defined in definition~\ref{def:hashFunction} and $\varMsg$ is a publicly known message.

\begin{itemize}
    \item $\procSetupId$ creates a keypair $\varKeyPair$, the public key can be distributed to the verifier(s) and the secret key has to be kept private. \\
    \item $\procSignId$ creates a signature consisting of a variable $\varS$ and generator $\varG$ raised to the nonce used during the signing process $\funGen{\varNonce}$.
    \item $\procVerfId$ allows a verifier knowing the signature $\varSignature$ and the provers public key $\varPubKey$ to verify the signatures validity. \\
\end{itemize}
The concrete implementation can be seen in figure~\ref{fig:schnorr}. The signature scheme is called schnorr signature scheme, first defined in~\cite{schnorr1989efficient} and is widely employed in many cryptography systems.
\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSetup{\varSecParam}$} {
            \varKey \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \pcreturn (\varSecKey \opAssign \varKey \opSeperate \varPubKey \opAssign \funGen{\varKey})
            }
            \procedure[linenumbering]{$\procSign{\varMsg}{\varSecKey}$}{
            \varNonce \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varRand \opAssign \funGen{\varNonce} \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \varS \opAssign \varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey \\
            \pcreturn \varSignature \opAssign (\varS, \varRand)
            }
            \procedure[linenumbering]{$\procVerf{\varMsg}{\varSignature}{\varPubKey}$} {
            \varS \opAssign \opAccess{\varSignature}{\varS} \\
            \varRand \opAssign \opAccess{\varSignature}{\varRand} \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varS} \opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKey
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Schnorr Signature Scheme as first defined in~\cite{schnorr1989efficient}}
    \label{fig:schnorr}
\end{figure}
\textit{Correctness} of the scheme is easy to derive. As $\varS$ is calculated as $\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey$, when generator $\varG$ is raised to $\varS$, we get
$\funGen{\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey}$ which we can transform into $\funGen{\varNonce} \opAddPoint \funGen{\varSecKey \opTimesScalar \varSchnorrChallenge}$, and finally
into $\varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}$ which is the same as the right side of the equation.

From the regular schnorr signature we now provide an instantiation for the two-party case defined in definition~\ref{def:twoPartySig} in figure~\ref{fig:twoparty-schnorr}. Note that this two-party variant of the scheme is what is
currently implemented in the Grin Mimblewimble Cryptocurrency and will provide a basis from which we will build our adapted scheme.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSetupPartSig{\varSecParam}$}{
            \varNonce \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varRand \opAssign \funGen{\varRand} \\
            \pcreturn (\varNonce \opSeperate \varRand)
            }
            \procedure[linenumbering]{$\procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}$} {
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRandAlice \opAddPoint \varRandBob \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob} \\
            \varS \opAssign \varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice \\
            \pcreturn \varSigAlice \opAssign \varS
            } \\
            \procedure[linenumbering]{$\procVerfPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varSigBob}$} {
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRandAlice \opAddPoint \varRandBob \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob} \\
            \varS \opAssign \opAccess{\varSigBob}{\varS} \\
            \pcreturn \funGen{\varS} \opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob
            } \\
            \procedure[linenumbering]{$\procFinSig{\varSigAlice}{\varSigBob}{\varRandAlice}{\varRandBob}$} {
            \varS_\varAlice \opAssign \opAccess{\varSigAlice}{\varS} \\
            \varS_\varBob \opAssign \opAccess{\varSigBob}{\varS} \\
            \pcreturn \varSigFin \opAssign (\varS \opAssign \varS_\varAlice \opAddScalar \varS_\varBob \opSeperate \varRand \opAssign \varRandAlice \opAddPoint \varRandBob)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Two Party Schnorr Signature Scheme}
    \label{fig:twoparty-schnorr}
\end{figure}

We further show in figure~\ref{fig:twoparty-schnorr-prot} how Alice and Bob can cooperate to produce a final signature which fulfills \textit{Correctness} as defined in definition~\ref{def:signatureScheme}.

\begin{figure}
    \centering
    \pseudocode[codesize=\scriptsize]{
    \textbf{Alice} \< \< \textbf{Bob} \\ [][\hline]
    \< \<  \\
    \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
    \< \text{Fixed Parameters: } \varKeyPairAlice \opSeperate \varKeyPairBob \< \\
    (\varNonceAlice \opSeperate \varRandAlice) \opFunResult \procSetupPartSig{\varSecParam} \< \< \\
    \< \sendmessageright{ top=$(\varPubKeyAlice \opSeperate \varRandAlice)$ } \< \\
    \< \< (\varNonceBob \opSeperate \varRandBob) \opFunResult \procSetupPartSig{\varSecParam} \\
    \< \< \varSigBob \opFunResult \procGenPartSig{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varPubKeyAlice}{\varRandAlice} \\
    \< \sendmessageleft{ top=$(\varSigBob \opSeperate \varPubKeyBob \opSeperate \varRandBob)$ } \< \\
    \procVerfPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varSigBob} \opEq 1\< \< \\
    \varSigAlice \opFunResult \procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob} \< \< \\
    \< \sendmessageright{ top=$(\varSigAlice)$ } \< \\
    \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob}{\varRandAlice}{\varRandBob} \\
    }
    \caption{Two Party Schnorr Signature Scheme Interaction}
    \label{fig:twoparty-schnorr-prot}
\end{figure}

The final signature is a valid signature to the message $\varMsg$ with the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$.
A verifier knowing the signed message $\varMsg$, the final signature $\varSigFin$ and the composite public key $\varPubKeyComp$ can now verify the signature using the $\procVerfId$ procedure.
The challenge $\varSchnorrChallenge$ will be the same because
\[ \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \opEq \funHash{\varMsg \opConc \varRandAlice \opAddPoint \varRandBob \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob} \]
\textit{Correctness} is proven by showing
that for partial signatures $\varSigAlice$ and $\varSigBob$:
\[ \procVerf{\varMsg}{\procFinSig{\varSigAlice}{\varSigBob}{\varRandAlice}{\varRandBob}}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1 \]

\begin{proof}
    \label{prf:twopartySchnorr}
    The proof is by showing equality of the equation checked by the verifier by continous substitutions in the left side of equation:
    \begin{align}
        \funGen{\varS} &\opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp \\
        \funGen{\varSAlice} \opAddPoint \funGen{\varSBob} & \\
        \funGen{\varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob} & \\
        \funGen{\varNonceAlice \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyBob} & \\
        \opPointScalar{\varRandAlice}{\varSchnorrChallenge} \opAddPoint \varPubKeyAlice \opAddPoint \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob & \\
        \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp & \opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp
    \end{align}
\end{proof}

In figure~\ref{fig:aptSchnorr} we further provide a schnorr-based instantiation for the fixed witness adapted signature scheme as defined in definition~\ref{def:twoPartyFixedWitAptSig}:

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSetupApt{\varSecParam}$} {
            (\varNonce \opSeperate \varRand) \opFunResult \procSetupPartSig{\varSecParam} \\
            \varWit \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varStatement \opAssign \funGen{\varWit} \\
            \pcreturn ((\varNonce \opSeperate \varRand)\opSeperate (\varWit, \varStatement))
            }
            \procedure[linenumbering]{$\procGenPtAptSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varWit}$}{
            \varSigBob \opFunResult \procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob} \\
            \varS \opAssign \opAccess{\varSigBob}{\varS} \opAddScalar \varWit \\
            \pcreturn \varSigAptAlice \opAssign (\varS \opSeperate \varStatement)
            } \\
            \procedure[linenumbering]{$\procVrfApt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varStatement}{\varSigAptBob}$} {
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob \opConc \varRandAlice \opAddPoint \varRandBob} \\
            \pcreturn \funGen{\varSigAptBob} \opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \funGen{\varWit}
            }
            \procedure[linenumbering]{$\procFinAptSig{\varSigAlice}{\varSigAptBob}{\varRandAlice}{\varRandBob}{\varWit}$}{
            \varSigBob \opAssign \varSigAptBob \opSub \varWit \\
            \pcreturn \procFinSig{\varSigAlice}{\varSigBob}{\varRandAlice}{\varRandBob}
            } \\
            \procedure[linenumbering]{$\procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}$}{
            \varSigBob \opAssign \varSigFin \opSub \varSigAlice \\
            \varWit \opAssign \varSigAptBob \opSub \varSigBob \\
            \pcreturn (\varWit)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Fixed Witness Adaptor Schnorr Signature Scheme}
    \label{fig:aptSchnorr}
\end{figure}

Again in figure~\ref{fig:aptSchnorrInteraction} we show an interaction between Alice and Bob creating a signature $\varSigFin$ for the composite public key $\varPubKeyBob \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$
while Bob will hide his secret $\varWit$ which Alice can extract after the signing process has completed.

\begin{figure}
    \pseudocode[codesize=\scriptsize]{
    \textbf{Alice} \< \< \textbf{Bob} \\ [][\hline]
    \< \<  \\
    \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
    \< \text{Fixed Parameters: } \varKeyPairAlice \opSeperate \varKeyPairBob \< \\
    (\varNonceAlice \opSeperate \varRandAlice) \opFunResult \procSetupPartSig{\varSecParam} \< \< \\
    \< \sendmessageright{ top=$(\varPubKeyAlice \opSeperate \varRandAlice)$ } \< \\
    \< \< ((\varNonceBob \opSeperate \varRandBob) \opSeperate (\varWit \opSeperate \varStatement)) \opFunResult \procSetupApt{\varSecParam} \\
    \< \< \varSigAptBob \opFunResult \procGenPtAptSig{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varPubKeyAlice}{\varRandAlice}{\varWit} \\
    \< \sendmessageleft{ top=$(\varSigBob \opSeperate \varPubKeyBob \opSeperate \varRandBob \opSeperate \varStatement)$ } \< \\
    \procVrfApt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varSigBob}{\varStatement} \opEq 1\< \< \\
    \varSigAlice \opFunResult \procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob} \< \< \\
    \< \sendmessageright{ top=$(\varSigAlice)$ } \< \\
    \< \< \varSigFin \opFunResult \procFinAptSig{\varSigAlice}{\varSigAptBob}{\varRandAlice}{\varRandBob}{\varWit} \\
    }
    \caption{Fixed Witness Adaptor Schnorr Signature Interaction}
    \label{fig:aptSchnorrInteraction}
\end{figure}

\section{Security}\label{sec:twopartyAptSecurity}

We now show that the outlined instantiation is secure with regards to the regular signature scheme definition~\ref{def:signatureScheme} and the adaptor signature scheme definition~\ref{def:twoPartyFixedWitAptSig}.
We start by proving \textit{correctness} of the scheme by showing that for a partial signature $\varSigAlice$ and a corresponding pre-signature $\varSigAptBob$
the following must hold
\[ \procVerf{\varMsg}{\procFinAptSig{\varSigAlice}{\varSigAptBob}{\varRandAlice}{\varRandBob}{\varWit}}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1 \]
\begin{proof}
    \label{prf:aptSchnorr}
    Again the proof is by continous substitutions in the equation checked by the verifier:
    \begin{align}
        \funGen{\varS} &\opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyCompApt \\
        \funGen{\varSAlice \opAddScalar \varSBob \opSub \varWit} & \\
        \funGen{\varSAlice} \opAddPoint \funGen{\varSBob \opSub \varWit} & \\
        \funGen{\varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob \opAddScalar \varWit \opSub \varWit} & \\
        \funGen{\varNonceAlice} \opAddPoint \funGen{\varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob} \opAddPoint \funGen{\varSchnorrChallenge \opTimesScalar \varSecKeyBob} & \\
        \opPointScalar{\varRandAlice}{\varSchnorrChallenge} \opAddPoint \varPubKeyAlice \opAddPoint \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob & \\
        \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp & \opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp
    \end{align}
\end{proof}

Next we provide a proof that in addition to regular \textit{correctness} also \textit{pre-signature correctness} holds.
Note that we have 3 statements to prove, we have already proven that $\procVerf{\varMsg}{\varSigFin}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1$ holds in our instantiation of the signature scheme in the
correctness proof~\ref{prf:aptSchnorr}.
It remains to prove that $\procVrfApt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varSigBob}{\varStatement} \opEq 1$ and
$(\varStatement \opSeperate \funStar{\varWit} \opIn \cnstRelation)$.

\begin{proof}
    \label{prf:aptSchnorrPreSigCorr}
    For this prove we assume the setup already specified in definition~\ref{def:preSigCorrectness}.
    First we prove that the following statement:
    \[
        \procVrfApt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varStatement}{\varSigAptBob} \opEq 1
    \]
    The proof is by continuous substitutions in the equation checked by the verifier:
    \begin{align}
        \funGen{\varSigAptBob} &\opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement \\
        \funGen{\varSigBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyBob} \opAddScalar \funGen{\varWit} & \\
        \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement &\opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement \\
        1 &\opEq 1
    \end{align}
    We now continue to prove the last equation required:
    \[
        (\varStatement \opSeperate \funStar{\varWit} \opIn \cnstRelation)
    \]
    To prove correctness we show that $\varWit$ is calculated correctly in $\procExtWitId$:
    \begin{align}
        \varWit \opAssign & \varSigAptBob \opSub (\varSigFin \opSub \varSigAlice) \\
        & \varSigAptBob \opSub ((\varSAlice \opAddScalar \varSBob ) \opSub \varSAlice ) \\
        & \varSBob \opAddScalar \varWit \opSub (\varSBob) \\
        \varWit \opAssign & \varWit \\
    \end{align}

\end{proof}

TODO Proof for pre-signature adaptability, $\cnstaEUFCMA$ and witness extractability.