In this chapter, we will define a variant of the adaptor signature scheme as explained in~\ref{sec:aptSignatures},
which is specifically tailored for the use in an Atomic Swap scenario in which (at least one side of the swap) uses a two-party protocol to generate transaction signatures and keypairs are fixed beforehand.

First we will define the general two-party signature creation protocol as it is currently implemented for example in the Grin Cryptocurrency.
We reduce the generated signatures to the general case~\cite{schnorr1989efficient} and thereby prove its correctness.
From this protocol, we then derive the adapted variant, which allows hiding a fixed witness
value in the signature, which can be revealed only by the other party after attaining the final signature.
We start by defining our extended signature scheme in section~\ref{sec:definitions}, proceed by providing a schnorr-based instantiation of the protocol in section~\ref{sec:schnorrInst} and finally prove its security in section~\ref{sec:twopartyAptSecurity}.

\section{Definitions}\label{sec:definitions}

\begin{definition}[Two Party Signature Scheme]
    \label{def:twoPartySig}
    A two-party signature scheme wrt. a hard relation $\cnstRelation$ is an extension of a signature scheme as defined in definition~\ref{def:signatureScheme}, which allows us to distribute signature generation for a composite public key shared between two parties Alice and Bob.
    Alice and Bob want to collaborate to generate a signature valid under the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice + \varPubKeyBob$ without having to reveal their secret keys to each other. For this we add three procedures to our signature scheme definition:

    \[ \varSigSchemeMP = (\varSigScheme \opConc \procSignPtId \opSeperate \procVerfPtSigId \opSeperate \procFinSigId) \]
    \begin{itemize}
        \item $\procSignPtId$ is defined as a two-party procedure which requires both Alice and Bob to provide their secret key and a message which should be signed. The parties collaborate to both calculate their own partial signatures. These partial signatures do not need to be valid signatures yet, but the other participating parties need to be able to verify them using the $\procVerfPartSigId$ procedure.
        \item $\procVerfPartSigId$ Is a function which lets one party verify the partial signature of the other party. As input it requires the partial signature, signed message and the public key of the other party. The output will be either 1 if the verification was successfull or 0 otherwise.
        \item $\procFinSigId$ will take the two partial signatures and combine them into a final valid signature under the participants composite public key.
    \end{itemize}
\end{definition}

\begin{definition}[Two Party Fixed Witness Adaptor Schnorr Signature Scheme]
    \label{def:twoPartyFixedWitAptSig}
    From the definition~\ref{def:twoPartySig}, we now derive an adapted signature scheme $\varSigSchemeApt$, which allows one of the participants to hide the discrete logarithm $\varWit$ of a statement $\varStatement$ chosen
    at the beginning of the protocol. Again we extend our previously defined signature scheme with new functions:
    \[ \varSigSchemeApt \opAssign (\varSigSchemeMP \opConc \procAptSigId \opConc \procVerifyAptSigId \opConc \procExtWitId) \]
    \begin{itemize}
        \item $\procAptSigId$ takes as input a partial signature $\varSigPt$ and a secret witness value $\varWit$. The procedure will output an adapted partial signature $\varSigApt$ which can be verified to contain $\varWit$ using the $\procVerifyAptSigId$ function, without immidiately revealing $\varWit$.
        \item $\procVerifyAptSigId$ takes as input an adapted partial signature $\varSigApt$, public key $\varPubKey$ and a statement $\varStatement$. The function will verify the partial signature's validity as well that it contains the secret witness $\varWit$.
        \item $\procExtWitId$ lets Alice extract the secret witness $\varWit$ from the final composite signature. Note that to extract the witness $\varWit$ the partial signatures shared between the participants beforehand and the statement $\varStatement$ needs to be provided as inputs. This makes sure that only participants of the procotol will be able to do the extraction.
    \end{itemize}
\end{definition}

\begin{definition}[Secure Adaptor Signature Scheme]
    As defined by Aumayr et al. in~\cite{aumayr2020bitcoinchannels}, a secure adaptor signature scheme needs four security properties to be fulfilled:
    \begin{enumerate}
        \item \textit{pre-signature correctness}
        \item \textit{adapted existential unforgeability under choosen message attack}
        \item \textit{pre-signature adaptability}
        \item \textit{witness extractability}
    \end{enumerate}
\end{definition}

We proceed by redefining these properties for our adapted two-party fixed witness signature scheme defined in definition~\ref{def:twoPartyFixedWitAptSig}:

\begin{definition}[Pre-signature correctness]\label{def:preSigCorrectness}
Similar to how it is defined in~\cite{aumayr2020bitcoinchannels} additionally to \textit{correctness} we require our signature scheme to satisfy \textit{pre-signature correctness}.
This property is given when every adapted partial signature generated by $\procAptSigId$ can be completed into a final signature for all pairs $(\varWit \opSeperate \varStatement) \opIn \cnstRelation$, from which it will
be possible to extract the witness computing $\procExtWitId$ with the required parameters.

More formally \textit{pre-signature correctness} is given if for every security parameter $\varN \in \cnstNatural$, message $\varMsg \in \cnstBinary{*}$, keypairs $\varKeyPairAlice \opSeperate \varKeyPairBob$
with their composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ and every statement/witness pair $(\varStatement \opSeperate \varWit)$ in a relation $\cnstRelation$ it must hold that:
\[
    \Pr\left[
    \begin{array}{c}
        1.\:\procVerf{\varMsg}{\varSigFin}{\varPubKeyComp} \opEq 1 \\
        \opAnd \\
        2.\: \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEq 1 \\
        \opAnd \\
        3.\:(\varStatement \opSeperate \funStar{\varWit} \opIn \cnstRelation)
    \end{array}
    \middle\vert
    \begin{array}{l}
        (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
        (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
        \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
        \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
        \funStar{\varWit} \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}
    \end{array}
    \right]=1.
\]
\end{definition}

\begin{definition}[$\cnstaEUFCMA$]\label{def:aeufcma}
Additionally to the regular definition of \textit{existential unforgeability under chosen message attacks} as defined for example in~\cite{vaudenay2006classical} we require that it is hard to produce a forged partial signature $\varSigPt$ if the
adversary $\cnstAdversary$ gets to know a valid adapted signature $\varSigApt$ w.r.t. some message $\varMsg$ and a statement $\varStatement$.

For the definition of $\cnstaEUFCMA$-security we define the experiment $\procExpForgId$ for a $\cnstPolyTime$ adversary $\cnstAdversary$ with a fixed keypair $(\varSecKeyAdv \opSeperate \varPubKeyAdv)$ and an adapted signature scheme $\varSigSchemeApt$ as
follows:

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procExpForg{\varN}$} {
        \varSet \opAssign \cnstEmptySet \\
        \varMsg \opFunResult \cnstAdversary^{\procSignOracle{\cdot}}(\varPubKeyAdv) \\
        (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
        \varSigBob \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyBob} \\
        \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
        \varSigPt_{\cnstAdversary} \opFunResult \cnstAdversary^{\procSignOracle{\cdot}}(\varSigApt) \\
        \varSigFin \opFunResult \procFinSig{\varSigPt_{\cnstAdversary}}{\varSigBob} \\
        \pcreturn (\varMsg \opNotIn \varSet \opAnd \procVerf{\varMsg}{\varSigFin}{\varPubKeyAdv \opAddPoint \varPubKey})
        }\\[2\baselineskip]
        \procedure[linenumbering]{$\procSignOracle{\varMsg}$} {
        \varSet \opAssign \varSet \opUnion {\varMsg} \\
        (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
        \varSigPt \opFunResult \procSignPtSingle{\varMsg}{\varSecKey} \\
        \varSigApt \opFunResult \procAptSig{\varSigPt}{\varWit} \\
        \pcreturn (\varSigApt \opSeperate \varStatement)
        }\\[2\baselineskip]
    \end{varwidth}
    }
\end{center}
The adapted signature scheme $\varSigSchemeApt$ is called $\cnstaEUFCMA$-secure if
\[ \prob{\procExpForg{\varN} \opEq 1} \opSmEq \funNegl{n} \]
\end{definition}

\begin{definition}[Pre-signature adaptability]
    Informally \textit{pre-signature adaptability} means that for any adapted partial signature $\varSigApt$ its unadapted variant $\varSigPt$ can always be completed into a final valid signature given the partial signature of the other party.

    Formally for any security parameter $\varN$, message $\varMsg \opIn \cnstBinary{*}$, valid fixed keypairs $\varKeyPairAlice \opSeperate \varKeyPairBob$ and the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$,
    valid adapted partial signature $\varSigAptBob$ and valid partial signature $\varSigAlice$ the following must hold:

    \[
        \Pr\left[
        \begin{array}{c}
            \procVerf{\varMsg}{\procFinSig{\varSigAlice}{\varSigBob}}{\varPubKeyComp} \opEq 1
        \end{array}
        \middle\vert
        \begin{array}{l}
            (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
            (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
            \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
            \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEq 1 \\
        \end{array}
        \right]=1.
    \]

    This definition might seem very similar to \textit{pre-signature correctness} defined in definition~\ref{def:preSigCorrectness}; however it is slightly stronger as it requires that all partial signatures and adapted partial signatures can be completed
    into a valid signature, as long as they are valid themselves. This would also include a partial signature that was created maliciously.
\end{definition}

\begin{definition}[Witness extractability]
    Informally the \textit{witness extractability} property holds for an adapted signature scheme $\varSigSchemeApt$ computed for the statement $\varStatement$ when we can always extract the witness
    $(\varWit \opSeperate \varStatement)$ from the final signature $\varSigFin$, given the partial signatures of the participants.
    To formalize this statement we describe an experiment $\procExpExtId$ for a $\cnstPolyTime$ adversary $\cnstAdversary$ with a fixed keypair $(\varSecKeyAdv \opSeperate \varPubKeyAdv)$
    and the fixed keypair $\varKeyPairBob$ of a second party.

    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procExpExt{\varN}$} {
            \varSet \opAssign \cnstEmptySet \\
            (\varMsg \opSeperate \varStatement) \opFunResult \cnstAdversary^{\procSignPtOracle{\cdot}}(\varPubKeyAdv) \\
            (\varSigPtAdv \opSeperate \varSigBob)\opFunResult \procSignPt{\varMsg}{\varSecKeyAdv}{\varSecKeyBob} \\
            \varSigAptAdv \opFunResult \cnstAdversary^{\procSignPtOracle{\cdot}}(\varPubKeyAdv \opSeperate \varSigPtAdv) \\
            \varSigFin \opFunResult \procFinSig{\varSigPtAdv}{\varSigBob} \\
            \funStar{\varWit} \opFunResult \procExtWit{\varSigFin}{\varSigBob}{\varSigAptAdv} \\
            \pcreturn (\varMsg \opNotIn \varSet \opAnd (\varStatement \opSeperate \funStar{\varWit}) \opNotIn \cnstRelation \opAnd \procVerf{\varMsg}{\varSigFin}{\varPubKeyAdv \opAddPoint \varPubKeyBob})
            }\\

            \procedure[linenumbering]{$\procSignPtOracle{\varMsg}$} {
            \varSet \opAssign \varSet \opUnion \varMsg \\
            \varSigPt \opFunResult \procSignPtSingle{\varMsg}{\varSecKey} \\
            \pcreturn \varSigPt
            }
        \end{varwidth}
        }
    \end{center}
    In order to satisfy witness extractability the following must hold:
    \[ \prob{\procExpExt{\varN} \opEq 1} \opSmEq \funNegl{\varN} \]
\end{definition}

\section{Schnorr-based instantiation}\label{sec:schnorrInst}

We start by providing a general instantiation of a signature scheme (see definition~\ref{def:signatureScheme}):
We assume we have a group $\cnstGroup$ with prime $\varPrime$, $\cnstHash$ is a secure hash function as defined in definition~\ref{def:hashFunction} and $\varMsg \opIn \cnstBinary{*}$ is a message.

\begin{itemize}
    \item $\procSetupId$ creates a keypair $\varKeyPair$, the public key can be distributed to the verifier(s) and the secret key has to be kept private. \\
    \item $\procSignId$ creates a signature consisting of a variable $\varS$ and $\varRand$ which is a commitment to the secret nonce $\varNonce$ used during the signing process.
    \item $\procVerfId$ allows a verifier knowing the signature $\varSignature$, message $\varMsg$ and the provers public key $\varPubKey$ to verify the signatures validity. \\
\end{itemize}
A concrete implementation can be seen in figure~\ref{fig:schnorr}. The signature scheme is called schnorr signature scheme, first defined in~\cite{schnorr1989efficient} and is widely employed in many cryptography systems.
\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSetup{\varSecParam}$} {
            \varKey \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \pcreturn (\varSecKey \opAssign \varKey \opSeperate \varPubKey \opAssign \funGen{\varKey})
            }
            \procedure[linenumbering]{$\procSign{\varMsg}{\varSecKey}$}{
            \varNonce \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varRand \opAssign \funGen{\varNonce} \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \varS \opAssign \varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey \\
            \pcreturn \varSignature \opAssign (\varS, \varRand)
            }
            \procedure[linenumbering]{$\procVerf{\varMsg}{\varSignature}{\varPubKey}$} {
            (\varS \opSeperate \varRand) \opFunResult \varSignature \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varS} \opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKey
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Schnorr Signature Scheme as first defined in~\cite{schnorr1989efficient}}
    \label{fig:schnorr}
\end{figure}
\textit{Correctness} of the scheme is easy to derive. As $\varS$ is calculated as $\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey$, when generator $\varG$ is raised to $\varS$, we get
$\funGen{\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey}$ which we can transform into $\funGen{\varNonce} \opAddPoint \funGen{\varSecKey \opTimesScalar \varSchnorrChallenge}$, and finally
into $\varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}$ which is the same as the right side of the equation.

From the regular schnorr signature we now provide an instantiation in figure~\ref{fig:twoparty-schnorr} for the two-party case defined in definition~\ref{def:twoPartySig}. Note that this two-party variant of the scheme is what is
currently implemented in the Grin Mimblewimble Cryptocurrency and will provide a basis from which we will build our adapted scheme.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob}$} {
            \varNonceAlice \sample \cnstIntegersPrimeWithoutZero{\varSecParam} \< \< \varNonceBob \sample \cnstIntegersPrimeWithoutZero{\varSecParam} \\
            \varRandAlice \opAssign \funGen{\varNonceAlice} \< \< \varRandBob \opAssign \funGen{\varNonceBob} \\
            \< \sendmessageright*{\varRandAlice} \< \\
            \< \sendmessageleft*{\varRandBob} \< \\
            \varRand \opAssign \varRandAlice \opAddPoint \varRandBob \< \< \varRand \opAssign \varRandAlice \opAddPoint \varRandBob \\
            \varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob \< \< \varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \< \< \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \\
            \varSAlice \opAssign \varNonceAlice \opAddScalar \varSecKeyAlice \opTimesScalar \varSchnorrChallenge \< \< \varSBob \opAssign \varNonceBob \opAddScalar \varSecKeyBob \opTimesScalar \varSchnorrChallenge \\
            \varSigAlice \opAssign (\varSAlice, \varRandAlice) \< \< \varSigBob \opAssign (\varSBob, \varRandBob) \\
            \pcreturn (\varSigAlice \opSeperate \varSigBob) \< \<
            } \\
            \procedure[linenumbering]{$\procVerfPtSig{\varSigBob}{\varMsg}{\varPubKeyBob}$} {
            (\varSBob, \varRandBob) \opFunResult \varSigBob \\
            \varRand \opAssign \varRandAlice \opAddPoint \varRandBob \\
            \varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \\
            \pcreturn \funGen{\varSBob} \opEq \varRandBob^{\varSchnorrChallenge} \opAddPoint \varPubKeyBob
            }
            \procedure[linenumbering]{$\procFinSig{\varSigAlice}{\varSigBob}$} {
            (\varSAlice, \varRandAlice) \opFunResult \varSigAlice \\
            (\varSBob, \varRandBob) \opFunResult \varSigBob \\
            \varRand \opAssign \varRandAlice \opAddPoint \varRandBob \\
            \varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob \\
            \varS \opAssign \varSAlice \opAddScalar \varSBob \\
            \varSigFin \opAssign (\varS, \varRand) \\
            \pcreturn (\varSigFin, \varPubKeyComp)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Two Party Schnorr Signature Scheme}
    \label{fig:twoparty-schnorr}
\end{figure}

We further show in figure~\ref{fig:twoparty-schnorr-prot} how Alice and Bob can cooperate to produce a final signature which fulfills \textit{Correctness} as defined in definition~\ref{def:signatureScheme}.

\begin{figure}
    \centering
    \pseudocode[codesize=\scriptsize]{
    \textbf{Alice} \< \< \textbf{Bob} \\ [][\hline]
    \< \<  \\
    \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
    \< \text{Fixed Parameters: } \varKeyPairAlice \opSeperate \varKeyPairBob \< \\
    (\varSigAlice) \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyAlice} \< \< (\varSigBob) \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyBob} \\
    \< \sendmessageleft*{\varSigBob} \< \\
    \procVerfPtSig{\varSigBob}{\varMsg}{\varPubKeyBob} \opEq 1 \\
    \< \sendmessageright*{\varSigAlice} \< \\
    \< \< \procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice} \opEq 1 \\
    \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob}
    }
    \caption{Two Party Schnorr Signature Scheme Interaction}
    \label{fig:twoparty-schnorr-prot}
\end{figure}

The final signature is a valid signature to the message $\varMsg$ with the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$.
A verifier knowing the signed message $\varMsg$, the final signature $\varSigFin$ and the composite public key $\varPubKeyComp$ can now verify the signature using the regular $\procVerfId$ procedure.
The challenge $\varSchnorrChallenge$ will be the same because
\[ \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \opEq \funHash{\varMsg \opConc \varRandAlice \opAddPoint \varRandBob \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob} \]

In figure~\ref{fig:aptSchnorr} we further provide a schnorr-based instantiation for the fixed witness adapted signature scheme as defined in definition~\ref{def:twoPartyFixedWitAptSig}:

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procAptSig{\varSigPt}{\varWit}$}{
            (\varS \opSeperate \varRand) \opFunResult \varSigPt \\
            \varSStar \opAssign \varS \opAddScalar \varWit \\
            \pcreturn \varSigApt \opAssign (\varSStar \opSeperate \varRand)
            } \\
            \procedure[linenumbering]{$\procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement}$} {
            (\varSBob \opSeperate \varRandBob) \opFunResult \varSigAptBob \\
            \varRand \opAssign \varRandAlice \opAddPoint \varRandBob \\
            \varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \\
            \pcreturn \funGen{\varSBob} \opEq \varRandBob^\varSchnorrChallenge \opAddPoint \varPubKeyBob \opAddPoint \varStatement
            }
            \procedure[linenumbering]{$\procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}$}{
            (\varS \opSeperate \varRand) \opFunResult \varSigFin \\
            (\varSAlice \opSeperate \varRandAlice) \opFunResult \varSigAlice \\
            (\funStar{\varSBob} \opSeperate \varRandBob) \opFunResult \varSigAptBob \\
            \varSBob \opAssign \varS \opSub \varSAlice \\
            \varWit \opAssign \funStar{\varSigBob} \opSub \varSigBob \\
            \pcreturn (\varWit)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Fixed Witness Adaptor Schnorr Signature Scheme}
    \label{fig:aptSchnorr}
\end{figure}

Again in figure~\ref{fig:aptSchnorrInteraction} we show an example interaction between Alice and Bob creating a signature $\varSigFin$ for the composite public key $\varPubKeyBob \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$
while Bob will hide his secret $\varWit$ which Alice can extract after the signing process has completed.

\begin{figure}
    \pseudocode[codesize=\scriptsize]{
    \textbf{Alice} \< \< \textbf{Bob} \\ [][\hline]
    \< \<  \\
    \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
    \< \text{Fixed Parameters: } \varKeyPairAlice \opSeperate \varKeyPairBob \< \\
    \< \< (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
    \< \sendmessageleft*{\varStatement} \< \\
    \varSigAlice \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyAlice} \< \< \varSigBob \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyBob} \\
    \< \< \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
    \< \sendmessageleft*{\varSigAptBob} \< \\
    \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEq 1 \< \< \\
    \< \sendmessageright*{\varSigAlice} \< \\
    \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
    \< \sendmessageleft*{\varSigFin} \< \\
    \varWit \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigBob}
    }
    \caption{Fixed Witness Adaptor Schnorr Signature Interaction}
    \label{fig:aptSchnorrInteraction}
\end{figure}

\section{Security}\label{sec:twopartyAptSecurity}

We now show that the outlined instantiation is secure with regards to the regular signature scheme definition~\ref{def:signatureScheme} and the adaptor signature scheme definition~\ref{def:twoPartyFixedWitAptSig}.
We start by proving \textit{correctness} of the scheme by showing that for two partial signatures $\varSigAlice$ and $\varSigBob$:
\[ \procVerf{\varMsg}{\procFinSig{\varSigAlice}{\varSigBob}}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1 \]

\begin{proof}
    \label{prf:aptSchnorr}
    The correctness proof is by showing equality of the equation checked by the verifier by continous substitutions in the left side of equation:
    \begin{align}
        \funGen{\varS} &\opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp \\
        \funGen{\varSAlice} \opAddPoint \funGen{\varSBob} & \\
        \funGen{\varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob} & \\
        \funGen{\varNonceAlice \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyBob} & \\
        \opPointScalar{\varRandAlice}{\varSchnorrChallenge} \opAddPoint \varPubKeyAlice \opAddPoint \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob & \\
        \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp & \opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp \\
        1 & \opEq 1
    \end{align}
\end{proof}

Next we provide a proof that in addition to regular \textit{correctness} also \textit{pre-signature correctness} holds.
Note that we have 3 statements to prove, we have already proven that $\procVerf{\varMsg}{\varSigFin}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1$ holds in our instantiation of the signature scheme in the
correctness proof~\ref{prf:aptSchnorr}.
It remains to prove that with the same setup $\procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEq 1$ and
$(\varStatement \opSeperate \funStar{\varWit}) \opIn \cnstRelation$ hold.

\begin{proof}
    \label{prf:aptSchnorrPreSigCorr}
    For this prove we assume the setup already specified in definition~\ref{def:preSigCorrectness}.
    First we prove that the following statement:
    \[
        \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyBob}{\varStatement} \opEq 1
    \]
    The proof is by continuous substitutions in the equation checked by the verifier:
    \begin{align}
        \funGen{\varSigAptBob} &\opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement \\
        \funGen{\varSigBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyBob} \opAddScalar \funGen{\varWit} & \\
        \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement &\opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement \\
        1 &\opEq 1
    \end{align}
    We now continue to prove the last equation required:
    \[
        (\varStatement \opSeperate \funStar{\varWit} \opIn \cnstRelation)
    \]
    To prove correctness we show that $\varWit$ is calculated correctly in $\procExtWitId$:
    \begin{align}
        \varWit \opAssign & \funStar{\varSBob} \opSub (\varS \opSub \varSAlice) \\
        & \funStar{\varSBob} \opSub ((\varSAlice \opAddScalar \varSBob ) \opSub \varSAlice ) \\
        & \varSBob \opAddScalar \varWit \opSub (\varSBob) \\
        \varWit \opAssign & \varWit \\
    \end{align}

\end{proof}

TODO Proof for pre-signature adaptability, $\cnstaEUFCMA$ and witness extractability.