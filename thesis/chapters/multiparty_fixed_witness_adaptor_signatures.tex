In this chapter, we will define a variant of the Adaptor Signature scheme as seen in~\ref{sec:aptSignatures},
which is specifically tailored for the use in an Atomic Swap scenario in which (at least one side of the swap) uses a two-party protocol to generate transaction signatures.
We will start by explaining the general two-party signature creation protocol as it currently implemented in the Grin Cryptocurrency.
We reduce the generated signatures to the general case~\cite{schnorr1989efficient} and thereby prove its security. From this protocol, we then derive the adapted variant, which allows hiding a fixed witness
value in the signature, which can be revealed only by the other party after attaining the final signature.
We then proof its security by showing that all security definitions defined in~\cite{aumayr2020bitcoinchannels} hold.
In chapter~\ref{chp:atomicSwap} we will then utilize this scheme to build the Atomic Swap protocol.

We start by defining a instantiation of Signature Scheme (see definition~\ref{def:signatureScheme})) which is currenlty employed in Grin, a Mimblewimble based Cryptocurrency.
We assume we have a group $\cnstGroup$ with prime $\varPrime$, $\cnstHash$ is a secure hash function as defined in~\ref{def:hashFunction} and $\varMsg$ is a publicly known message.\\
\begin{itemize}
    \item $\procSetupId$ creates a keypair $\varKeyPair$, the public key can be distributed to the verifier(s) and the secret key has to be kept private. \\
    \item $\procSignId$ creates a signature consisting of a variable $\varS$ and generator $\varG$ raised to the nonce used during the signing process $\funGen{\varNonce}$. \\
    \item $\procVerfId$ allows a verifier knowing the signature $\varSignature$ and the provers public key $\varPubKey$ to verify the signatures validity. \\
\end{itemize}
\begin{figure}
    \fbox{
        \parbox{\textwidth}{
            \procedure[linenumbering, syntaxhighlight=auto]{$\procSetup{\varSecParam}$} {
                \varKey \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
                \pcreturn (\varSecKey \opAssign \varKey \opSeperate \varPubKey \opAssign \funGen{\varKey})
            }
            \procedure[linenumbering, syntaxhighlight=auto]{$\procSign{\varMsg}{\varSecKey}$}{
                \varNonce \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
                \varRand \opAssign \funGen{\varNonce} \\
                \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
                \varS \opAssign \varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey \\
                \pcreturn \varSignature \opAssign (\varS, \varRand)
            }
            \procedure[linenumbering, syntaxhighlight=auto]{$\procVerf{\varMsg}{\varSignature}{\varPubKey}$} {
                \varS \opAssign \opAccess{\varSignature}{\varS} \\
                \varRand \opAssign \opAccess{\varSignature}{\varRand} \\
                \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
                \pcreturn \funGen{\varS} \opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKey
            }
        }
    }
    \caption{Schnorr Signature Scheme as defined in~\cite{schnorr1989efficient}}
    \label{fig:schnorr}
\end{figure}
\textit{Correctness} of the Scheme is easy to derive. As $\varS$ is calculated as $\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey$, when generator $\varG$ is raised to $\varS$, we get
$\funGen{\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey}$ which we can transform into $\funGen{\varNonce} \opAddPoint \funGen{\varSecKey \opTimesScalar \varSchnorrChallenge}$, and finally
into $\varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}$ which is the same as the right side of the equation.

\begin{definition}[Two Party Signature Generation]
    \label{def:twoPartySig}
    We now define a two party Signature Scheme wrt. to a hard relation $\cnstRelation$ as an extension of the outlined Signature Scheme,
    which allows us to distribute signature generation for a composite public key shared between two parties Alice and Bob. Alice and Bob want to collaborate to generate a signature valid unter the composite
    public key $\varPubKeyComp \opAssign \varPubKeyAlice + \varPubKeyBob$ without having to reveal their secret keys to each other. For this we add three procedures to our Signature Scheme:
    \[ \varSigSchemeMP = (\varSigScheme \opConc \procSetupPartSigId \opSeperate \procGenPartSigId \opSeperate \procVerfPartSigId \opSeperate \procFinSigId) \]
    \begin{itemize}
        \item $\procSetupPartSigId$ takes as input $\varSecParam$ with $\varN$ as the security parameter and randomly generates a nonce $\varNonce$ as well as a commitment $\varRand$ to the nonce which has to be distributed between Alice and Bob. Note that in this protocol we assume Alice keypair $\varKeyPairAlice$, as well as Bobs keypair $\varKeyPairBob$ to be fixed ergo they can't be chosen arbitrarily. This is important because otherwise the protocol might be vulnerable to a Rogue-Key Attack~\cite{horster1995meta}. As we have seen in section~\ref{sec:Mimblewimble} the public keys in the Mimblewimble protocol to which the parties are signing are the so called Kernel elements $\varKernel$ which are calculated rather then choosen.
        \item $\procGenPartSigId$ takes as input a to be signed message $\varMsg$ and generates a partial signature with Alice's key $\varSecKeyAlice$ and nonce $\varNonceAlice$. Note that $\varPubKeyBob$ and $\varRandBob$ are also used in the protocol for generating the schnorr challenge $\varSchnorrChallenge$, because our final signature should be valid under the combined public key $\varPubKeyAlice \opAddPoint \varPubKeyBob$ and combined nonce commitment $\varRandAlice \opAddPoint \varRandBob$.
        \item $\procVerfPartSigId$ lets Alice verify Bobs partial signature and vice verca. Note that the equation the verifier checks is identical to what we have already proven to be correct in the regular
        case. The only difference is that $\varSchnorrChallenge$ is computed differently.
        \item $\procFinSigId$ will take the two partial signatures as well as the randomness exchanged and creates a valid signature which can be verified with $\procVerfId$ under the public key
        $\varPubKeyAlice \opAddPoint \varPubKeyBob$.
    \end{itemize}
\end{definition}

\begin{figure}
    \fbox{
        \parbox{\textwidth}{
            \procedure[linenumbering, syntaxhighlight=auto]{$\procSetupPartSig{\varSecParam}$}{
                \varNonce \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
                \varRand \opAssign \funGen{\varRand} \\
                \pcreturn (\varNonce \opSeperate \varRand)
            }
            \procedure[linenumbering, syntaxhighlight=auto]{$\procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}$} {
                \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRandAlice \opAddPoint \varRandBob \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob} \\
                \varS \opAssign \varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice \\
                \pcreturn \varSigAlice \opAssign \varS
            } \\[2\baselineskip]
            \procedure[linenumbering, syntaxhighlight=auto]{$\procVerfPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varSigBob}$} {
                \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRandAlice \opAddPoint \varRandBob \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob} \\
                \varS \opAssign \opAccess{\varSigBob}{\varS} \\
                \pcreturn \funGen{\varS} \opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob
            } \\[2\baselineskip]
            \procedure[linenumbering, syntaxhighlight=auto]{$\procFinSig{\varSigAlice}{\varSigBob}{\varRandAlice}{\varRandBob}$} {
                \varS_\varAlice \opAssign \opAccess{\varSigAlice}{\varS} \\
                \varS_\varBob \opAssign \opAccess{\varSigBob}{\varS} \\
                \pcreturn \varSigFin \opAssign (\varS \opAssign \varS_\varAlice \opAddScalar \varS_\varBob \opSeperate \varRand \opAssign \varRandAlice \opAddPoint \varRandBob)
            }
        }
    }
    \caption{Two Party Schnorr Signature Scheme}
    \label{fig:twoparty-schnorr}
\end{figure}

We further explain in figure~\ref{fig:twoparty-schnorr-prot} how Alice and Bob can cooperate to produce a final signature which fullfills \textit{Correctness} as defined in~\ref{def:signatureScheme}.
We outline an interaction between Alice and Bob using the procedures defined in figure~\ref{fig:twoparty-schnorr} to build final composite signature $\varSigFin$.

\begin{figure}
    \centering
    \pseudocode[codesize=\scriptsize]{
        \textbf{Alice} \< \< \textbf{Bob} \\ [][\hline]
        \< \<  \\
        \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
        \< \text{Fixed Parameters: } \varKeyPairAlice \opSeperate \varKeyPairBob \< \\
        (\varNonceAlice \opSeperate \varRandAlice) \opFunResult \procSetupPartSig{\varSecParam} \< \< \\
        \< \sendmessageright{ top=$(\varPubKeyAlice \opSeperate \varRandAlice)$ } \< \\
        \< \< (\varNonceBob \opSeperate \varRandBob) \opFunResult \procSetupPartSig{\varSecParam} \\
        \< \< \varSigBob \opFunResult \procGenPartSig{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varPubKeyAlice}{\varRandAlice} \\
        \< \sendmessageleft{ top=$(\varSigBob \opSeperate \varPubKeyBob \opSeperate \varRandBob)$ } \< \\
        \procVerfPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varSigBob} \opEq 1\< \< \\
        \varSigAlice \opFunResult \procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob} \< \< \\
        \< \sendmessageright{ top=$(\varSigAlice)$ } \< \\
        \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob}{\varRandAlice}{\varRandBob} \\
    }
    \caption{Two Party Schnorr Signature Scheme Interaction}
    \label{fig:twoparty-schnorr-prot}
\end{figure}

The final signature is a valid signature to the message $\varMsg$ with the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$.
A verifier knowing the signed message $\varMsg$, the final signature $\varSigFin$ and the composite public key $\varPubKeyComp$ can now verify the signature using the $\procVerfId$ procedure.
The challenge $\varSchnorrChallenge$ will be the same because
\[ \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \opEq \funHash{\varMsg \opConc \varRandAlice \opAddPoint \varRandBob \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob} \]
\textit{Correctness} is proven in proof~\ref{prf:twopartySchnorr} by showing
that:~
\[ \varSigAlice \opFunResult \procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob} \]
\[ \varSigBob \opFunResult \procGenPartSig{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varPubKeyAlice}{\varRandAlice} \]
\[ \procVerf{\varMsg}{\procFinSig{\varSigAlice}{\varSigBob}{\varRandAlice}{\varRandBob}}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1 \]

\begin{proof}
    \label{prf:twopartySchnorr}
    The proof is by showing equality of the equation checked by the verifier by continous substitutions in the left side of equation:
    \begin{align}
        \funGen{\varS} &\opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp \\
        \funGen{\varSAlice} \opAddPoint \funGen{\varSBob} & \\
        \funGen{\varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob} & \\
        \funGen{\varNonceAlice \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyBob} & \\
        \opPointScalar{\varRandAlice}{\varSchnorrChallenge} \opAddPoint \varPubKeyAlice \opAddPoint \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob & \\
        \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp & \opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp
    \end{align}
\end{proof}

\begin{definition}[Two Party Fixed Witness Adaptor Schnorr Signature Scheme]
    \label{def:twoPartyFixedWitAptSig}
    From the definition~\ref{def:twoPartySig} we now derive an adapted Signature Scheme $\varSigSchemeApt$ which allows one of the participants to hide the discrete logarithm $\varWit$ of a curve point $\funGen{\varWit}$ choosen
    at the beginning of the protocol. Again we extend our previously defined Signature Scheme with new functions:
    \[ \varSigSchemeApt \opAssign (\varSigSchemeMP \opConc \procSetupAptId \opSeperate \procGenPtAptSigId \opSeperate \procVrfAptId \opSeperate \procExtWitId) \]
    \begin{itemize}
        \item $\procSetupAptId$ generates randomly a secret witness $\varWit$ which has to be kept private and is revealed to the other party by receiving the final composite signature. $\varStatement$ is distributed
        to the other party. In a Atomic Swap scenario between Alice and Bob (which we will describe in~\ref{chp:atomicSwap}) Bob receiving $\varStatement$ should convince himself of its validity. (For example by verifying that
        there are indeed funds available to him if he receives the secret $\varWit$).
        \item $\procGenPtAptSigId$ allows Alice (knowing $\varWit$) to create a partial pre signature (similiar to as defined in~\ref{def:twoPartySig}) which hides the secret $\varWit$ without immediately revealing it.
        It outputs the partial pre signature, which can be verified to contain $\varWit$ by Bob (knowing $\varStatement$).
        \item $\procVrfAptId$ makes it possible to verify the validity of an partial pre signature plus that it indeed contains the secret witness of $\varStatement$. Assume Bob provided a partial pre signature to Alice,
        Alice calculates the Schnorr challenge $\varSchnorrChallenge$ as previously defined, but when comparing equality of the provided partial signature and her computed values she will add $\varStatement$ to additionally
        verify the signature containing witness $\varWit$.
        \item $\procFinAptSigId$ creates a final valid signature under the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ by adapting Bobs partial pre signature
        into Bobs final partial Signature which which we can then construct the final composite one.
        \item $\procExtWitId$ lets Alice extract the secret witness $\varWit$ from the final composite signature, her own partial signature $\varSigAlice$ and Bobs partial pre signature $\varSigAptBob$. She does
        so by first calculating Bobs adapted partial signature in which the witness is already removed. Knowing Bobs adapted partial signature as well as the presignature one she
        can simply substract those two to receive the secret $\varX$.
    \end{itemize}
    Figure~\ref{fig:aptSchnorr} shows the concrete instantiations of the functions. The final signature is created again by calling $\procFinSigId$ with the partial signatures computed by Alice and Bob.
\end{definition}

\begin{figure}
    \fbox{
        \parbox{\textwidth} {
            \procedure[linenumbering, syntaxhighlight=auto]{$\procSetupApt{\varSecParam}$} {
                (\varNonce \opSeperate \varRand) \opFunResult \procSetupPartSig{\varSecParam} \\
                \varWit \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
                \varStatement \opAssign \funGen{\varWit} \\
                \pcreturn ((\varNonce \opSeperate \varRand)\opSeperate (\varWit, \varStatement))
            }
            \procedure[linenumbering, syntaxhighlight=auto]{$\procGenPtAptSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varWit}$}{
                \varSigBob \opFunResult \procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob} \\
                \varS \opAssign \opAccess{\varSigBob}{\varS} \opAddScalar \varWit \\
                \pcreturn \varSigAptAlice \opAssign (\varS \opSeperate \varStatement)
            } \\[2\baselineskip]
            \procedure[linenumbering, syntaxhighlight=auto]{$\procVrfApt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varStatement}{\varSigAptBob}$} {
                \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob \opConc \varRandAlice \opAddPoint \varRandBob} \\
                \pcreturn \funGen{\varSigAptBob} \opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \funGen{\varWit}
            }
            \procedure[linenumbering, syntaxhighlight=auto]{$\procFinAptSig{\varSigAlice}{\varSigAptBob}{\varRandAlice}{\varRandBob}{\varWit}$}{
                \varSigBob \opAssign \varSigAptBob \opSub \varWit \\
                \pcreturn \procFinSig{\varSigAlice}{\varSigAptBob}{\varRandAlice}{\varRandBob}
            } \\[2\baselineskip]
            \procedure[linenumbering, syntaxhighlight=auto]{$\procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}$}{
                \varSigBob \opAssign \varSigFin \opSub \varSigAlice \\
                \varWit \opAssign \varSigAptBob \opSub \varSigBob \\
                \pcreturn (\varWit)
            }
        }
    }
    \caption{Fixed Witness Adaptor Schnorr Signature Scheme}
    \label{fig:aptSchnorr}
\end{figure}

Again in figure~\ref{fig:aptSchnorrInteraction} we show an interaction between Alice and Bob creating a signature $\varSigFin$ for the composite public key $\varPubKeyBob \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$
while Bob will hide his secret $\varWit$ which Alice can retrieve after the signing process has completed.

\begin{figure}
    \pseudocode[codesize=\scriptsize]{
        \textbf{Alice} \< \< \textbf{Bob} \\ [][\hline]
        \< \<  \\
        \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
        \< \text{Fixed Parameters: } \varKeyPairAlice \opSeperate \varKeyPairBob \< \\
        (\varNonceAlice \opSeperate \varRandAlice) \opFunResult \procSetupPartSig{\varSecParam} \< \< \\
        \< \sendmessageright{ top=$(\varPubKeyAlice \opSeperate \varRandAlice)$ } \< \\
        \< \< ((\varNonceBob \opSeperate \varRandBob) \opSeperate (\varWit \opSeperate \varStatement)) \opFunResult \procSetupApt{\varSecParam} \\
        \< \< \varSigAptBob \opFunResult \procGenPtAptSig{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varPubKeyAlice}{\varRandAlice}{\varWit} \\
        \< \sendmessageleft{ top=$(\varSigBob \opSeperate \varPubKeyBob \opSeperate \varRandBob \opSeperate \varStatement)$ } \< \\
        \procVrfApt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varSigBob}{\varStatement} \opEq 1\< \< \\
        \varSigAlice \opFunResult \procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob} \< \< \\
        \< \sendmessageright{ top=$(\varSigAlice)$ } \< \\
        \< \< \varSigFin \opFunResult \procFinAptSig{\varSigAlice}{\varSigAptBob}{\varRandAlice}{\varRandBob}{\varWit} \\
    }
    \caption{Fixed Witness Adaptor Schnorr Signature Interaction}
    \label{fig:aptSchnorrInteraction}
\end{figure}

We now proof the \textit{Correctness} of the scheme by showing that:~
\begin{gather}
    \varSigAlice \opFunResult \procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob} \\
    \varSigAptBob \opFunResult \procGenPtAptSig{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varPubKeyAlice}{\varRandAlice}{\varWit} \\
    \procVerf{\varMsg}{\procFinSig{\varSigAlice}{\varSigAptBob}{\varRandAlice}{\varRandBob}{\varWit}}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1
\end{gather}

\begin{proof}
    \label{prf:aptSchnorr}
    Again the proof is by continous substitutions in the equation checked by the verifier:
    \begin{align}
        \funGen{\varS} &\opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyCompApt \\
        \funGen{\varSAlice \opAddScalar \varSBob \opSub \varWit} & \\
        \funGen{\varSAlice} \opAddPoint \funGen{\varSBob \opSub \varWit} & \\
        \funGen{\varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob \opAddScalar \varWit \opSub \varWit} & \\
        \funGen{\varNonceAlice} \opAddPoint \funGen{\varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob} \opAddPoint \funGen{\varSchnorrChallenge \opTimesScalar \varSecKeyBob} & \\
        \opPointScalar{\varRandAlice}{\varSchnorrChallenge} \opAddPoint \varPubKeyAlice \opAddPoint \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob & \\
        \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp & \opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp
    \end{align}
\end{proof}

\begin{definition}[Pre-signature correctness]\label{def:preSigCorrectness}
    Similiar to how it is defined in~\cite{aumayr2020bitcoinchannels} additionally to \textit{correctness} require our signature scheme to satisfy \textit{pre-signature correctness}. \\
    This property is given if a presignature is generated by $\procGenPtAptSigId$ can be completed into a final (partial) signature for all pairs $(\varWit \opSeperate \varStatement)$, from which it will
    be possible to extract the witness computing $\procExtWitId$ with the required parameters.\\ \\
    More formally Pre-signature correctness is given if for every security parameter $\varN \in \cnstNatural$, message $\varMsg \in \cnstBinary{*}$, and every statement/witness pair
    $\varStatement \opSeperate \varWit)$ in a relation $\cnstRelation$ it must hold that:
\begin{scriptsize}
    \[
        \Pr\left[
        \begin{array}{c}
            1. \procVerf{\varMsg}{\varSigFin}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1 \\
            \opAnd \\
            2. \procVrfApt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varSigBob}{\varStatement} \opEq 1 \\
            \opAnd \\
            3. (\varStatement \opSeperate \funStar{\varWit} \opIn \cnstRelation)
        \end{array}
        \middle\vert
        \begin{array}{l}
            (\varKeyPairAlice \opSeperate (\varNonceAlice \opSeperate \varRandAlice)) \opFunResult \procSetupPartSig{\varSecParam} \\
            (\varKeyPairBob \opSeperate (\varNonceBob \opSeperate \varRandBob) \opSeperate (\varWit \opSeperate \varStatement)) \opFunResult \procSetupApt{\varSecParam} \\
            \varSigAptBob \opFunResult \procGenPtAptSig{\varMsg}{\varSecKeyBob}{\varNonceBob}{\varPubKeyAlice}{\varRandAlice}{\varWit} \\
            \varSigAlice \opFunResult \procGenPartSig{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob} \\
            \varSigFin \opFunResult \procFinAptSig{\varSigAlice}{\varSigAptBob}{\varRandAlice}{\varRandBob}{\varWit} \\
            \funStar{\varWit} \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}
        \end{array}
        \right]=1.
    \]
\end{scriptsize}
\end{definition}

As defined by aumayr et al. in ~\cite{aumayr2020bitcoinchannels} a secure adaptor signature scheme needs three security properties to be fullfilled:
\begin{enumerate}
    \item \textit{adapted existential unforgeability under choosen message attack}
    \item \textit{pre-signature adaptability}
    \item \textit{witness extractability}
\end{enumerate}

We proceed by defining the three properties for our adapted signature scheme defined in~\ref{def:twoPartyFixedWitAptSig}.

\begin{definition}[$\cnstaEUFCMA$]\label{def:aeufcma}
        Additionally to the regular definition of existential unforgeability under chosen message attacks we additionally require that it is hard to produce a forged partial signature $\varSigPart$ if the
    adversary $\cnstAdversary$ gets to know a valid pre signature $\varSigPartApt$ w.r.t. some message $\varMsg$ and a statement $\varStatement$.\\
    For the definition of $\cnstaEUFCMA$-security we define the experiment $\procExpForgId$ for a $\cnstPolyTime$ adversary $\cnstAdversary$ with a fixed keypair $(\varSecKeyAdv \opSeperate \varPubKeyAdv)$ and an adapted signature scheme $\varSigSchemeApt$ as
    follows:\\
    \fbox{
        \parbox{\textwidth}{
            \procedure[linenumbering, syntaxhighlight=auto]{$\procExpForg{\varN}$} {
                \varSet \opAssign \cnstEmptySet \\
                (\varNonceAdv \opSeperate \varRandAdv) \opFunResult \procSetupPartSig{\varSecParam} \\
                \varMsg \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\varSecKey}{\varPubKey}}(\varPubKeyAdv \opSeperate \varRandAdv) \\
                \varSigPartApt \opFunResult \procGenPtAptSig{\varMsg}{\varSecKey}{\varNonce}{\varPubKeyAdv}{\varRandAdv}{\varWit} \\
                \varSigPart \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\varSecKey}{\varPubKey}}(\varSigPartApt) \\
                \varSigFin \opFunResult \procFinAptSig{\varSigPart}{\varSigPartApt}{\varWit}{\varRand}{\varRandAdv} \\
                \pcreturn (\varMsg \opNotIn \varSet \opAnd \procVerf{\varMsg}{\varSigFin}{\varPubKeyAdv \opAddPoint \varPubKey})
            }\\[2\baselineskip]
            \procedure[linenumbering, syntaxhighlight=auto]{$\procSignOracle{\varMsg}{\varPubKeyAdv}{\varRandAdv}$} {
                \varSet \opAssign \varSet \opUnion {\varMsg} \\
                (\varKeyPair \opSeperate (\varNonce \opSeperate \varRand) \opSeperate (\varWit \opSeperate \varStatement)) \opFunResult \procSetupApt{\varSecParam} \\
                \pcreturn \procGenPtAptSig{\varMsg}{\varSecKey}{\varNonce}{\varPubKeyAdv}{\varRandAdv}{\varWit}
            }\\[2\baselineskip]

        }
    }
\end{definition}

\begin{definition}[Pre-signature adaptability]
    TODO~\cite{aumayr2020bitcoinchannels}
\end{definition}

\begin{definition}[Witness extractability]
    TODO~\cite{aumayr2020bitcoinchannels}
\end{definition}

\begin{definition}[Secure Adaptor Signature Scheme]
    TODO~\cite{aumayr2020bitcoinchannels}
\end{definition}

Note that we have 3 statements to prove, in order to prove \textit{Pre-Signature Correctness}.
We have already proven that $\procVerf{\varMsg}{\varSigFin}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1$ holds in our instantiation of the signature scheme in the
correctness proof~\ref{prf:aptSchnorr}.
It remains to prove that $\procVrfApt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varSigBob}{\varStatement} \opEq 1$ and
$(\varStatement \opSeperate \funStar{\varWit} \opIn \cnstRelation)$.

\begin{proof}
    \label{prf:aptSchnorrPreSigCorr}
    For this prove we assume the setup already specified in~\ref{def:preSigCorrectness}.
    First we prove that the following statement:
    \[
        \procVrfApt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varPubKeyBob}{\varRandBob}{\varStatement}{\varSigAptBob} \opEq 1
    \]
    The proof is by continous substitutions in the equation checked by the verifier:
    \begin{align}
        \funGen{\varSigAptBob} &\opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement \\
        \funGen{\varSigBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyBob} \opAddScalar \funGen{\varWit} & \\
        \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement &\opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement \\
        1 &\opEq 1
    \end{align}
    We now continue to prove the last equation required:
    \[
        (\varStatement \opSeperate \funStar{\varWit} \opIn \cnstRelation)
    \]
    To prove correctness we show that $\varWit$ is calculated correctly in $\procExtWitId$:
    \begin{align}
        \varWit \opAssign & \varSigAptBob \opSub (\varSigFin \opSub \varSigAlice) \\
        & \varSigAptBob \opSub ((\varSAlice \opAddScalar \varSBob ) \opSub \varSAlice ) \\
        & \varSBob \opAddScalar \varWit \opSub (\varSBob) \\
        \varWit & \varWit \\
    \end{align}

\end{proof}