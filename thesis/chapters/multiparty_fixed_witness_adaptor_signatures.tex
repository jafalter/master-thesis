In this chapter, we will define a variant of the adaptor signature scheme as explained in~\ref{sec:aptSignatures}. The main difference in the protocol outlined in this thesis is that one of the two parties does know the fixed secret witness before the start of the protocol. The aim of the protocol will then be that the other person is able to extract the witness from the final signature. This feature such that we can later build an atomic swap protocol on top of it.

First we will define the general two-party signature creation protocol as it is currently implemented for example in the Grin cryptocurrency.
We reduce the generated signatures to the general case~\cite{schnorr1989efficient} and thereby prove its correctness.
From this protocol, we then derive the adapted variant, which allows hiding a fixed witness
value in the signature, which can be revealed only by the other party after attaining the final signature.
We start by defining our extended signature scheme in section~\ref{sec:definitions}, proceed by providing a schnorr-based instantiation of the protocol in section~\ref{sec:schnorrInst} and finally prove its security in section~\ref{sec:twopartyAptSecurity}.


\section{Definitions}\label{sec:definitions}

A two-party signature scheme is an extension of a signature scheme as defined in definition~\ref{def:signatureScheme}, which allows us to distribute signature generation for a composite public key shared between two parties Alice and Bob.
Alice and Bob want to collaborate to generate a signature valid under the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ without having to reveal their secret keys to each other.

\begin{definition}[Two Party Signature Scheme]
    \label{def:twoPartySig}

    A \emph{two party signature scheme $\varSigSchemeMP$} extends a signature scheme $\varSigScheme$ with a tuple of protocols and algorithms
    $(\procSetupCtxId, \procKeyGenPtId, \procSignPrtId , \procVerfPtSigId, \procFinSigId)$ defined as follows:

    \begin{itemize}
        \item $\varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyAlice}{\varPubKeyBob}$ is an auxiliary function to populate a signature context. After one round of interaction the context
        should contain the combined public key $\varPubKey$ and nonce commitment $\varRand$.

        \item $((\varSecKeyAlice, \varPubKeyAlice, \varNonceAlice, \varSigContext), (\varSecKeyBob, \varPubKeyBob, \varNonceBob \varSigContext)) \opFunResult \procKeyGenPt{\varSecParam}{\varSecParam}$: The distributed key generation protocol takes as input the security parameter from both Alice and Bob and returns
        the tuple $(\varSecKeyAlice, \varPubKeyAlice, \varNonceAlice \varSigContext)$ to Alice (similar to Bob) where $(\varSecKeyAlice, \varPubKeyAlice)$ is a pair of private and corresponding public keys, $\varNonceAlice$ a secret nonce and $\varSigContext$ is the signature context containing shared parameters shared between Alice and Bob.

        \item $(\varSigAlice) \opFunResult \procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}$: The partial signing procedure takes as input the message $\varMsg$ and the share of the secret key $\varSecKeyAlice$ and nonce $\varNonceAlice$ (similiar for Bob). This procedure outputs $(\varSigAlice)$, that is, a share of the signature to a participant.

        \item $\cnstTrueorFalse \opFunResult \procVerfPtSig{\varSigBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}$: The share verification algorithm is a DPT function that takes as input a signature share $\varSigAlice$, a message $m$, and the other participants public keys $\varPubKeyAlice$ or $\varPubKeyBob$. The algorithm returns 1 if the verification was successfull or 0 otherwise.

        \item $\varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob})$: The finalize signature algorithm is a DPT function that takes as input two shares of the signatures and combines them into a final signature.

    \end{itemize}

\end{definition}

\todo[inline]{You need to add here that we require a two-party signature scheme that is correct and unforgeable against chosen message attacks (EUF-CMA). You can then point to these paper \url{https://link.springer.com/content/pdf/10.1007/s00145-006-0347-3.pdf} The EUF-CMA game for 2-party signature scheme is defined in pages 14-15 of this paper \url{https://eprint.iacr.org/2017/552.pdf}}

\begin{definition}[Two Party Fixed Witness Adaptor Schnorr Signature Scheme]
    \label{def:twoPartyFixedWitAptSig}
    From the definition~\ref{def:twoPartySig}, we now derive an adapted signature scheme $\varSigSchemeApt$, which allows one of the participants to hide the discrete logarithm $\varWit$ of a statement $\varStatement$ chosen
    at the beginning of the protocol. Again we extend our previously defined signature scheme with new functions:
    \[ \varSigSchemeApt \opAssign (\varSigSchemeMP \opConc \procAptSigId \opConc \procVerifyAptSigId \opConc \procExtWitId) \]

    \begin{itemize}
        \item $\varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit}$ takes as input a partial signature $\varSigPt$ and a secret witness value $\varWit$. The procedure will output an adapted partial signature $\varSigApt$ which can be verified to contain $\varWit$ using the $\procVerifyAptSigId$ function, without immidiately revealing $\varWit$.
        \item $\cnstTrueorFalse \opFunResult \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varStatement}$ takes as input an adapted partial signature $\varSigApt$, the participants public keys and a statement $\varStatement$. The function will verify the partial signature's validity as well that it contains the secret witness $\varWit$.
        \item $\varWit \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}$ lets Alice extract the secret witness $\varWit$ from the final composite signature. Note that to extract the witness $\varWit$ the partial signatures shared between the participants beforehand and the statement $\varStatement$ needs to be provided as inputs. This makes sure that only participants of the procotol will be able to perform the extraction.
    \end{itemize}
\end{definition}

\begin{definition}[\cnstSecureAptScheme]
    \label{def:aptsigsecure}
    As defined by Aumayr et al. in~\cite{aumayr2020bitcoinchannels}, a secure adaptor signature scheme needs two security properties to be fulfilled:
    \begin{enumerate}
        \item \cnstaEUFCMA
        \item \cnstWitnessExtractability
    \end{enumerate}
\end{definition}

We proceed by redefining these properties as well as adapted correctness for our adapted two-party fixed witness signature scheme defined in definition~\ref{def:twoPartyFixedWitAptSig}:

\begin{definition}[\cnstAptSigCorrectness]
    \label{def:aptSigCorrectness}
    Similar to how it is defined in~\cite{aumayr2020bitcoinchannels} additionally to \cnstCorrectness as defined in~\ref{def:signatureScheme} we require our signature scheme to satisfy \cnstAptSigCorrectness.
    This property is given when every adapted partial signature generated by $\procAptSigId$ can be completed into a final signature for all pairs $(\varWit \opSeperate \varStatement) \opIn \cnstRelation$, from which it will
    be possible to extract the witness computing $\procExtWitId$ with the required parameters.

    More formally \cnstAptSigCorrectness is given if for every security parameter $\varN \in \cnstNatural$, message $\varMsg \in \cnstBinary{*}$, keypairs $\varKeyPairAlice \opFunResult \procSetup{\varSecParam} \opSeperate
    \varKeyPairBob \opFunResult \procSetup{\varSecParam}$
    with their composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ \todo{you need to define keys in terms of DKeyGen}
    and every statement/witness pair $(\varStatement \opSeperate \varWit)$ in a relation $\cnstRelation$ it must hold that:
    \todo[inline]{Pedro: remove the question mark from equal in left part of Pr. They must hold}

    \[
        \Pr\left[
        \begin{array}{c}
            \:\procVerf{\varMsg}{\varSigFin}{\varPubKeyComp} \opEq 1                                            \\
            \opAnd                                                                                              \\
            \: \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varStatement} \opEq 1 \\
            \opAnd                                                                                              \\
            \:(\varStatement \opSeperate \funStar{\varWit}) \opIn \cnstRelation
        \end{array}
        \middle\vert
        \begin{array}{l}
            (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam}                                \\
            (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
            \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit}                                             \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob}                                           \\
            \funStar{\varWit} \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}
        \end{array}
        \right]=1.
    \]
\end{definition}

\begin{definition}[$\cnstaEUFCMA$]
    \label{def:aeufcma}
    Additionally to the regular definition of \textit{existential unforgeability under chosen message attacks} as defined for example in~\cite{vaudenay2006classical} we require that it is hard to produce a forged partial signature $\varSigPt$ if the
    adversary $\cnstAdversary$ gets to know a valid adapted signature $\varSigApt$ w.r.t. some message $\varMsg$ and a statement $\varStatement$.

    For the definition of $\cnstaEUFCMA$-security we define the experiment $\procExpForgId$ for a $\cnstPolyTime$ adversary $\cnstAdversary$ with a keypair $(\varSecKeyAlice \opSeperate \varPubKeyAlice)$,
    meaning the attacker plays the role of Alice in the protocol and an adapted signature scheme $\varSigSchemeApt$ as
    follows:

    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procExpForg{\varN}$} {
            \varSet \opAssign \cnstEmptySet \\
            \varKeyPairBob \opFunResult \procSetup{\varSecParam} \\
            (\varMsg \opSeperate \varSecKeyAlice) \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\cdot}}(\varPubKeyBob) \\
            (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
            (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
            \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
            \funStar{\varSigAlice} \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\cdot}}(\varSigBob) \\
            \varSigFin \opFunResult \procFinSig{\funStar{\varSigAlice}}{\varSigBob} \\
            \pcreturn ((\varMsg) \opNotIn \varSet \opAnd \funStar{\varSigAlice} \opNotEq \varSigAlice \opAnd \procVerf{\varMsg}{\varSigFin}{\varPubKeyAlice \opAddPoint \varPubKeyBob})
            }\\[2\baselineskip]
            \procedure[linenumbering]{$\procSignOracle{\varMsg}{\varPubKeyAlice}$} {
            (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
            (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
            \varSigAptBob \opFunResult \procAptSig{\varSigPt}{\varWit} \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigAptBob} \\
            \varSet \opAssign \varSet \opUnion \{\varMsg\} \\
            \pcreturn (\varSigFin \opSeperate \varStatement)
            }\\[2\baselineskip]
        \end{varwidth}
        }
    \end{center}
    The adapted signature scheme $\varSigSchemeApt$ is called $\cnstaEUFCMA$-secure if
    \[ \prob{\procExpForg{\varN} \opEqNoQ 1} \opSmEq \funNegl{\varN} \]
\end{definition}

\begin{definition}[\cnstWitnessExtractability]
    Informally the \cnstWitnessExtractability property holds for an adapted signature scheme $\varSigSchemeApt$ computed for the statement $\varStatement$ when we can always extract the witness
    $(\varWit \opSeperate \varStatement)$ from the final signature $\varSigFin$, given the partial signatures of the participants.
    To formalize this statement we describe an experiment $\procExpExtId$ for a $\cnstPolyTime$ adversary $\cnstAdversary$ with a keypair $\varKeyPairBob$, meaning the attacker plays the role of Bob in the protocol.

    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procExpExt{\varN}$} {
            \varSet \opAssign \cnstEmptySet \\
            \varKeyPairAlice \opFunResult \procSetup{\varSecParam} \\
            (\varSecKeyBob \opSeperate \varMsg \opSeperate \varStatement) \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\cdot}}(\varPubKeyAlice) \\
            (\varSigAlice \opSeperate \varSigBob)\opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
            (\varSigAptBob \opSeperate \varSigFin) \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\cdot}}(\varPubKeyAlice \opSeperate \varSigAlice) \\
            \funStar{\varWit} \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob} \\
            \pcreturn (\varMsg \opNotIn \varSet \opAnd (\varStatement \opSeperate \funStar{\varWit}) \opNotIn \cnstRelation \opAnd \procVerf{\varMsg}{\varSigFin}{\varPubKeyAlice \opAddPoint \varPubKeyBob})
            }\\

            \procedure[linenumbering]{$\procSignOracle{\varMsg}{\varPubKey}$} {
            \varSet \opAssign \varSet \opUnion \varMsg \\
            (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
            \pcreturn \varSigFin
            }
        \end{varwidth}
        }
    \end{center}
    In order to satisfy witness extractability the following must hold:
    \[ \prob{\procExpExt{\varN} \opEqNoQ 1} \opSmEq \funNegl{\varN} \]
\end{definition}


\section{Schnorr-based instantiation}\label{sec:schnorrInst}

We start by providing a general instantiation of a signature scheme (see definition~\ref{def:signatureScheme}):
We assume we have a group $\cnstGroup$ with prime $\varPrime$, $\cnstHash$ is a secure hash function as defined in definition~\ref{def:hashFunction} and $\varMsg \opIn \cnstBinary{*}$ is a message.

\begin{itemize}
    \item $\varKeyPair \opFunResult \procSetup{\varSecParam}$ creates a keypair $\varKeyPair$, the public key can be distributed to the verifier(s) and the secret key has to be kept private. \\
    \item $\varSignature \opFunResult \procSign{\varMsg}{\varSecKey}$ creates a signature consisting of a variable $\varS$ and $\varRand$ which is a commitment to the secret nonce $\varNonce$ used during the signing process.
    As an input it takes a message $\varMsg$ and the secret key $\varSecKey$ of the signer.
    \item $\cnstTrueorFalse \opFunResult \procVerf{\varMsg}{\varSignature}{\varPubKey}$ allows a verifier knowing the signature $\varSignature$, message $\varMsg$ and the provers public key $\varPubKey$ to verify the signatures
    validity. \\
\end{itemize}
A concrete implementation can be seen in figure~\ref{fig:schnorr}. The signature scheme is called schnorr signature scheme, first defined in~\cite{schnorr1989efficient} and is widely employed in many cryptography systems.
\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSetup{\varSecParam}$} {
            \varKey \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \pcreturn (\varSecKey \opAssign \varKey \opSeperate \varPubKey \opAssign \funGen{\varKey})
            }
            \procedure[linenumbering]{$\procSign{\varMsg}{\varSecKey}$}{
            \varNonce \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varRand \opAssign \funGen{\varNonce} \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \varS \opAssign \varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey \\
            \pcreturn \varSignature \opAssign (\varS, \varRand)
            }
            \procedure[linenumbering]{$\procVerf{\varMsg}{\varSignature}{\varPubKey}$} {
            (\varS \opSeperate \varRand) \opFunResult \varSignature \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varS} \opEq \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Schnorr Signature Scheme as first defined in~\cite{schnorr1989efficient}}
    \label{fig:schnorr}
\end{figure}
\cnstCorrectness of the scheme is easy to derive. As $\varS$ is calculated as $\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey$, when generator $\varG$ is raised to $\varS$, we get
$\funGen{\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey}$ which we can transform into $\funGen{\varNonce} \opAddPoint \funGen{\varSecKey \opTimesScalar \varSchnorrChallenge}$, and finally
into $\varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}$ which is the same as the right side of the equation.

From the regular schnorr signature we now provide an instantiation in figure~\ref{fig:twoparty-schnorr} for the two-party case defined in definition~\ref{def:twoPartySig}. Note that this two-party variant of the scheme is what is
currently implemented in the Grin mimblewimble cryptocurrency and will provide a basis from which we will build our adapted scheme.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSetupCtx{\varSigContext}{\varPubKeyAlice}{\varRandAlice}$} {
            \opAccess{\varSigContext}{\varPubKey} \opAssign \opAccess{\varSigContext}{\varPubKey} \opAddPoint \varPubKeyAlice \\
            \opAccess{\varSigContext}{\varRand} \opAssign \opAccess{\varSigContext}{\varRand} \opAddPoint \varRandAlice \\
            \pcreturn \varSigContext
            } \\
            \procedure[linenumbering]{$\procKeyGenPt{\varSecParam}{\varSecParam}$} {
            \textbf{Alice} \< \< \textbf{Bob} \\
            \varSecKeyAlice \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \varSecKeyBob \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varNonceAlice \sample \cnstIntegersPrimeWithoutZero{\varPrime} \< \< \varNonceBob \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varPubKeyAlice \opAssign \funGen{\varSecKeyAlice} \< \< \varPubKeyBob \opAssign \funGen{\varSecKeyBob} \\
            \varRandAlice \opAssign \funGen{\varNonceAlice} \< \< \varRandBob \opAssign \funGen{\varNonceBob} \\
            \varZkpStatementAlice \opAssign \exists \varSecKeyAlice \textit{ s.t. } \funGen{\varSecKeyAlice} \opEqNoQ \varPubKeyAlice \< \< \varZkpStatementBob \opAssign \exists \varSecKeyBob \textit{ s.t. } \funGen{\varSecKeyBob} \opEqNoQ \varPubKeyBob \\
            \varProofAlice \opFunResult \procZkpProve{\varSecKeyAlice}{\varZkpStatementAlice} \< \< \varProofBob \opFunResult \procZkpProve{\varSecKeyBob}{\varZkpStatementBob} \\
            \varSigContext \opAssign \langle \varPubKey \opAssign \cnstIdentityElement \opSeperate \varRand \opAssign \cnstIdentityElement \rangle \< \< \\
            \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyAlice}{\varRandAlice} \< \< \\
            \< \sendmessageright*{\varSigContext, \varPubKeyAlice, \varProofAlice} \< \\
            \< \< \procZkpVerify{\varProofAlice} \opEq 1 \\
            \< \< \varSigContext \opFunResult \procSetupCtx{\varSigContext}{\varPubKeyBob}{\varRandBob} \\
            \< \sendmessageleft*{\varSigContext, \varPubKeyBob, \varProofBob} \< \\
            \procZkpVerify{\varProofBob} \opEq 1 \< \< \\
            \pcreturn (\varSecKeyAlice,\varPubKeyAlice,\varNonceAlice,\varSigContext) \< \< \pcreturn (\varSecKeyBob,\varPubKeyBob,\varNonceBob,\varSigContext)
            } \\
            \procedure[linenumbering]{$\procSignPrt{\varMsg}{\varSecKeyAlice}{\varNonceAlice}{\varSigContext}$} {
            (\varRand \opSeperate \varPubKey) \opFunResult \varSigContext \\
            \varRandAlice \opAssign \funGen{\varNonceAlice} \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \varSAlice \opAssign \varNonceAlice \opAddScalar \varSecKeyAlice \opTimesScalar \varSchnorrChallenge \\
            \pcreturn \varSigAlice \opAssign (\varSAlice, \varRandAlice, \varSigContext)
            }
            \procedure[linenumbering]{$\procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice}$} {
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAlice \\
            (\varPubKey \opSeperate \varRand) \opFunResult \varSigContext \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varSAlice} \opEq \varRandAlice^{\varSchnorrChallenge} \opAddPoint \varPubKeyAlice
            }
            \procedure[linenumbering]{$\procFinSig{\varSigAlice}{\varSigBob}$} {
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAlice \\
            (\varSBob \opSeperate \varRandBob \opSeperate \varSigContext) \opFunResult \varSigBob \\
            (\varPubKey \opSeperate \varRand) \opFunResult \varSigContext \\
            \varS \opAssign \varSAlice \opAddScalar \varSBob \\
            \varSigFin \opAssign (\varS, \varRand) \\
            \pcreturn \varSigFin
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Two Party Schnorr Signature Scheme}
    \label{fig:twoparty-schnorr}
\end{figure}

We further show in figure~\ref{fig:twoparty-schnorr-prot} how Alice and Bob can cooperate to produce a final signature which fulfills \cnstCorrectness as defined in definition~\ref{def:signatureScheme}.

\begin{figure}
    \centering
    \pseudocode[codesize=\scriptsize]{
    \textbf{Alice} \; \varKeyPairAlice \< \< \textbf{Bob} \; \varKeyPairBob \\ [][\hline]
    \< \<  \\
    \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
    (\varSigAlice) \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyAlice} \< \< (\varSigBob) \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyBob} \\
    \< \sendmessageleft*{\varSigBob} \< \\
    \procVerfPtSig{\varSigBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob} \opEq 1 \\
    \< \sendmessageright*{\varSigAlice} \< \\
    \< \< \procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob} \opEq 1 \\
    \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob}
    }
    \caption{Two Party Schnorr Signature Scheme Interaction}
    \label{fig:twoparty-schnorr-prot}
\end{figure}

The final signature is a valid signature to the message $\varMsg$ with the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$.
A verifier knowing the signed message $\varMsg$, the final signature $\varSigFin$ and the composite public key $\varPubKeyComp$ can now verify the signature using the regular $\procVerfId$ procedure.
The challenge $\varSchnorrChallenge$ will be the same because
\[ \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \opEqNoQ \funHash{\varMsg \opConc \varRandAlice \opAddPoint \varRandBob \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob} \]

In figure~\ref{fig:aptSchnorr} we further provide a schnorr-based instantiation for the fixed witness adapted signature scheme as defined in definition~\ref{def:twoPartyFixedWitAptSig}:

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procAptSig{\varSigPt}{\varWit}$}{
            (\varS \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigPt \\
            \varSStar \opAssign \varS \opAddScalar \varWit \\
            \pcreturn \varSigApt \opAssign (\varSStar \opSeperate \varRandAlice \opSeperate \varSigContext)
            } \\
            \procedure[linenumbering]{$\procVerifyAptSig{\varSigAptAlice}{\varMsg}{\varPubKeyAlice}{\varStatement}$} {
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAptAlice \\
            (\varPubKey, \varRand) \opFunResult \varSigContext \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varSAlice} \opEq \varRandAlice^\varSchnorrChallenge \opAddPoint \varPubKeyAlice \opAddPoint \varStatement
            }
            \procedure[linenumbering]{$\procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}$}{
            (\varS \opSeperate \varRand) \opFunResult \varSigFin \\
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varSigContext) \opFunResult \varSigAlice \\
            (\varSAptBob \opSeperate \varRandBob \opSeperate \varSigContext) \opFunResult \varSigAptBob \\
            \varSBob \opAssign \varS \opSub \varSAlice \\
            \varWit \opAssign \varSAptBob \opSub \varSBob \\
            \pcreturn (\varWit)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Fixed Witness Adaptor Schnorr Signature Scheme}
    \label{fig:aptSchnorr}
\end{figure}

Again in figure~\ref{fig:aptSchnorrInteraction} we show an example interaction between Alice and Bob creating a signature $\varSigFin$ for the composite public key $\varPubKeyBob \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$
while Bob will hide his secret $\varWit$ which Alice can extract after the signing process has completed.

\begin{figure}
    \pseudocode[codesize=\scriptsize]{
    \textbf{Alice} \; \varKeyPairAlice \< \< \textbf{Bob} \; \varKeyPairBob \\ [][\hline]
    \< \<  \\
    \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
    \< \< (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
    \< \sendmessageleft*{\varStatement} \< \\
    \varSigAlice \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyAlice} \< \< \varSigBob \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyBob} \\
    \< \< \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
    \< \sendmessageleft*{\varSigAptBob} \< \\
    \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varStatement} \opEq 1 \< \< \\
    \< \sendmessageright*{\varSigAlice} \< \\
    \< \< \procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob} \opEq 1 \\
    \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
    \< \sendmessageleft*{\varSigFin} \< \\
    \varWit \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigBob}
    }
    \caption{Fixed Witness Adaptor Schnorr Signature Interaction}
    \label{fig:aptSchnorrInteraction}
\end{figure}

\subsection{Correctness \& Security}\label{sec:twopartyAptSecurity}

We now prove that the outlined schnorr-based instantiation is correct, i.e. $\cnstAptSigCorrectness$ holds, as well as secure with regards to the definition \ref{def:aptsigsecure}.

\subsection{\cnstAptSigCorrectness}\label{subsec:cnstaptsigcorrectness}

To prove that $\cnstAptSigCorrectness$ holds we have 3 statements to prove, first we prove that $\procVerf{\varMsg}{\varSigFin}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1$ holds in our schnorr-based instantiation of the signature scheme.

\begin{proof}
    \label{prf:aptSchnorrPreSigCorr}
    For this prove we assume the setup already specified in definition~\ref{def:aptSigCorrectness}.
    The proof is by showing equality of the equation checked by the verifier of the final signature by continuous substitutions in the left side of equation:
    \begin{align}
        \funGen{\varS} &\opEq \varRand \opAddPoint \opPointScalar{\varPubKeyComp}{\varSchnorrChallenge} \\
        \funGen{\varSAlice} \opAddPoint \funGen{\varSBob} & \\
        \funGen{\varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob} & \\
        \funGen{\varNonceAlice} \opAddPoint \opPointScalar{\varPubKeyAlice}{\varSchnorrChallenge} \opAddPoint \funGen{\varNonceBob} \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} & \\
        \varRandAlice \opAddPoint \varPubKeyAlice \opAddPoint \varRandBob \opAddPoint \varPubKeyBob & \\
        \varRand \opAddPoint \opPointScalar{\varPubKeyComp}{\varSchnorrChallenge} & \opEq \varRand \opAddPoint \opPointScalar{\varPubKeyComp}{\varSchnorrChallenge} \\
        1 & \opEq 1
    \end{align}

    It remains to prove that with the same setup $\procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varStatement} \opEq 1$ and
    $(\varStatement \opSeperate \funStar{\varWit}) \opIn \cnstRelation$ hold.

    \[
        \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varStatement} \opEq 1
    \]
    The proof is by continuous substitutions in the equation checked by the verifier:
    \begin{align}
        \funGen{\varSigAptBob} &\opEq \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement \\
        \funGen{\varSigBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob} \opAddPoint \funGen{\varSecKeyBob \opTimesScalar \varSchnorrChallenge} \opAddScalar \funGen{\varWit} & \\
        \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement &\opEq \varRandBob \opAddPoint \opPointScalar{\varPubKeyBob}{\varSchnorrChallenge} \opAddPoint \varStatement \\
        1 &\opEq 1
    \end{align}
    We now continue to prove the last equation required:
    \[
        ((\varStatement \opSeperate \funStar{\varWit}) \opIn \cnstRelation)
    \]
    We do this by showing that $\varWit$ is calculated correctly in $\procExtWitId$:
    \begin{align}
        \varWit \opAssign & \varSApt \opSub (\varS \opSub \varSAlice) \\
        & \varSApt \opSub ((\varSAlice \opAddScalar \varSBob ) \opSub \varSAlice ) \\
        & \varSBob \opAddScalar \varWit \opSub (\varSBob) \\
        \varWit \opAssign & \varWit \\
    \end{align}
\end{proof}

\subsection{\cnstSecureAptScheme}\label{subsec:cnstsecureaptscheme}

In order to prove the security of the scheme we need to provide a proof that both $\cnstaEUFCMA$ and $\cnstWitnessExtractability$ hold in our instantiation.
To perform the proof we must first recall the regular definition of $\cnstEUFCMA$ given for regular schnorr signatures.~\cite{schnorr1989efficient} For that we define the game $\procExpForgeSimpleId$:

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procExpForgeSimple{\varN}$} {
        \varSet \opFunResult \cnstEmptySet \\
        \varKeyPair \opFunResult \procSetup{\varSecParam} \\
        (\varMsg \opSeperate \varSignature) \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\cdot}} \\
        \pcreturn ((\varMsg) \opNotIn \varSet \opAnd \procVerf{\varMsg}{\varSignature}{\varPubKey})
        }
        \procedure[linenumbering]{$\procSignOracle{\varMsg}{\varPubKey}$} {
        \varSignature \opFunResult \procSign{\varMsg}{\varSecKey} \\
        \varSet \opAssign \varSet \opUnion \{ \varMsg \} \\
        \pcreturn \varSignature
        }
    \end{varwidth}
    }
\end{center}

$\cnstEUFCMA$ holds if $\prob{\procExpForgeSimple{\varN} \opEqNoQ 1} \opSmEq \funNegl{\varN}$.

\begin{proof}
    We first proof $\cnstaEUFCMA$ by providing a black box reduction from $\cnstaEUFCMA$ to $\cnstEUFCMA$.
    Intuitively if we suppose there exists a $\cnstPolyTime$ adversary $\cnstAdversary$ that wins the $\procExpForgId$ game with probability $1$,
    then $\cnstAdversary$ will also be able to win the $\procExpForgeSimpleId$ game with the same probability, which leads us to a contradiction.
    This can be achieved by splitting up the public key chosen by the challenger in the $\procExpForgeSimpleId$ game into $\varPubKey_1$ and $\varPubKey_2$ and then running the
    $\procExpForgId$ game using the two split keys.
    Since the signing oracle in $\cnstaEUFCMA$ and $\cnstWitnessExtractability$ both provide a signature valid unter the composite of the two public keys, we can simulate the oracle
    queried by the adversary $\cnstAdversary$ simply by forward the query to the $\cnstEUFCMA$ with the unsplit version of the public key.
    The output of the $\procExpForgId$ game will be a forged final signature valid under the combined public key of $\varPubKey_1$ and $\varPubKey_2$
    which we can then use to win the $\procExpForgId$ game. See figure~\ref{prf:bbreuf} for the black-box reduction.

    \begin{figure}
        \begin{center}
            \begin{bbrenv}{A}
                \begin{bbrbox}[name=\cnstEUFCMA]
                    \pseudocode{
                    \varKeyPair \opFunResult \procSetup{\varSecParam} \\
                    \varPubKey_1 \opAddPoint \varPubKey_2 \opEqNoQ \varPubKey \\
                    \begin{bbrenv}{B}
                        \begin{bbrbox}[name=\cnstaEUFCMA, xshift=4cm]
                            \pseudocode{
                            \varMsg \opAssign \varMsg \\
                            \varPubKeyAlice \opAssign \varPubKey_1 \\
                            \varPubKeyBob \opAssign \varPubKey_2
                            }
                        \end{bbrbox}
                        \bbrmsgto{top={$\varN,\varPubKey_1,\varPubKey_2$}, length=2cm}
                        \bbrmsgfrom{top={$\varMsg,\varSigFin$}, length=2cm}
                        \bbrqryto{top={$\procSignOracle{\varMsg}{\varPubKeyBob}$}, length=2cm}
                        \bbrqryfrom{top={$\varSigFin \opAssign \varSignature$}, length=2cm}
                    \end{bbrenv} \\
                    \varSignature \opAssign \varSigFin
                    }
                \end{bbrbox}
                \begin{bbroracle}{OraA}
                    \begin{bbrbox}[name=$\procSignOracleId$, minheight=1cm]
                    \end{bbrbox}
                \end{bbroracle}
                \bbroracleqryto{top=$\procSignOracle{\varMsg}{\varPubKey}$, length=2cm}
                \bbroracleqryfrom{top=$\varSignature$, length=2cm}
                \bbrinput{n}
                \bbroutput{$\varSignature$}
            \end{bbrenv}
        \end{center}
        \caption{Reduction from \cnstaEUFCMA to \cnstEUFCMA \label{prf:bbreuf}}
    \end{figure}

    In a very similiar way we can provide a reduction from \cnstWitnessExtractability to $\cnstEUFCMA$. Again if we suppose there exists a $\cnstPolyTime$ adversary $\cnstAdversary$ able to win the $\procExpExtId$ game with probability $1$, then $\cnstAdversary$ will always be able to win the $\procExpForgeSimpleId$, leading to a contradiction. Similiar to the previous proof the adversary $\cnstAdversary$ splits up the secret key $\varSecKey$ computed during the $\procExpForgeSimpleId$ game into $\varSecKey_1$ and $\varSecKey_2$ to use them in the $\procExpExtId$. The forged final signature $\varSigFin$ can then be used to win the $\procExpForgeSimpleId$ game. The black-box reduction can be seen in figure~\ref{prf:bbrwit}

    \begin{figure}
        \begin{center}
            \begin{bbrenv}{A}
                \begin{bbrbox}[name=\cnstEUFCMA]
                    \pseudocode{
                    \varKeyPair \opFunResult \procSetup{\varSecParam} \\
                    \varPubKey_1 \opAddPoint \varPubKey_2 \opEqNoQ \varPubKey \\
                    \begin{bbrenv}{B}
                        \begin{bbrbox}[name=Wit. Extr., xshift=4cm]
                            \pseudocode{
                            \varMsg \opAssign \varMsg \\
                            \varPubKeyAlice \opAssign \varPubKey_1 \\
                            \varPubKeyBob \opAssign \varPubKey_2
                            }
                        \end{bbrbox}
                        \bbrmsgto{top={$\varN,\varPubKey_1,\varPubKey_2$}, length=2cm}
                        \bbrmsgfrom{top={$\varMsg,\varSigFin$}, length=2cm}
                        \bbrqryto{top={$\procSignOracle{\varMsg}{\varPubKeyBob}$}, length=2cm}
                        \bbrqryfrom{top={$\varSigFin \opAssign \varSignature$}, length=2cm}
                    \end{bbrenv} \\
                    \varSignature \opAssign \varSigFin
                    }
                \end{bbrbox}
                \begin{bbroracle}{OraA}
                    \begin{bbrbox}[name=$\procSignOracleId$, minheight=1cm]
                    \end{bbrbox}
                \end{bbroracle}
                \bbroracleqryto{top=$\procSignOracle{\varMsg}{\varPubKey}$, length=2cm}
                \bbroracleqryfrom{top=$\varSignature$, length=2cm}
                \bbrinput{n}
                \bbroutput{$\varSignature$}
            \end{bbrenv}
        \end{center}
        \caption{Reduction from \cnstWitnessExtractability to \cnstEUFCMA \label{prf:bbrwit}}
    \end{figure}

\end{proof}