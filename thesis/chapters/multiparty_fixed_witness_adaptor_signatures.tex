In this chapter, we will define a variant of the adaptor signature scheme as explained in~\ref{sec:aptSignatures}. The main difference in the protocol outlined in this thesis is that one of the two parties does know the fixed secret witness before the start of the protocol. The aim of the protocol will then be that the other person is able to extract the witness from the final signature. This feature such that we can later build an atomic swap protocol on top of it.  

First we will define the general two-party signature creation protocol as it is currently implemented for example in the Grin cryptocurrency.
We reduce the generated signatures to the general case~\cite{schnorr1989efficient} and thereby prove its correctness.
From this protocol, we then derive the adapted variant, which allows hiding a fixed witness
value in the signature, which can be revealed only by the other party after attaining the final signature.
We start by defining our extended signature scheme in section~\ref{sec:definitions}, proceed by providing a schnorr-based instantiation of the protocol in section~\ref{sec:schnorrInst} and finally prove its security in section~\ref{sec:twopartyAptSecurity}.

\section{Definitions}\label{sec:definitions}

A two-party signature scheme wrt. a hard relation $\cnstRelation$ is an extension of a signature scheme as defined in definition~\ref{def:signatureScheme}, which allows us to distribute signature generation for a composite public key shared between two parties Alice and Bob.
    Alice and Bob want to collaborate to generate a signature valid under the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice + \varPubKeyBob$ without having to reveal their secret keys to each other.\begin{definition}[Two Party Signature Scheme]
    \label{def:twoPartySig}
     We extend the regular definition of a signature scheme~\ref{def:signatureScheme} with three functions:
    \[
        \varSigSchemeMP = (\varSigScheme \opConc \procSignPtId \opSeperate \procVerfPtSigId \opSeperate \procFinSigId)
    \]
    
    \begin{itemize}
        \item $(\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob}$ is defined as a two-party procedure which requires both Alice and Bob to provide their secret key and a message which should be signed. The parties collaborate to both calculate their own partial signatures. These partial signatures do not need to be valid signatures yet, but the other participating parties need to be able to verify them using the $\procVerfPtSigId$ procedure.
        \item $\cnstTrueorFalse \opFunResult \procVerfPtSig{\varSigBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}$ Is a function which lets one party verify the partial signature of the other party. As input it requires the partial signature, signed message and the participants public keys. The output will be either 1 if the verification was successfull or 0 otherwise.
        \item $\varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob})$ will take the two partial signatures and combine them into a final valid signature under the participants composite public key.
    \end{itemize}
\end{definition}

\begin{definition}[Two Party Fixed Witness Adaptor Schnorr Signature Scheme]
    \label{def:twoPartyFixedWitAptSig}
    From the definition~\ref{def:twoPartySig}, we now derive an adapted signature scheme $\varSigSchemeApt$, which allows one of the participants to hide the discrete logarithm $\varWit$ of a statement $\varStatement$ chosen
    at the beginning of the protocol. Again we extend our previously defined signature scheme with new functions:
    \[ \varSigSchemeApt \opAssign (\varSigSchemeMP \opConc \procAptSigId \opConc \procVerifyAptSigId \opConc \procExtWitId) \]
    
    \begin{itemize}
        \item $\varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit}$ takes as input a partial signature $\varSigPt$ and a secret witness value $\varWit$. The procedure will output an adapted partial signature $\varSigApt$ which can be verified to contain $\varWit$ using the $\procVerifyAptSigId$ function, without immidiately revealing $\varWit$.
        \item $\cnstTrueorFalse \opFunResult \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varStatement}$ takes as input an adapted partial signature $\varSigApt$, the participants public keys and a statement $\varStatement$. The function will verify the partial signature's validity as well that it contains the secret witness $\varWit$.
        \item $\varWit \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}$ lets Alice extract the secret witness $\varWit$ from the final composite signature. Note that to extract the witness $\varWit$ the partial signatures shared between the participants beforehand and the statement $\varStatement$ needs to be provided as inputs. This makes sure that only participants of the procotol will be able to perform the extraction.
    \end{itemize}
\end{definition}

\begin{definition}[Secure Adaptor Signature Scheme]
    As defined by Aumayr et al. in~\cite{aumayr2020bitcoinchannels}, a secure adaptor signature scheme needs two security properties to be fulfilled:
    \begin{enumerate}
        \item \cnstaEUFCMA
        \item \cnstWitnessExtractability
    \end{enumerate}
\end{definition}

We proceed by redefining these properties as well as adapted correctness for our adapted two-party fixed witness signature scheme defined in definition~\ref{def:twoPartyFixedWitAptSig}:

\begin{definition}[\cnstAptSigCorrectness]\label{def:aptSigCorrectness}
Similar to how it is defined in~\cite{aumayr2020bitcoinchannels} additionally to \cnstCorrectness as defined in~\ref{def:signatureScheme} we require our signature scheme to satisfy \cnstAptSigCorrectness.
This property is given when every adapted partial signature generated by $\procAptSigId$ can be completed into a final signature for all pairs $(\varWit \opSeperate \varStatement) \opIn \cnstRelation$, from which it will
be possible to extract the witness computing $\procExtWitId$ with the required parameters.

More formally \cnstAptSigCorrectness is given if for every security parameter $\varN \in \cnstNatural$, message $\varMsg \in \cnstBinary{*}$, keypairs $\varKeyPairAlice \opFunResult \procSetup{\varSecParam} \opSeperate
\varKeyPairBob \opFunResult \procSetup{\varSecParam}$
with their composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$ and every statement/witness pair $(\varStatement \opSeperate \varWit)$ in a relation $\cnstRelation$ it must hold that:
\[
    \Pr\left[
    \begin{array}{c}
        1.\:\procVerf{\varMsg}{\varSigFin}{\varPubKeyComp} \opEq 1 \\
        \opAnd \\
        2.\: \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varStatement} \opEq 1 \\
        \opAnd \\
        3.\:(\varStatement \opSeperate \funStar{\varWit} \opIn \cnstRelation)
    \end{array}
    \middle\vert
    \begin{array}{l}
        (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
        (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
        \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
        \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
        \funStar{\varWit} \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}
    \end{array}
    \right]=1.
\]
\end{definition}

\begin{definition}[$\cnstaEUFCMA$]\label{def:aeufcma}
Additionally to the regular definition of \textit{existential unforgeability under chosen message attacks} as defined for example in~\cite{vaudenay2006classical} we require that it is hard to produce a forged partial signature $\varSigPt$ if the
adversary $\cnstAdversary$ gets to know a valid adapted signature $\varSigApt$ w.r.t. some message $\varMsg$ and a statement $\varStatement$.

For the definition of $\cnstaEUFCMA$-security we define the experiment $\procExpForgId$ for a $\cnstPolyTime$ adversary $\cnstAdversary$ with a keypair $(\varSecKeyAlice \opSeperate \varPubKeyAlice)$,
meaning the attacker plays the role of Alice in the protocol and an adapted signature scheme $\varSigSchemeApt$ as
follows:

\begin{center}
    \fbox{
    \begin{varwidth}{\textwidth}
        \procedure[linenumbering]{$\procExpForg{\varN}$} {
        \varSet \opAssign \cnstEmptySet \\
        \varKeyPairBob \opFunResult \procSetup{\varSecParam} \\
        (\varMsg \opSeperate \varSecKeyAlice) \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\cdot}}(\varPubKeyBob) \\
        (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
        (\varSigPtAdv \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
        \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
        \funStar{\varSigPtAdv} \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\cdot}}(\varSigBob) \\
        \varSigFin \opFunResult \procFinSig{\funStar{\varSigPtAdv}}{\varSigBob} \\
        \pcreturn (\varMsg \opNotIn \varSet \opAnd \procVerf{\varMsg}{\varSigFin}{\varPubKeyAlice \opAddPoint \varPubKeyBob})
        }\\[2\baselineskip]
        \procedure[linenumbering]{$\procSignOracle{\varMsg}{\varSecKeyAlice}$} {
        \varSet \opAssign \varSet \opUnion {\varMsg} \\
        (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
        (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
        \varSigAptBob \opFunResult \procAptSig{\varSigPt}{\varWit} \\
        \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigAptBob} \\
        \pcreturn (\varSigFin \opSeperate \varStatement)
        }\\[2\baselineskip]
    \end{varwidth}
    }
\end{center}
The adapted signature scheme $\varSigSchemeApt$ is called $\cnstaEUFCMA$-secure if
\[ \prob{\procExpForg{\varN} \opEq 1} \opSmEq \funNegl{n} \]
\end{definition}

\begin{definition}[\cnstWitnessExtractability]
    Informally the \cnstWitnessExtractability property holds for an adapted signature scheme $\varSigSchemeApt$ computed for the statement $\varStatement$ when we can always extract the witness
    $(\varWit \opSeperate \varStatement)$ from the final signature $\varSigFin$, given the partial signatures of the participants.
    To formalize this statement we describe an experiment $\procExpExtId$ for a $\cnstPolyTime$ adversary $\cnstAdversary$ with a keypair $\varKeyPairBob$, meaning the attacker plays the role of Bob in the protocol.

    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procExpExt{\varN}$} {
            \varSet \opAssign \cnstEmptySet \\
            \varKeyPairAlice \opFunResult \procSetup{\varSecParam} \\
            (\varSecKeyBob \opSeperate \varMsg \opSeperate \varStatement) \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\cdot}}(\varPubKeyAlice) \\
            (\varSigAlice \opSeperate \varSigBob)\opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
            \varSigAptBob \opFunResult \cnstAdversary^{\procSignOracle{\cdot}{\cdot}}(\varPubKeyAlice \opSeperate \varSigAlice) \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
            \funStar{\varWit} \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob} \\
            \pcreturn (\varMsg \opNotIn \varSet \opAnd (\varStatement \opSeperate \funStar{\varWit}) \opNotIn \cnstRelation \opAnd \procVerf{\varMsg}{\varSigFin}{\varPubKeyAlice \opAddPoint \varPubKeyBob})
            }\\

            \procedure[linenumbering]{$\procSignOracle{\varMsg}{\varSecKeyBob}$} {
            \varSet \opAssign \varSet \opUnion \varMsg \\
            (\varSigAlice \opSeperate \varSigBob) \opFunResult \procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob} \\
            \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
            \pcreturn \varSigFin
            }
        \end{varwidth}
        }
    \end{center}
    In order to satisfy witness extractability the following must hold:
    \[ \prob{\procExpExt{\varN} \opEq 1} \opSmEq \funNegl{\varN} \]
\end{definition}

\section{Schnorr-based instantiation}\label{sec:schnorrInst}

We start by providing a general instantiation of a signature scheme (see definition~\ref{def:signatureScheme}):
We assume we have a group $\cnstGroup$ with prime $\varPrime$, $\cnstHash$ is a secure hash function as defined in definition~\ref{def:hashFunction} and $\varMsg \opIn \cnstBinary{*}$ is a message.

\begin{itemize}
    \item $\procSetupId$ creates a keypair $\varKeyPair$, the public key can be distributed to the verifier(s) and the secret key has to be kept private. \\
    \item $\procSignId$ creates a signature consisting of a variable $\varS$ and $\varRand$ which is a commitment to the secret nonce $\varNonce$ used during the signing process.
    \item $\procVerfId$ allows a verifier knowing the signature $\varSignature$, message $\varMsg$ and the provers public key $\varPubKey$ to verify the signatures validity. \\
\end{itemize}
A concrete implementation can be seen in figure~\ref{fig:schnorr}. The signature scheme is called schnorr signature scheme, first defined in~\cite{schnorr1989efficient} and is widely employed in many cryptography systems.
\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSetup{\varSecParam}$} {
            \varKey \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \pcreturn (\varSecKey \opAssign \varKey \opSeperate \varPubKey \opAssign \funGen{\varKey})
            }
            \procedure[linenumbering]{$\procSign{\varMsg}{\varSecKey}$}{
            \varNonce \sample \cnstIntegersPrimeWithoutZero{\varPrime} \\
            \varRand \opAssign \funGen{\varNonce} \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \varS \opAssign \varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey \\
            \pcreturn \varSignature \opAssign (\varS, \varRand)
            }
            \procedure[linenumbering]{$\procVerf{\varMsg}{\varSignature}{\varPubKey}$} {
            (\varS \opSeperate \varRand) \opFunResult \varSignature \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKey} \\
            \pcreturn \funGen{\varS} \opEq \varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Schnorr Signature Scheme as first defined in~\cite{schnorr1989efficient}}
    \label{fig:schnorr}
\end{figure}
\cnstCorrectness of the scheme is easy to derive. As $\varS$ is calculated as $\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey$, when generator $\varG$ is raised to $\varS$, we get
$\funGen{\varNonce \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKey}$ which we can transform into $\funGen{\varNonce} \opAddPoint \funGen{\varSecKey \opTimesScalar \varSchnorrChallenge}$, and finally
into $\varRand \opAddPoint \opPointScalar{\varPubKey}{\varSchnorrChallenge}$ which is the same as the right side of the equation.

From the regular schnorr signature we now provide an instantiation in figure~\ref{fig:twoparty-schnorr} for the two-party case defined in definition~\ref{def:twoPartySig}. Note that this two-party variant of the scheme is what is
currently implemented in the Grin mimblewimble cryptocurrency and will provide a basis from which we will build our adapted scheme.

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procSignPt{\varMsg}{\varSecKeyAlice}{\varSecKeyBob}$} {
            \varNonceAlice \sample \cnstIntegersPrimeWithoutZero{\varSecParam} \< \< \varNonceBob \sample \cnstIntegersPrimeWithoutZero{\varSecParam} \\
            \varRandAlice \opAssign \funGen{\varNonceAlice} \< \< \varRandBob \opAssign \funGen{\varNonceBob} \\
            \< \sendmessageright*{\varRandAlice} \< \\
            \< \sendmessageleft*{\varRandBob} \< \\
            \varRand \opAssign \varRandAlice \opAddPoint \varRandBob \< \< \varRand \opAssign \varRandAlice \opAddPoint \varRandBob \\
            \varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob \< \< \varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \< \< \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \\
            \varSAlice \opAssign \varNonceAlice \opAddScalar \varSecKeyAlice \opTimesScalar \varSchnorrChallenge \< \< \varSBob \opAssign \varNonceBob \opAddScalar \varSecKeyBob \opTimesScalar \varSchnorrChallenge \\
            \varSigAlice \opAssign (\varSAlice \opSeperate \varRandAlice \opSeperate \varRandBob) \< \< \varSigBob \opAssign (\varSBob \opSeperate \varRandAlice \opSeperate \varRandBob) \\
            \pcreturn (\varSigAlice \opSeperate \varSigBob) \< \<
            } \\
            \procedure[linenumbering]{$\procVerfPtSig{\varSigBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}$} {
            (\varSBob \opSeperate \varRandAlice \opSeperate \varRandBob) \opFunResult \varSigBob \\
            \varRand \opAssign \varRandAlice \opAddPoint \varRandBob \\
            \varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \\
            \pcreturn \funGen{\varSBob} \opEq \varRandBob^{\varSchnorrChallenge} \opAddPoint \varPubKeyBob
            }
            \procedure[linenumbering]{$\procFinSig{\varSigAlice}{\varSigBob}$} {
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varRandBob) \opFunResult \varSigAlice \\
            (\varSBob \opSeperate \varRandAlice \opSeperate \varRandBob) \opFunResult \varSigBob \\
            \varRand \opAssign \varRandAlice \opAddPoint \varRandBob \\
            \varS \opAssign \varSAlice \opAddScalar \varSBob \\
            \varSigFin \opAssign (\varS, \varRand) \\
            \pcreturn \varSigFin
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Two Party Schnorr Signature Scheme}
    \label{fig:twoparty-schnorr}
\end{figure}

We further show in figure~\ref{fig:twoparty-schnorr-prot} how Alice and Bob can cooperate to produce a final signature which fulfills \cnstCorrectness as defined in definition~\ref{def:signatureScheme}.

\begin{figure}
    \centering
    \pseudocode[codesize=\scriptsize]{
    \textbf{Alice} \; \varKeyPairAlice \< \< \textbf{Bob} \; \varKeyPairBob \\ [][\hline]
    \< \<  \\
    \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
    (\varSigAlice) \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyAlice} \< \< (\varSigBob) \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyBob} \\
    \< \sendmessageleft*{\varSigBob} \< \\
    \procVerfPtSig{\varSigBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob} \opEq 1 \\
    \< \sendmessageright*{\varSigAlice} \< \\
    \< \< \procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob} \opEq 1 \\
    \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob}
    }
    \caption{Two Party Schnorr Signature Scheme Interaction}
    \label{fig:twoparty-schnorr-prot}
\end{figure}

The final signature is a valid signature to the message $\varMsg$ with the composite public key $\varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$.
A verifier knowing the signed message $\varMsg$, the final signature $\varSigFin$ and the composite public key $\varPubKeyComp$ can now verify the signature using the regular $\procVerfId$ procedure.
The challenge $\varSchnorrChallenge$ will be the same because
\[ \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \opEq \funHash{\varMsg \opConc \varRandAlice \opAddPoint \varRandBob \opConc \varPubKeyAlice \opAddPoint \varPubKeyBob} \]

In figure~\ref{fig:aptSchnorr} we further provide a schnorr-based instantiation for the fixed witness adapted signature scheme as defined in definition~\ref{def:twoPartyFixedWitAptSig}:

\begin{figure}
    \begin{center}
        \fbox{
        \begin{varwidth}{\textwidth}
            \procedure[linenumbering]{$\procAptSig{\varSigPt}{\varWit}$}{
            (\varS \opSeperate \varRandAlice \opSeperate \varRandBob) \opFunResult \varSigPt \\
            \varSStar \opAssign \varS \opAddScalar \varWit \\
            \pcreturn \varSigApt \opAssign (\varSStar \opSeperate \varRandAlice \opSeperate \varRandBob)
            } \\
            \procedure[linenumbering]{$\procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varStatement}$} {
            (\varSBob \opSeperate \varRandAlice \opSeperate \varRandBob) \opFunResult \varSigAptBob \\
            \varRand \opAssign \varRandAlice \opAddPoint \varRandBob \\
            \varPubKeyComp \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob \\
            \varSchnorrChallenge \opAssign \funHash{\varMsg \opConc \varRand \opConc \varPubKeyComp} \\
            \pcreturn \funGen{\varSBob} \opEq \varRandBob^\varSchnorrChallenge \opAddPoint \varPubKeyBob \opAddPoint \varStatement
            }
            \procedure[linenumbering]{$\procExtWit{\varSigFin}{\varSigAlice}{\varSigAptBob}$}{
            (\varS \opSeperate \varRand) \opFunResult \varSigFin \\
            (\varSAlice \opSeperate \varRandAlice \opSeperate \varRandBob) \opFunResult \varSigAlice \\
            (\funStar{\varSBob} \opSeperate \varRandAlice \opSeperate \varRandBob) \opFunResult \varSigAptBob \\
            \varSBob \opAssign \varS \opSub \varSAlice \\
            \varWit \opAssign \funStar{\varSBob} \opSub \varSBob \\
            \pcreturn (\varWit)
            }
        \end{varwidth}
        }
    \end{center}
    \caption{Fixed Witness Adaptor Schnorr Signature Scheme}
    \label{fig:aptSchnorr}
\end{figure}

Again in figure~\ref{fig:aptSchnorrInteraction} we show an example interaction between Alice and Bob creating a signature $\varSigFin$ for the composite public key $\varPubKeyBob \opAssign \varPubKeyAlice \opAddPoint \varPubKeyBob$
while Bob will hide his secret $\varWit$ which Alice can extract after the signing process has completed.

\begin{figure}
    \pseudocode[codesize=\scriptsize]{
    \textbf{Alice} \; \varKeyPairAlice \< \< \textbf{Bob} \; \varKeyPairBob \\ [][\hline]
    \< \<  \\
    \< \text{Public Parameters: } \varMsg \opSeperate \varSecParam \< \\
    \< \< (\varWit \opSeperate \varStatement) \opFunResult \procGenR{\varSecParam} \\
    \< \sendmessageleft*{\varStatement} \< \\
    \varSigAlice \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyAlice} \< \< \varSigBob \opFunResult \procSignPtSingle{\varMsg}{\varSecKeyBob} \\
    \< \< \varSigAptBob \opFunResult \procAptSig{\varSigBob}{\varWit} \\
    \< \sendmessageleft*{\varSigAptBob} \< \\
    \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varStatement} \opEq 1 \< \< \\
    \< \sendmessageright*{\varSigAlice} \< \\
    \< \< \procVerfPtSig{\varSigAlice}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob} \opEq 1 \\
    \< \< \varSigFin \opFunResult \procFinSig{\varSigAlice}{\varSigBob} \\
    \< \sendmessageleft*{\varSigFin} \< \\
    \varWit \opFunResult \procExtWit{\varSigFin}{\varSigAlice}{\varSigBob}
    }
    \caption{Fixed Witness Adaptor Schnorr Signature Interaction}
    \label{fig:aptSchnorrInteraction}
\end{figure}

\section{Security}\label{sec:twopartyAptSecurity}

We now show that the outlined instantiation is secure with regards to the regular signature scheme definition~\ref{def:signatureScheme} and the adaptor signature scheme definition~\ref{def:twoPartyFixedWitAptSig}.
We start by proving \cnstCorrectness of the scheme by showing that for two partial signatures $\varSigAlice$ and $\varSigBob$:
\[ \procVerf{\varMsg}{\procFinSig{\varSigAlice}{\varSigBob}}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1 \]



\begin{proof}
    \label{prf:aptSchnorr}
    The correctness proof is by showing equality of the equation checked by the verifier by continous substitutions in the left side of equation:
    \begin{align}
        \funGen{\varS} &\opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp \\
        \funGen{\varSAlice} \opAddPoint \funGen{\varSBob} & \\
        \funGen{\varNonceAlice \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob} & \\
        \funGen{\varNonceAlice \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyAlice} \opAddPoint \funGen{\varNonceBob \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyBob} & \\
        \opPointScalar{\varRandAlice}{\varSchnorrChallenge} \opAddPoint \varPubKeyAlice \opAddPoint \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob & \\
        \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp & \opEq \opPointScalar{\varRand}{\varSchnorrChallenge} \opAddPoint \varPubKeyComp \\
        1 & \opEq 1
    \end{align}
    \todo[inline]{Pedro: I am not sure about the step 4.4}
\end{proof}

Next we provide a proof that in addition to regular \cnstCorrectness also \cnstAptSigCorrectness holds.
Note that we have 3 statements to prove, we have already proven that $\procVerf{\varMsg}{\varSigFin}{\varPubKeyAlice \opAddPoint \varPubKeyBob} \opEq 1$ holds in our instantiation of the signature scheme in the
correctness proof~\ref{prf:aptSchnorr}.
It remains to prove that with the same setup $\procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varStatement} \opEq 1$ and
$(\varStatement \opSeperate \funStar{\varWit}) \opIn \cnstRelation$ hold.

\begin{proof}
    \label{prf:aptSchnorrPreSigCorr}
    For this prove we assume the setup already specified in definition~\ref{def:aptSigCorrectness}.
    First we prove that the following statement:
    \[
        \procVerifyAptSig{\varSigAptBob}{\varMsg}{\varPubKeyAlice}{\varPubKeyBob}{\varStatement} \opEq 1
    \]
    The proof is by continuous substitutions in the equation checked by the verifier:
    \begin{align}
        \funGen{\varSigAptBob} &\opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement \\
        \funGen{\varSigBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opAddScalar \varSchnorrChallenge \opTimesScalar \varSecKeyBob \opAddScalar \varWit} & \\
        \funGen{\varNonceBob \opTimesScalar \varSchnorrChallenge} \opAddPoint \funGen{\varSecKeyBob} \opAddScalar \funGen{\varWit} & \\
        \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement &\opEq \opPointScalar{\varRandBob}{\varSchnorrChallenge} \opAddPoint \varPubKeyBob \opAddPoint \varStatement \\
        1 &\opEq 1
    \end{align}
    We now continue to prove the last equation required:
    \[
        (\varStatement \opSeperate \funStar{\varWit} \opIn \cnstRelation)
    \]
    To prove correctness we show that $\varWit$ is calculated correctly in $\procExtWitId$:
    \begin{align}
        \varWit \opAssign & \funStar{\varSBob} \opSub (\varS \opSub \varSAlice) \\
        & \funStar{\varSBob} \opSub ((\varSAlice \opAddScalar \varSBob ) \opSub \varSAlice ) \\
        & \varSBob \opAddScalar \varWit \opSub (\varSBob) \\
        \varWit \opAssign & \varWit \\
    \end{align}
	\todo[inline]{Pedro: I am not sure about step 4.11. I think that having $s'_B$ and $s_B$ is confusing.}
\end{proof}

TODO Proof for pre-signature adaptability, $\cnstaEUFCMA$ and witness extractability.